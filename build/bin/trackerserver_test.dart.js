// Generated by dart2js, the Dart to JavaScript compiler.
// The code supports the following hooks:
// dartPrint(message):
//    if this function is defined it is called instead of the Dart [print]
//    method.
//
// dartMainRunner(main, args):
//    if this function is defined, the Dart [main] method will not be invoked
//    directly. Instead, a closure that will invoke [main], and its arguments
//    [args] is passed to [dartMainRunner].
(function($) {
function dart(){ this.x = 0 }var A = new dart;
delete A.x;
var B = new dart;
delete B.x;
var C = new dart;
delete C.x;
var D = new dart;
delete D.x;
var E = new dart;
delete E.x;
var F = new dart;
delete F.x;
var G = new dart;
delete G.x;
var H = new dart;
delete H.x;
var J = new dart;
delete J.x;
var K = new dart;
delete K.x;
var L = new dart;
delete L.x;
var M = new dart;
delete M.x;
var N = new dart;
delete N.x;
var O = new dart;
delete O.x;
var P = new dart;
delete P.x;
var Q = new dart;
delete Q.x;
var R = new dart;
delete R.x;
var S = new dart;
delete S.x;
var T = new dart;
delete T.x;
var U = new dart;
delete U.x;
var V = new dart;
delete V.x;
var W = new dart;
delete W.x;
var X = new dart;
delete X.x;
var Y = new dart;
delete Y.x;
var Z = new dart;
delete Z.x;
function Isolate() {}
init();

$ = Isolate.$isolateProperties;
var $$ = {};

// Native classes
(function(reflectionData) {
  "use strict";
  function map(x) {
    x = {x: x};
    delete x.x;
    return x;
  }
  function processStatics(descriptor) {
    for (var property in descriptor) {
      if (!hasOwnProperty.call(descriptor, property))
        continue;
      if (property === "^")
        continue;
      var element = descriptor[property];
      var firstChar = property.substring(0, 1);
      var previousProperty;
      if (firstChar === "+") {
        mangledGlobalNames[previousProperty] = property.substring(1);
        var flag = descriptor[property];
        if (flag > 0)
          descriptor[previousProperty].$reflectable = flag;
        if (element && element.length)
          init.typeInformation[previousProperty] = element;
      } else if (firstChar === "@") {
        property = property.substring(1);
        $[property]["@"] = element;
      } else if (firstChar === "*") {
        globalObject[previousProperty].$defaultValues = element;
        var optionalMethods = descriptor.$methodsWithOptionalArguments;
        if (!optionalMethods) {
          descriptor.$methodsWithOptionalArguments = optionalMethods = {};
        }
        optionalMethods[property] = previousProperty;
      } else if (typeof element === "function") {
        globalObject[previousProperty = property] = element;
        functions.push(property);
        init.globalFunctions[property] = element;
      } else if (element.constructor === Array) {
        addStubs(globalObject, element, property, true, descriptor, functions);
      } else {
        previousProperty = property;
        var newDesc = {};
        var previousProp;
        for (var prop in element) {
          if (!hasOwnProperty.call(element, prop))
            continue;
          firstChar = prop.substring(0, 1);
          if (prop === "static") {
            processStatics(init.statics[property] = element[prop]);
          } else if (firstChar === "+") {
            mangledNames[previousProp] = prop.substring(1);
            var flag = element[prop];
            if (flag > 0)
              element[previousProp].$reflectable = flag;
          } else if (firstChar === "@" && prop !== "@") {
            newDesc[prop.substring(1)]["@"] = element[prop];
          } else if (firstChar === "*") {
            newDesc[previousProp].$defaultValues = element[prop];
            var optionalMethods = newDesc.$methodsWithOptionalArguments;
            if (!optionalMethods) {
              newDesc.$methodsWithOptionalArguments = optionalMethods = {};
            }
            optionalMethods[prop] = previousProp;
          } else {
            var elem = element[prop];
            if (prop !== "^" && elem != null && elem.constructor === Array && prop !== "<>") {
              addStubs(newDesc, elem, prop, false, element, []);
            } else {
              newDesc[previousProp = prop] = elem;
            }
          }
        }
        $$[property] = [globalObject, newDesc];
        classes.push(property);
      }
    }
  }
  function addStubs(descriptor, array, name, isStatic, originalDescriptor, functions) {
    var f, funcs = [originalDescriptor[name] = descriptor[name] = f = array[0]];
    f.$stubName = name;
    functions.push(name);
    for (var index = 0; index < array.length; index += 2) {
      f = array[index + 1];
      if (typeof f != "function")
        break;
      f.$stubName = array[index + 2];
      funcs.push(f);
      if (f.$stubName) {
        originalDescriptor[f.$stubName] = descriptor[f.$stubName] = f;
        functions.push(f.$stubName);
      }
    }
    for (var i = 0; i < funcs.length; index++, i++) {
      funcs[i].$callName = array[index + 1];
    }
    var getterStubName = array[++index];
    array = array.slice(++index);
    var requiredParameterInfo = array[0];
    var requiredParameterCount = requiredParameterInfo >> 1;
    var isAccessor = (requiredParameterInfo & 1) === 1;
    var isSetter = requiredParameterInfo === 3;
    var isGetter = requiredParameterInfo === 1;
    var optionalParameterInfo = array[1];
    var optionalParameterCount = optionalParameterInfo >> 1;
    var optionalParametersAreNamed = (optionalParameterInfo & 1) === 1;
    var isIntercepted = requiredParameterCount + optionalParameterCount != funcs[0].length;
    var functionTypeIndex = array[2];
    var unmangledNameIndex = 2 * optionalParameterCount + requiredParameterCount + 3;
    var isReflectable = array.length > unmangledNameIndex;
    if (getterStubName) {
      f = tearOff(funcs, array, isStatic, name, isIntercepted);
      descriptor[name].$getter = f;
      f.$getterStub = true;
      if (isStatic)
        init.globalFunctions[name] = f;
      originalDescriptor[getterStubName] = descriptor[getterStubName] = f;
      funcs.push(f);
      if (getterStubName)
        functions.push(getterStubName);
      f.$stubName = getterStubName;
      f.$callName = null;
      if (isIntercepted)
        init.interceptedNames[getterStubName] = true;
    }
    if (isReflectable) {
      for (var i = 0; i < funcs.length; i++) {
        funcs[i].$reflectable = 1;
        funcs[i].$reflectionInfo = array;
      }
      var mangledNames = isStatic ? init.mangledGlobalNames : init.mangledNames;
      var unmangledName = array[unmangledNameIndex];
      var reflectionName = unmangledName;
      if (getterStubName)
        mangledNames[getterStubName] = reflectionName;
      if (isSetter) {
        reflectionName += "=";
      } else if (!isGetter) {
        reflectionName += ":" + requiredParameterCount + ":" + optionalParameterCount;
      }
      mangledNames[name] = reflectionName;
      funcs[0].$reflectionName = reflectionName;
      funcs[0].$metadataIndex = unmangledNameIndex + 1;
      if (optionalParameterCount)
        descriptor[unmangledName + "*"] = funcs[0];
    }
  }
  function tearOffGetterNoCsp(funcs, reflectionInfo, name, isIntercepted) {
    return isIntercepted ? new Function("funcs", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "(x) {" + "if (c === null) c = H.closureFromTearOff(" + "this, funcs, reflectionInfo, false, [x], name);" + "return new c(this, funcs[0], x, name);" + "}")(funcs, reflectionInfo, name, H, null) : new Function("funcs", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "() {" + "if (c === null) c = H.closureFromTearOff(" + "this, funcs, reflectionInfo, false, [], name);" + "return new c(this, funcs[0], null, name);" + "}")(funcs, reflectionInfo, name, H, null);
  }
  function tearOffGetterCsp(funcs, reflectionInfo, name, isIntercepted) {
    var cache = null;
    return isIntercepted ? function(x) {
      if (cache === null)
        cache = H.closureFromTearOff(this, funcs, reflectionInfo, false, [x], name);
      return new cache(this, funcs[0], x, name);
    } : function() {
      if (cache === null)
        cache = H.closureFromTearOff(this, funcs, reflectionInfo, false, [], name);
      return new cache(this, funcs[0], null, name);
    };
  }
  function tearOff(funcs, reflectionInfo, isStatic, name, isIntercepted) {
    var cache;
    return isStatic ? function() {
      if (cache === void 0)
        cache = H.closureFromTearOff(this, funcs, reflectionInfo, true, [], name).prototype;
      return cache;
    } : tearOffGetter(funcs, reflectionInfo, name, isIntercepted);
  }
  var functionCounter = 0;
  var tearOffGetter = typeof dart_precompiled == "function" ? tearOffGetterCsp : tearOffGetterNoCsp;
  if (!init.libraries)
    init.libraries = [];
  if (!init.mangledNames)
    init.mangledNames = map();
  if (!init.mangledGlobalNames)
    init.mangledGlobalNames = map();
  if (!init.statics)
    init.statics = map();
  if (!init.typeInformation)
    init.typeInformation = map();
  if (!init.globalFunctions)
    init.globalFunctions = map();
  if (!init.interceptedNames)
    init.interceptedNames = map();
  var libraries = init.libraries;
  var mangledNames = init.mangledNames;
  var mangledGlobalNames = init.mangledGlobalNames;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var length = reflectionData.length;
  for (var i = 0; i < length; i++) {
    var data = reflectionData[i];
    var name = data[0];
    var uri = data[1];
    var metadata = data[2];
    var globalObject = data[3];
    var descriptor = data[4];
    var isRoot = !!data[5];
    var fields = descriptor && descriptor["^"];
    if (fields instanceof Array)
      fields = fields[0];
    var classes = [];
    var functions = [];
    processStatics(descriptor);
    libraries.push([name, uri, classes, functions, metadata, fields, isRoot, globalObject]);
  }
})([
["_foreign_helper", "dart:_foreign_helper", , H, {
  "^": "",
  JS_CONST: {
    "^": "Object;code<"
  }
}],
["_interceptors", "dart:_interceptors", , J, {
  "^": "",
  getInterceptor: function(object) {
    return void 0;
  },
  makeDispatchRecord: function(interceptor, proto, extension, indexability) {
    return {i: interceptor, p: proto, e: extension, x: indexability};
  },
  getNativeInterceptor: function(object) {
    var record, proto, objectProto, interceptor;
    record = object[init.dispatchPropertyName];
    if (record == null)
      if ($.initNativeDispatchFlag == null) {
        H.initNativeDispatch();
        record = object[init.dispatchPropertyName];
      }
    if (record != null) {
      proto = record.p;
      if (false === proto)
        return record.i;
      if (true === proto)
        return object;
      objectProto = Object.getPrototypeOf(object);
      if (proto === objectProto)
        return record.i;
      if (record.e === objectProto)
        throw H.wrapException(P.UnimplementedError$("Return interceptor for " + H.S(proto(object, record))));
    }
    interceptor = H.lookupAndCacheInterceptor(object);
    if (interceptor == null) {
      proto = Object.getPrototypeOf(object);
      if (proto == null || proto === Object.prototype)
        return C.PlainJavaScriptObject_methods;
      else
        return C.UnknownJavaScriptObject_methods;
    }
    return interceptor;
  },
  Interceptor: {
    "^": "Object;",
    $eq: function(receiver, other) {
      return receiver === other;
    },
    get$hashCode: function(receiver) {
      return H.Primitives_objectHashCode(receiver);
    },
    toString$0: function(receiver) {
      return H.Primitives_objectToString(receiver);
    },
    get$runtimeType: function(receiver) {
      return new H.TypeImpl(H.getRuntimeTypeString(receiver), null);
    }
  },
  JSBool: {
    "^": "Interceptor;",
    toString$0: function(receiver) {
      return String(receiver);
    },
    get$hashCode: function(receiver) {
      return receiver ? 519018 : 218159;
    },
    get$runtimeType: function(receiver) {
      return C.Type_EsU;
    },
    $isbool: true
  },
  JSNull: {
    "^": "Interceptor;",
    $eq: function(receiver, other) {
      return null == other;
    },
    toString$0: function(receiver) {
      return "null";
    },
    get$hashCode: function(receiver) {
      return 0;
    },
    get$runtimeType: function(receiver) {
      return C.Type_eZO;
    }
  },
  JavaScriptObject: {
    "^": "Interceptor;",
    get$hashCode: function(_) {
      return 0;
    },
    get$runtimeType: function(_) {
      return C.Type_XXD;
    }
  },
  PlainJavaScriptObject: {
    "^": "JavaScriptObject;"
  },
  UnknownJavaScriptObject: {
    "^": "JavaScriptObject;",
    toString$0: function(receiver) {
      return String(receiver);
    }
  },
  JSArray: {
    "^": "Interceptor;",
    add$1: [function(receiver, value) {
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("add"));
      receiver.push(value);
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "void__E", void: true, args: [E]};
      }, this.$receiver, "JSArray");
    }],
    removeAt$1: function(receiver, index) {
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index < 0 || index >= receiver.length)
        throw H.wrapException(P.RangeError$value(index));
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("removeAt"));
      return receiver.splice(index, 1)[0];
    },
    insert$2: function(receiver, index, value) {
      if (index > receiver.length)
        throw H.wrapException(P.RangeError$value(index));
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("insert"));
      receiver.splice(index, 0, value);
    },
    removeLast$0: function(receiver) {
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("removeLast"));
      if (receiver.length === 0)
        throw H.wrapException(P.RangeError$value(-1));
      return receiver.pop();
    },
    remove$1: function(receiver, element) {
      var i;
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("remove"));
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq(receiver[i], element)) {
          receiver.splice(i, 1);
          return true;
        }
      return false;
    },
    expand$1: function(receiver, f) {
      return H.setRuntimeTypeInfo(new H.ExpandIterable(receiver, f), [null, null]);
    },
    addAll$1: function(receiver, collection) {
      var t1;
      for (t1 = J.get$iterator$ax(collection); t1.moveNext$0();)
        this.add$1(receiver, t1.get$current());
    },
    forEach$1: function(receiver, f) {
      return H.IterableMixinWorkaround_forEach(receiver, f);
    },
    join$1: function(receiver, separator) {
      var t1, list, i, t2;
      t1 = receiver.length;
      list = Array(t1);
      list.fixed$length = init;
      for (i = 0; i < receiver.length; ++i) {
        t2 = H.S(receiver[i]);
        if (i >= t1)
          return H.ioore(list, i);
        list[i] = t2;
      }
      return list.join(separator);
    },
    join$0: function($receiver) {
      return this.join$1($receiver, "");
    },
    skip$1: function(receiver, n) {
      return H.SubListIterable$(receiver, n, null, H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(receiver, 0)]), 0));
    },
    elementAt$1: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      if (typeof start !== "number" || Math.floor(start) !== start)
        throw H.wrapException(P.ArgumentError$(start));
      if (start < 0 || start > receiver.length)
        throw H.wrapException(P.RangeError$range(start, 0, receiver.length));
      if (typeof end !== "number" || Math.floor(end) !== end)
        throw H.wrapException(P.ArgumentError$(end));
      if (end < start || end > receiver.length)
        throw H.wrapException(P.RangeError$range(end, start, receiver.length));
      if (start === end)
        return H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(receiver, 0)]);
      return H.setRuntimeTypeInfo(receiver.slice(start, end), [H.getTypeArgumentByIndex(receiver, 0)]);
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$last: function(receiver) {
      var t1 = receiver.length;
      if (t1 > 0)
        return receiver[t1 - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    removeRange$2: function(receiver, start, end) {
      var receiverLength;
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("removeRange"));
      receiverLength = receiver.length;
      if (start < 0 || start > receiverLength)
        throw H.wrapException(P.RangeError$range(start, 0, receiverLength));
      if (end < start || end > receiverLength)
        throw H.wrapException(P.RangeError$range(end, start, receiverLength));
      H.Lists_copy(receiver, end, receiver, start, receiverLength - end);
      this.set$length(receiver, receiverLength - (end - start));
    },
    indexOf$2: function(receiver, element, start) {
      return H.Lists_indexOf(receiver, element, start, receiver.length);
    },
    indexOf$1: function($receiver, element) {
      return this.indexOf$2($receiver, element, 0);
    },
    contains$1: function(receiver, other) {
      var i;
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq(receiver[i], other))
          return true;
      return false;
    },
    get$isEmpty: function(receiver) {
      return receiver.length === 0;
    },
    get$isNotEmpty: function(receiver) {
      return receiver.length !== 0;
    },
    toString$0: function(receiver) {
      return P.IterableBase_iterableToFullString(receiver, "[", "]");
    },
    toList$1$growable: function(receiver, growable) {
      var t1;
      if (growable)
        return H.setRuntimeTypeInfo(receiver.slice(), [H.getTypeArgumentByIndex(receiver, 0)]);
      else {
        t1 = H.setRuntimeTypeInfo(receiver.slice(), [H.getTypeArgumentByIndex(receiver, 0)]);
        t1.fixed$length = init;
        return t1;
      }
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    get$iterator: function(receiver) {
      return H.setRuntimeTypeInfo(new H.ListIterator(receiver, receiver.length, 0, null), [H.getTypeArgumentByIndex(receiver, 0)]);
    },
    get$hashCode: function(receiver) {
      return H.Primitives_objectHashCode(receiver);
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    set$length: function(receiver, newLength) {
      if (typeof newLength !== "number" || Math.floor(newLength) !== newLength)
        throw H.wrapException(P.ArgumentError$(newLength));
      if (newLength < 0)
        throw H.wrapException(P.RangeError$value(newLength));
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("set length"));
      receiver.length = newLength;
    },
    $index: function(receiver, index) {
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(P.RangeError$value(index));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      if (!!receiver.immutable$list)
        H.throwExpression(P.UnsupportedError$("indexed set"));
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(P.RangeError$value(index));
      receiver[index] = value;
    },
    $isJSArray: true,
    $isJSIndexable: true,
    $isList: true,
    $asList: null,
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: null,
    static: {JSArray_JSArray$fixed: function($length, $E) {
        var t1;
        if (typeof $length !== "number" || Math.floor($length) !== $length || $length < 0)
          throw H.wrapException(P.ArgumentError$("Length must be a non-negative integer: " + H.S($length)));
        t1 = H.setRuntimeTypeInfo(new Array($length), [$E]);
        t1.fixed$length = init;
        return t1;
      }}
  },
  JSNumber: {
    "^": "Interceptor;",
    compareTo$1: function(receiver, b) {
      var bIsNegative;
      if (typeof b !== "number")
        throw H.wrapException(P.ArgumentError$(b));
      if (receiver < b)
        return -1;
      else if (receiver > b)
        return 1;
      else if (receiver === b) {
        if (receiver === 0) {
          bIsNegative = this.get$isNegative(b);
          if (this.get$isNegative(receiver) === bIsNegative)
            return 0;
          if (this.get$isNegative(receiver))
            return -1;
          return 1;
        }
        return 0;
      } else if (isNaN(receiver)) {
        if (this.get$isNaN(b))
          return 0;
        return 1;
      } else
        return -1;
    },
    get$isNegative: function(receiver) {
      return receiver === 0 ? 1 / receiver < 0 : receiver < 0;
    },
    get$isNaN: function(receiver) {
      return isNaN(receiver);
    },
    get$isFinite: function(receiver) {
      return isFinite(receiver);
    },
    remainder$1: function(receiver, b) {
      return receiver % b;
    },
    toInt$0: function(receiver) {
      var t1;
      if (receiver >= -2147483648 && receiver <= 2147483647)
        return receiver | 0;
      if (isFinite(receiver)) {
        t1 = receiver < 0 ? Math.ceil(receiver) : Math.floor(receiver);
        return t1 + 0;
      }
      throw H.wrapException(P.UnsupportedError$('' + receiver));
    },
    roundToDouble$0: function(receiver) {
      if (receiver < 0)
        return -Math.round(-receiver);
      else
        return Math.round(receiver);
    },
    toRadixString$1: function(receiver, radix) {
      if (radix < 2 || radix > 36)
        throw H.wrapException(P.RangeError$(radix));
      return receiver.toString(radix);
    },
    toString$0: function(receiver) {
      if (receiver === 0 && 1 / receiver < 0)
        return "-0.0";
      else
        return "" + receiver;
    },
    get$hashCode: function(receiver) {
      return receiver & 0x1FFFFFFF;
    },
    $negate: function(receiver) {
      return -receiver;
    },
    $add: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver + other;
    },
    $sub: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver - other;
    },
    $mul: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver * other;
    },
    $mod: function(receiver, other) {
      var result = receiver % other;
      if (result === 0)
        return 0;
      if (result > 0)
        return result;
      if (other < 0)
        return result - other;
      else
        return result + other;
    },
    $tdiv: function(receiver, other) {
      if ((receiver | 0) === receiver && (other | 0) === other && 0 !== other && -1 !== other)
        return receiver / other | 0;
      else
        return this.toInt$0(receiver / other);
    },
    _tdivFast$1: function(receiver, other) {
      return (receiver | 0) === receiver ? receiver / other | 0 : this.toInt$0(receiver / other);
    },
    $shl: function(receiver, other) {
      if (other < 0)
        throw H.wrapException(P.ArgumentError$(other));
      return other > 31 ? 0 : receiver << other >>> 0;
    },
    _shlPositive$1: function(receiver, other) {
      return other > 31 ? 0 : receiver << other >>> 0;
    },
    $shr: function(receiver, other) {
      var t1;
      if (other < 0)
        throw H.wrapException(P.ArgumentError$(other));
      if (receiver > 0)
        t1 = other > 31 ? 0 : receiver >>> other;
      else {
        t1 = other > 31 ? 31 : other;
        t1 = receiver >> t1 >>> 0;
      }
      return t1;
    },
    _shrOtherPositive$1: function(receiver, other) {
      var t1;
      if (receiver > 0)
        t1 = other > 31 ? 0 : receiver >>> other;
      else {
        t1 = other > 31 ? 31 : other;
        t1 = receiver >> t1 >>> 0;
      }
      return t1;
    },
    _shrReceiverPositive$1: function(receiver, other) {
      if (other < 0)
        throw H.wrapException(P.ArgumentError$(other));
      return other > 31 ? 0 : receiver >>> other;
    },
    $and: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return (receiver & other) >>> 0;
    },
    $or: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return (receiver | other) >>> 0;
    },
    $xor: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return (receiver ^ other) >>> 0;
    },
    $lt: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver < other;
    },
    $gt: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver > other;
    },
    $ge: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver >= other;
    },
    get$runtimeType: function(receiver) {
      return C.Type_xM7;
    },
    $isnum: true,
    static: {"^": "JSNumber__MIN_INT32,JSNumber__MAX_INT32"}
  },
  JSInt: {
    "^": "JSNumber;",
    get$runtimeType: function(receiver) {
      return C.Type_SnA;
    },
    $is$double: true,
    $isnum: true,
    $is$int: true
  },
  JSDouble: {
    "^": "JSNumber;",
    get$runtimeType: function(receiver) {
      return C.Type_qq1;
    },
    $is$double: true,
    $isnum: true
  },
  JSString: {
    "^": "Interceptor;",
    codeUnitAt$1: function(receiver, index) {
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index < 0)
        throw H.wrapException(P.RangeError$value(index));
      if (index >= receiver.length)
        throw H.wrapException(P.RangeError$value(index));
      return receiver.charCodeAt(index);
    },
    allMatches$2: function(receiver, string, start) {
      var t1;
      if (typeof string !== "string")
        H.throwExpression(P.ArgumentError$(string));
      t1 = J.get$length$asx(string);
      if (typeof t1 !== "number")
        return H.iae(t1);
      t1 = start > t1;
      if (t1)
        throw H.wrapException(P.RangeError$range(start, 0, J.get$length$asx(string)));
      return H.allMatchesInStringUnchecked(receiver, string, start);
    },
    allMatches$1: function($receiver, string) {
      return this.allMatches$2($receiver, string, 0);
    },
    matchAsPrefix$2: function(receiver, string, start) {
      var t1, t2, i, t3;
      if (start < 0 || start > string.length)
        throw H.wrapException(P.RangeError$range(start, 0, string.length));
      t1 = receiver.length;
      t2 = string.length;
      if (start + t1 > t2)
        return;
      for (i = 0; i < t1; ++i) {
        t3 = start + i;
        if (t3 < 0)
          H.throwExpression(P.RangeError$value(t3));
        if (t3 >= t2)
          H.throwExpression(P.RangeError$value(t3));
        t3 = string.charCodeAt(t3);
        if (i >= t1)
          H.throwExpression(P.RangeError$value(i));
        if (t3 !== receiver.charCodeAt(i))
          return;
      }
      return new H.StringMatch(start, string, receiver);
    },
    $add: function(receiver, other) {
      if (typeof other !== "string")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver + other;
    },
    endsWith$1: function(receiver, other) {
      var t1, otherLength, t2;
      if (typeof other !== "string")
        H.throwExpression(P.ArgumentError$(other));
      t1 = J.getInterceptor$asx(other);
      otherLength = t1.get$length(other);
      t2 = receiver.length;
      if (J.$gt$n(otherLength, t2))
        return false;
      if (typeof otherLength !== "number")
        return H.iae(otherLength);
      return t1.$eq(other, this.substring$1(receiver, t2 - otherLength));
    },
    replaceAll$2: function(receiver, from, to) {
      return H.stringReplaceAllUnchecked(receiver, from, to);
    },
    replaceFirst$2: function(receiver, from, to) {
      return H.stringReplaceFirstUnchecked(receiver, from, to);
    },
    split$1: function(receiver, pattern) {
      return receiver.split(pattern);
    },
    startsWith$2: function(receiver, pattern, index) {
      var endIndex;
      if (index > receiver.length)
        throw H.wrapException(P.RangeError$range(index, 0, receiver.length));
      if (typeof pattern === "string") {
        endIndex = index + pattern.length;
        if (endIndex > receiver.length)
          return false;
        return pattern === receiver.substring(index, endIndex);
      }
      return J.matchAsPrefix$2$s(pattern, receiver, index) != null;
    },
    startsWith$1: function($receiver, pattern) {
      return this.startsWith$2($receiver, pattern, 0);
    },
    substring$2: function(receiver, startIndex, endIndex) {
      var t1;
      if (typeof startIndex !== "number" || Math.floor(startIndex) !== startIndex)
        H.throwExpression(P.ArgumentError$(startIndex));
      if (endIndex == null)
        endIndex = receiver.length;
      if (typeof endIndex !== "number" || Math.floor(endIndex) !== endIndex)
        H.throwExpression(P.ArgumentError$(endIndex));
      t1 = J.getInterceptor$n(startIndex);
      if (t1.$lt(startIndex, 0))
        throw H.wrapException(P.RangeError$value(startIndex));
      if (t1.$gt(startIndex, endIndex))
        throw H.wrapException(P.RangeError$value(startIndex));
      if (J.$gt$n(endIndex, receiver.length))
        throw H.wrapException(P.RangeError$value(endIndex));
      return receiver.substring(startIndex, endIndex);
    },
    substring$1: function($receiver, startIndex) {
      return this.substring$2($receiver, startIndex, null);
    },
    toLowerCase$0: function(receiver) {
      return receiver.toLowerCase();
    },
    trim$0: function(receiver) {
      var result, endIndex, startIndex, t1, endIndex0;
      result = receiver.trim();
      endIndex = result.length;
      if (endIndex === 0)
        return result;
      if (this.codeUnitAt$1(result, 0) === 133) {
        startIndex = J.JSString__skipLeadingWhitespace(result, 1);
        if (startIndex === endIndex)
          return "";
      } else
        startIndex = 0;
      t1 = endIndex - 1;
      endIndex0 = this.codeUnitAt$1(result, t1) === 133 ? J.JSString__skipTrailingWhitespace(result, t1) : endIndex;
      if (startIndex === 0 && endIndex0 === endIndex)
        return result;
      return result.substring(startIndex, endIndex0);
    },
    $mul: function(receiver, times) {
      var s, result;
      if (0 >= times)
        return "";
      if (times === 1 || receiver.length === 0)
        return receiver;
      if (times !== times >>> 0)
        throw H.wrapException(C.C_OutOfMemoryError);
      for (s = receiver, result = ""; true;) {
        if ((times & 1) === 1)
          result = s + result;
        times = times >>> 1;
        if (times === 0)
          break;
        s += s;
      }
      return result;
    },
    get$codeUnits: function(receiver) {
      return new J._CodeUnits(receiver);
    },
    indexOf$2: function(receiver, pattern, start) {
      var t1, match, t2, i;
      if (pattern == null)
        H.throwExpression(P.ArgumentError$(null));
      if (typeof start !== "number" || Math.floor(start) !== start)
        throw H.wrapException(P.ArgumentError$(start));
      if (start < 0 || start > receiver.length)
        throw H.wrapException(P.RangeError$range(start, 0, receiver.length));
      if (typeof pattern === "string")
        return receiver.indexOf(pattern, start);
      t1 = J.getInterceptor(pattern);
      if (!!t1.$isJSSyntaxRegExp) {
        match = pattern._execGlobal$2(receiver, start);
        return match == null ? -1 : match._match.index;
      }
      for (t2 = receiver.length, i = start; i <= t2; ++i)
        if (t1.matchAsPrefix$2(pattern, receiver, i) != null)
          return i;
      return -1;
    },
    indexOf$1: function($receiver, pattern) {
      return this.indexOf$2($receiver, pattern, 0);
    },
    lastIndexOf$2: function(receiver, pattern, start) {
      var t1, t2;
      start = receiver.length;
      t1 = pattern.length;
      t2 = receiver.length;
      if (start + t1 > t2)
        start = t2 - t1;
      return receiver.lastIndexOf(pattern, start);
    },
    lastIndexOf$1: function($receiver, pattern) {
      return this.lastIndexOf$2($receiver, pattern, null);
    },
    contains$2: function(receiver, other, startIndex) {
      if (other == null)
        H.throwExpression(P.ArgumentError$(null));
      if (startIndex > receiver.length)
        throw H.wrapException(P.RangeError$range(startIndex, 0, receiver.length));
      return H.stringContainsUnchecked(receiver, other, startIndex);
    },
    contains$1: function($receiver, other) {
      return this.contains$2($receiver, other, 0);
    },
    get$isEmpty: function(receiver) {
      return receiver.length === 0;
    },
    get$isNotEmpty: function(receiver) {
      return receiver.length !== 0;
    },
    compareTo$1: function(receiver, other) {
      var t1;
      if (typeof other !== "string")
        throw H.wrapException(P.ArgumentError$(other));
      if (receiver === other)
        t1 = 0;
      else
        t1 = receiver < other ? -1 : 1;
      return t1;
    },
    toString$0: function(receiver) {
      return receiver;
    },
    get$hashCode: function(receiver) {
      var t1, hash, i;
      for (t1 = receiver.length, hash = 0, i = 0; i < t1; ++i) {
        hash = 536870911 & hash + receiver.charCodeAt(i);
        hash = 536870911 & hash + ((524287 & hash) << 10 >>> 0);
        hash ^= hash >> 6;
      }
      hash = 536870911 & hash + ((67108863 & hash) << 3 >>> 0);
      hash ^= hash >> 11;
      return 536870911 & hash + ((16383 & hash) << 15 >>> 0);
    },
    get$runtimeType: function(receiver) {
      return C.Type_Ejg;
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(P.RangeError$value(index));
      return receiver[index];
    },
    $isJSIndexable: true,
    $isString: true,
    static: {JSString__isWhitespace: function(codeUnit) {
        if (codeUnit < 256)
          switch (codeUnit) {
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 32:
            case 133:
            case 160:
              return true;
            default:
              return false;
          }
        switch (codeUnit) {
          case 5760:
          case 6158:
          case 8192:
          case 8193:
          case 8194:
          case 8195:
          case 8196:
          case 8197:
          case 8198:
          case 8199:
          case 8200:
          case 8201:
          case 8202:
          case 8232:
          case 8233:
          case 8239:
          case 8287:
          case 12288:
          case 65279:
            return true;
          default:
            return false;
        }
      }, JSString__skipLeadingWhitespace: function(string, index) {
        var t1, codeUnit;
        for (t1 = string.length; index < t1;) {
          if (index >= t1)
            H.throwExpression(P.RangeError$value(index));
          codeUnit = string.charCodeAt(index);
          if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
            break;
          ++index;
        }
        return index;
      }, JSString__skipTrailingWhitespace: function(string, index) {
        var t1, index0, codeUnit;
        for (t1 = string.length; index > 0; index = index0) {
          index0 = index - 1;
          if (index0 >= t1)
            H.throwExpression(P.RangeError$value(index0));
          codeUnit = string.charCodeAt(index0);
          if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
            break;
        }
        return index;
      }}
  },
  _CodeUnits: {
    "^": "UnmodifiableListBase;_string",
    get$length: function(_) {
      return this._string.length;
    },
    $index: function(_, i) {
      var t1, t2;
      t1 = this._string;
      if (typeof i !== "number" || Math.floor(i) !== i)
        H.throwExpression(P.ArgumentError$(i));
      t2 = J.getInterceptor$n(i);
      if (t2.$lt(i, 0))
        H.throwExpression(P.RangeError$value(i));
      if (t2.$ge(i, t1.length))
        H.throwExpression(P.RangeError$value(i));
      return t1.charCodeAt(i);
    },
    $asUnmodifiableListBase: function() {
      return [P.$int];
    },
    $asListBase: function() {
      return [P.$int];
    },
    $asObject_ListMixin: function() {
      return [P.$int];
    },
    $asList: function() {
      return [P.$int];
    },
    $asIterable: function() {
      return [P.$int];
    }
  }
}],
["_isolate_helper", "dart:_isolate_helper", , H, {
  "^": "",
  _callInIsolate: function(isolate, $function) {
    var result = isolate.eval$1($function);
    init.globalState.topEventLoop.run$0();
    return result;
  },
  leaveJsAsync: function() {
    --init.globalState.topEventLoop._activeJsAsyncCount;
  },
  startRootIsolate: function(entry, args) {
    var t1, t2, t3, t4, t5, rootContext;
    t1 = {};
    t1.args_0 = args;
    args = args;
    t1.args_0 = args;
    if (args == null) {
      args = [];
      t1.args_0 = args;
      t2 = args;
    } else
      t2 = args;
    if (!J.getInterceptor(t2).$isList)
      throw H.wrapException(P.ArgumentError$("Arguments to main must be a List: " + H.S(t2)));
    t2 = new H._Manager(0, 0, 1, null, null, null, null, null, null, null, null, null, entry);
    t2._Manager$1(entry);
    init.globalState = t2;
    if (init.globalState.isWorker === true)
      return;
    t2 = init.globalState.nextIsolateId++;
    t3 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, H.RawReceivePortImpl);
    t4 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.$int);
    t5 = new H.RawReceivePortImpl(0, null, false);
    rootContext = new H._IsolateContext(t2, t3, t4, new Isolate(), t5, new H.CapabilityImpl(H.random64()), new H.CapabilityImpl(H.random64()), false, false, [], P.LinkedHashSet_LinkedHashSet(null, null, null, null), null, null, false, true, P.LinkedHashSet_LinkedHashSet(null, null, null, null));
    t4.add$1(0, 0);
    rootContext._addRegistration$2(0, t5);
    init.globalState.rootContext = rootContext;
    init.globalState.currentContext = rootContext;
    t2 = H.getDynamicRuntimeType();
    t3 = H.buildFunctionType(t2, [t2])._isTest$1(entry);
    if (t3)
      rootContext.eval$1(new H.startRootIsolate_closure(t1, entry));
    else {
      t2 = H.buildFunctionType(t2, [t2, t2])._isTest$1(entry);
      if (t2)
        rootContext.eval$1(new H.startRootIsolate_closure0(t1, entry));
      else
        rootContext.eval$1(entry);
    }
    init.globalState.topEventLoop.run$0();
  },
  IsolateNatives_computeThisScript: function() {
    var currentScript = init.currentScript;
    if (currentScript != null)
      return String(currentScript.src);
    if (typeof version == "function" && typeof os == "object" && "system" in os)
      return H.IsolateNatives_computeThisScriptFromTrace();
    if (typeof version == "function" && typeof system == "function")
      return thisFilename();
    if (init.globalState.isWorker === true)
      return H.IsolateNatives_computeThisScriptFromTrace();
    return;
  },
  IsolateNatives_computeThisScriptFromTrace: function() {
    var stack, matches;
    stack = new Error().stack;
    if (stack == null) {
      stack = function() {
        try {
          throw new Error();
        } catch (e) {
          return e.stack;
        }

      }();
      if (stack == null)
        throw H.wrapException(P.UnsupportedError$("No stack trace"));
    }
    matches = stack.match(new RegExp("^ *at [^(]*\\((.*):[0-9]*:[0-9]*\\)$", "m"));
    if (matches != null)
      return matches[1];
    matches = stack.match(new RegExp("^[^@]*@(.*):[0-9]*$", "m"));
    if (matches != null)
      return matches[1];
    throw H.wrapException(P.UnsupportedError$("Cannot extract URI from \"" + H.S(stack) + "\""));
  },
  IsolateNatives__processWorkerMessage: [function(sender, e) {
    var msg, t1, functionName, entryPoint, args, message, isSpawnUri, startPaused, replyTo, t2, t3, t4, context;
    msg = H._deserializeMessage(e.data);
    t1 = J.getInterceptor$asx(msg);
    switch (t1.$index(msg, "command")) {
      case "start":
        init.globalState.currentManagerId = t1.$index(msg, "id");
        functionName = t1.$index(msg, "functionName");
        entryPoint = functionName == null ? init.globalState.entry : init.globalFunctions[functionName]();
        args = t1.$index(msg, "args");
        message = H._deserializeMessage(t1.$index(msg, "msg"));
        isSpawnUri = t1.$index(msg, "isSpawnUri");
        startPaused = t1.$index(msg, "startPaused");
        replyTo = H._deserializeMessage(t1.$index(msg, "replyTo"));
        t1 = init.globalState.nextIsolateId++;
        t2 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, H.RawReceivePortImpl);
        t3 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.$int);
        t4 = new H.RawReceivePortImpl(0, null, false);
        context = new H._IsolateContext(t1, t2, t3, new Isolate(), t4, new H.CapabilityImpl(H.random64()), new H.CapabilityImpl(H.random64()), false, false, [], P.LinkedHashSet_LinkedHashSet(null, null, null, null), null, null, false, true, P.LinkedHashSet_LinkedHashSet(null, null, null, null));
        t3.add$1(0, 0);
        context._addRegistration$2(0, t4);
        init.globalState.topEventLoop.events._add$1(new H._IsolateEvent(context, new H.IsolateNatives__processWorkerMessage_closure(entryPoint, args, message, isSpawnUri, startPaused, replyTo), "worker-start"));
        init.globalState.currentContext = context;
        init.globalState.topEventLoop.run$0();
        break;
      case "spawn-worker":
        break;
      case "message":
        if (t1.$index(msg, "port") != null)
          t1.$index(msg, "port").send$1(t1.$index(msg, "msg"));
        init.globalState.topEventLoop.run$0();
        break;
      case "close":
        init.globalState.managers.remove$1(0, $.get$IsolateNatives_workerIds().$index(0, sender));
        sender.terminate();
        init.globalState.topEventLoop.run$0();
        break;
      case "log":
        H.IsolateNatives__log(t1.$index(msg, "msg"));
        break;
      case "print":
        if (init.globalState.isWorker === true) {
          t1 = init.globalState.mainManager;
          t2 = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "print", "msg", msg], null, null));
          t1.toString;
          self.postMessage(t2);
        } else
          P.print(t1.$index(msg, "msg"));
        break;
      case "error":
        throw H.wrapException(t1.$index(msg, "msg"));
    }
  }, "call$2", "IsolateNatives__processWorkerMessage$closure", 4, 0, null, 1, 2],
  IsolateNatives__log: function(msg) {
    var trace, t1, t2, exception;
    if (init.globalState.isWorker === true) {
      t1 = init.globalState.mainManager;
      t2 = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "log", "msg", msg], null, null));
      t1.toString;
      self.postMessage(t2);
    } else
      try {
        self.console.log(msg);
      } catch (exception) {
        H.unwrapException(exception);
        trace = new H._StackTrace(exception, null);
        throw H.wrapException(P.Exception_Exception(trace));
      }

  },
  IsolateNatives__startIsolate: function(topLevel, args, message, isSpawnUri, startPaused, replyTo) {
    var context, t1, t2, t3;
    context = init.globalState.currentContext;
    t1 = context.id;
    $.Primitives_mirrorFunctionCacheName = $.Primitives_mirrorFunctionCacheName + ("_" + t1);
    $.Primitives_mirrorInvokeCacheName = $.Primitives_mirrorInvokeCacheName + ("_" + t1);
    t1 = context.controlPort;
    t2 = init.globalState.currentContext.id;
    t3 = context.pauseCapability;
    replyTo.send$1(["spawned", new H._NativeJsSendPort(t1, t2), t3, context.terminateCapability]);
    t2 = new H.IsolateNatives__startIsolate_runStartFunction(topLevel, args, message, isSpawnUri, context);
    if (startPaused === true) {
      context.addPause$2(t3, t3);
      init.globalState.topEventLoop.events._add$1(new H._IsolateEvent(context, t2, "start isolate"));
    } else
      t2.call$0();
  },
  _serializeMessage: function(message) {
    var t1;
    if (init.globalState.supportsWorkers === true) {
      t1 = new H._JsSerializer(0, new H._MessageTraverserVisitedMap());
      t1._visited = new H._JsVisitedMap(null);
      return t1.traverse$1(message);
    } else {
      t1 = new H._JsCopier(new H._MessageTraverserVisitedMap());
      t1._visited = new H._JsVisitedMap(null);
      return t1.traverse$1(message);
    }
  },
  _deserializeMessage: function(message) {
    if (init.globalState.supportsWorkers === true)
      return new H._JsDeserializer(null).deserialize$1(message);
    else
      return message;
  },
  _MessageTraverser_isPrimitive: function(x) {
    return x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean";
  },
  _Deserializer_isPrimitive: function(x) {
    return x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean";
  },
  startRootIsolate_closure: {
    "^": "Closure:55;box_0,entry_1",
    call$0: function() {
      this.entry_1.call$1(this.box_0.args_0);
    },
    $isFunction: true
  },
  startRootIsolate_closure0: {
    "^": "Closure:55;box_0,entry_2",
    call$0: function() {
      this.entry_2.call$2(this.box_0.args_0, null);
    },
    $isFunction: true
  },
  _Manager: {
    "^": "Object;nextIsolateId,currentManagerId,nextManagerId,currentContext,rootContext,topEventLoop,fromCommandLine,isWorker,supportsWorkers,isolates,mainManager,managers,entry",
    _Manager$1: function(entry) {
      var t1, t2, t3;
      t1 = self.window == null;
      t2 = self.Worker;
      t3 = t1 && !!self.postMessage;
      this.isWorker = t3;
      if (!t3)
        t2 = t2 != null && $.get$IsolateNatives_thisScript() != null;
      else
        t2 = true;
      this.supportsWorkers = t2;
      this.fromCommandLine = t1 && !t3;
      this.topEventLoop = new H._EventLoop(P.ListQueue$(null, H._IsolateEvent), 0);
      this.isolates = P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, H._IsolateContext);
      this.managers = P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, null);
      if (this.isWorker === true) {
        t1 = new H._MainManagerStub();
        this.mainManager = t1;
        self.onmessage = function(f, a) {
          return function(e) {
            f(a, e);
          };
        }(H.IsolateNatives__processWorkerMessage, t1);
        self.dartPrint = self.dartPrint || function(serialize) {
          return function(object) {
            if (self.console && self.console.log) {
              self.console.log(object);
            } else {
              self.postMessage(serialize(object));
            }
          };
        }(H._Manager__serializePrintMessage);
      }
    },
    static: {_Manager__serializePrintMessage: [function(object) {
        return H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "print", "msg", object], null, null));
      }, "call$1", "_Manager__serializePrintMessage$closure", 2, 0, null, 0]}
  },
  _IsolateContext: {
    "^": "Object;id,ports,weakPorts,isolateStatics<,controlPort<,pauseCapability,terminateCapability,initialized?,isPaused<,delayedEvents<,pauseTokens,doneHandlers,_scheduledControlEvents,_isExecutingEvent,errorsAreFatal,errorPorts",
    addPause$2: function(authentification, resume) {
      if (!this.pauseCapability.$eq(0, authentification))
        return;
      if (this.pauseTokens.add$1(0, resume) && !this.isPaused)
        this.isPaused = true;
      this._updateGlobalState$0();
    },
    removePause$1: function(resume) {
      var t1, t2, $event, t3, t4, t5;
      if (!this.isPaused)
        return;
      t1 = this.pauseTokens;
      t1.remove$1(0, resume);
      if (t1._collection$_length === 0) {
        for (t1 = this.delayedEvents; t2 = t1.length, t2 !== 0;) {
          if (0 >= t2)
            return H.ioore(t1, 0);
          $event = t1.pop();
          t2 = init.globalState.topEventLoop.events;
          t3 = t2._head;
          t4 = t2._table;
          t5 = t4.length;
          t3 = (t3 - 1 & t5 - 1) >>> 0;
          t2._head = t3;
          if (t3 < 0 || t3 >= t5)
            return H.ioore(t4, t3);
          t4[t3] = $event;
          if (t3 === t2._tail)
            t2._grow$0();
          ++t2._modificationCount;
        }
        this.isPaused = false;
      }
      this._updateGlobalState$0();
    },
    addDoneListener$1: function(responsePort) {
      var t1 = this.doneHandlers;
      if (t1 == null) {
        t1 = [];
        this.doneHandlers = t1;
      }
      if (J.contains$1$asx(t1, responsePort))
        return;
      this.doneHandlers.push(responsePort);
    },
    removeDoneListener$1: function(responsePort) {
      var t1 = this.doneHandlers;
      if (t1 == null)
        return;
      J.remove$1$ax(t1, responsePort);
    },
    setErrorsFatal$2: function(authentification, errorsAreFatal) {
      if (!this.terminateCapability.$eq(0, authentification))
        return;
      this.errorsAreFatal = errorsAreFatal;
    },
    handlePing$2: function(responsePort, pingType) {
      var t1, t2;
      t1 = J.getInterceptor(pingType);
      if (!t1.$eq(pingType, 0))
        t2 = t1.$eq(pingType, 1) && !this._isExecutingEvent;
      else
        t2 = true;
      if (t2) {
        responsePort.send$1(null);
        return;
      }
      t2 = new H._IsolateContext_handlePing_respond(responsePort);
      if (t1.$eq(pingType, 2)) {
        init.globalState.topEventLoop.events._add$1(new H._IsolateEvent(this, t2, "ping"));
        return;
      }
      t1 = this._scheduledControlEvents;
      if (t1 == null) {
        t1 = P.ListQueue$(null, null);
        this._scheduledControlEvents = t1;
      }
      t1._add$1(t2);
    },
    handleKill$2: function(authentification, priority) {
      var t1, t2;
      if (!this.terminateCapability.$eq(0, authentification))
        return;
      t1 = J.getInterceptor(priority);
      if (!t1.$eq(priority, 0))
        t2 = t1.$eq(priority, 1) && !this._isExecutingEvent;
      else
        t2 = true;
      if (t2) {
        this.kill$0();
        return;
      }
      if (t1.$eq(priority, 2)) {
        t1 = init.globalState.topEventLoop;
        t2 = this.get$kill();
        t1.events._add$1(new H._IsolateEvent(this, t2, "kill"));
        return;
      }
      t1 = this._scheduledControlEvents;
      if (t1 == null) {
        t1 = P.ListQueue$(null, null);
        this._scheduledControlEvents = t1;
      }
      t1._add$1(this.get$kill());
    },
    handleUncaughtError$2: function(error, stackTrace) {
      var t1, message;
      t1 = this.errorPorts;
      if (t1._collection$_length === 0) {
        if (this.errorsAreFatal === true && this === init.globalState.rootContext)
          return;
        if (self.console && self.console.error)
          self.console.error(error, stackTrace);
        else {
          P.print(error);
          if (stackTrace != null)
            P.print(stackTrace);
        }
        return;
      }
      message = Array(2);
      message.fixed$length = init;
      message[0] = J.toString$0(error);
      message[1] = stackTrace == null ? null : J.toString$0(stackTrace);
      for (t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(t1, t1._modifications, null, null), [null]), t1._cell = t1._collection$_set._first; t1.moveNext$0();)
        t1._collection$_current.send$1(message);
    },
    eval$1: function(code) {
      var old, result, e, s, exception, t1;
      old = init.globalState.currentContext;
      init.globalState.currentContext = this;
      $ = this.isolateStatics;
      result = null;
      this._isExecutingEvent = true;
      try {
        result = code.call$0();
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        this.handleUncaughtError$2(e, s);
        if (this.errorsAreFatal === true) {
          this.kill$0();
          if (this === init.globalState.rootContext)
            throw exception;
        }
      }
 finally {
        this._isExecutingEvent = false;
        init.globalState.currentContext = old;
        if (old != null)
          $ = old.get$isolateStatics();
        if (this._scheduledControlEvents != null)
          for (; t1 = this._scheduledControlEvents, !t1.get$isEmpty(t1);)
            this._scheduledControlEvents.removeFirst$0().call$0();
      }
      return result;
    },
    handleControlMessage$1: function(message) {
      var t1 = J.getInterceptor$asx(message);
      switch (t1.$index(message, 0)) {
        case "pause":
          this.addPause$2(t1.$index(message, 1), t1.$index(message, 2));
          break;
        case "resume":
          this.removePause$1(t1.$index(message, 1));
          break;
        case "add-ondone":
          this.addDoneListener$1(t1.$index(message, 1));
          break;
        case "remove-ondone":
          this.removeDoneListener$1(t1.$index(message, 1));
          break;
        case "set-errors-fatal":
          this.setErrorsFatal$2(t1.$index(message, 1), t1.$index(message, 2));
          break;
        case "ping":
          this.handlePing$2(t1.$index(message, 1), t1.$index(message, 2));
          break;
        case "kill":
          this.handleKill$2(t1.$index(message, 1), t1.$index(message, 2));
          break;
        case "getErrors":
          this.errorPorts.add$1(0, t1.$index(message, 1));
          break;
        case "stopErrors":
          this.errorPorts.remove$1(0, t1.$index(message, 1));
          break;
      }
    },
    lookup$1: function(portId) {
      return this.ports.$index(0, portId);
    },
    _addRegistration$2: function(portId, port) {
      var t1 = this.ports;
      if (t1.containsKey$1(portId))
        throw H.wrapException(P.Exception_Exception("Registry: ports must be registered only once."));
      t1.$indexSet(0, portId, port);
    },
    _updateGlobalState$0: function() {
      if (this.ports._collection$_length - this.weakPorts._collection$_length > 0 || this.isPaused || !this.initialized)
        init.globalState.isolates.$indexSet(0, this.id, this);
      else
        this.kill$0();
    },
    kill$0: [function() {
      var t1, t2;
      t1 = this._scheduledControlEvents;
      if (t1 != null)
        t1.clear$0(0);
      for (t1 = this.ports, t2 = t1.get$values(), t2 = H.setRuntimeTypeInfo(new H.MappedIterator(null, J.get$iterator$ax(t2._iterable), t2._f), [H.getTypeArgumentByIndex(t2, 0), H.getTypeArgumentByIndex(t2, 1)]); t2.moveNext$0();)
        t2._current.__isolate_helper$_close$0();
      t1.clear$0(0);
      this.weakPorts.clear$0(0);
      init.globalState.isolates.remove$1(0, this.id);
      this.errorPorts.clear$0(0);
      t1 = this.doneHandlers;
      if (t1 != null) {
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
          t1._current.send$1(null);
        this.doneHandlers = null;
      }
    }, "call$0", "get$kill", 0, 0, 12]
  },
  _IsolateContext_handlePing_respond: {
    "^": "Closure:12;responsePort_0",
    call$0: [function() {
      this.responsePort_0.send$1(null);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _EventLoop: {
    "^": "Object;events,_activeJsAsyncCount",
    dequeue$0: function() {
      var t1 = this.events;
      if (t1._head === t1._tail)
        return;
      return t1.removeFirst$0();
    },
    runIteration$0: function() {
      var $event, t1, t2;
      $event = this.dequeue$0();
      if ($event == null) {
        if (init.globalState.rootContext != null && init.globalState.isolates.containsKey$1(init.globalState.rootContext.id) && init.globalState.fromCommandLine === true && init.globalState.rootContext.ports._collection$_length === 0)
          H.throwExpression(P.Exception_Exception("Program exited with open ReceivePorts."));
        t1 = init.globalState;
        if (t1.isWorker === true && t1.isolates._collection$_length === 0 && t1.topEventLoop._activeJsAsyncCount === 0) {
          t1 = t1.mainManager;
          t2 = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "close"], null, null));
          t1.toString;
          self.postMessage(t2);
        }
        return false;
      }
      $event.process$0();
      return true;
    },
    _runHelper$0: function() {
      if (self.window != null)
        new H._EventLoop__runHelper_next(this).call$0();
      else
        for (; this.runIteration$0();)
          ;
    },
    run$0: function() {
      var e, trace, exception, t1, t2;
      if (init.globalState.isWorker !== true)
        this._runHelper$0();
      else
        try {
          this._runHelper$0();
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          trace = new H._StackTrace(exception, null);
          t1 = init.globalState.mainManager;
          t2 = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "error", "msg", H.S(e) + "\n" + H.S(trace)], null, null));
          t1.toString;
          self.postMessage(t2);
        }

    }
  },
  _EventLoop__runHelper_next: {
    "^": "Closure:12;this_0",
    call$0: [function() {
      if (!this.this_0.runIteration$0())
        return;
      P.Timer_Timer(C.Duration_0, this);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _IsolateEvent: {
    "^": "Object;isolate,fn,message<",
    process$0: function() {
      var t1 = this.isolate;
      if (t1.get$isPaused()) {
        t1.get$delayedEvents().push(this);
        return;
      }
      t1.eval$1(this.fn);
    }
  },
  _MainManagerStub: {
    "^": "Object;"
  },
  IsolateNatives__processWorkerMessage_closure: {
    "^": "Closure:55;entryPoint_0,args_1,message_2,isSpawnUri_3,startPaused_4,replyTo_5",
    call$0: [function() {
      H.IsolateNatives__startIsolate(this.entryPoint_0, this.args_1, this.message_2, this.isSpawnUri_3, this.startPaused_4, this.replyTo_5);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  IsolateNatives__startIsolate_runStartFunction: {
    "^": "Closure:12;topLevel_0,args_1,message_2,isSpawnUri_3,context_4",
    call$0: [function() {
      var t1, t2, t3;
      this.context_4.set$initialized(true);
      if (this.isSpawnUri_3 !== true)
        this.topLevel_0.call$1(this.message_2);
      else {
        t1 = this.topLevel_0;
        t2 = H.getDynamicRuntimeType();
        t3 = H.buildFunctionType(t2, [t2, t2])._isTest$1(t1);
        if (t3)
          t1.call$2(this.args_1, this.message_2);
        else {
          t2 = H.buildFunctionType(t2, [t2])._isTest$1(t1);
          if (t2)
            t1.call$1(this.args_1);
          else
            t1.call$0();
        }
      }
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _BaseSendPort: {
    "^": "Object;",
    $isSendPort: true,
    $isCapability: true
  },
  _NativeJsSendPort: {
    "^": "_BaseSendPort;__isolate_helper$_receivePort,_isolateId",
    send$1: function(message) {
      var t1, t2, isolate, t3, shouldSerialize;
      t1 = {};
      t2 = this._isolateId;
      isolate = init.globalState.isolates.$index(0, t2);
      if (isolate == null)
        return;
      t3 = this.__isolate_helper$_receivePort;
      if (t3.get$__isolate_helper$_isClosed())
        return;
      shouldSerialize = init.globalState.currentContext != null && init.globalState.currentContext.id !== t2;
      t1.msg_0 = message;
      if (shouldSerialize)
        t1.msg_0 = H._serializeMessage(message);
      if (isolate.get$controlPort() === t3) {
        isolate.handleControlMessage$1(t1.msg_0);
        return;
      }
      t2 = init.globalState.topEventLoop;
      t3 = "receive " + H.S(message);
      t2.events._add$1(new H._IsolateEvent(isolate, new H._NativeJsSendPort_send_closure(t1, this, shouldSerialize), t3));
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor(other).$is_NativeJsSendPort && J.$eq(this.__isolate_helper$_receivePort, other.__isolate_helper$_receivePort);
    },
    get$hashCode: function(_) {
      return this.__isolate_helper$_receivePort.get$__isolate_helper$_id();
    },
    $is_NativeJsSendPort: true,
    $isSendPort: true,
    $isCapability: true
  },
  _NativeJsSendPort_send_closure: {
    "^": "Closure:55;box_0,this_1,shouldSerialize_2",
    call$0: [function() {
      var t1, t2;
      t1 = this.this_1.__isolate_helper$_receivePort;
      if (!t1.get$__isolate_helper$_isClosed()) {
        if (this.shouldSerialize_2) {
          t2 = this.box_0;
          t2.msg_0 = H._deserializeMessage(t2.msg_0);
        }
        t1.__isolate_helper$_add$1(this.box_0.msg_0);
      }
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _WorkerSendPort: {
    "^": "_BaseSendPort;_workerId,_receivePortId,_isolateId",
    send$1: function(message) {
      var workerMessage, manager;
      workerMessage = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "message", "port", this, "msg", message], null, null));
      if (init.globalState.isWorker === true) {
        init.globalState.mainManager.toString;
        self.postMessage(workerMessage);
      } else {
        manager = init.globalState.managers.$index(0, this._workerId);
        if (manager != null)
          manager.postMessage(workerMessage);
      }
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor(other).$is_WorkerSendPort && J.$eq(this._workerId, other._workerId) && J.$eq(this._isolateId, other._isolateId) && J.$eq(this._receivePortId, other._receivePortId);
    },
    get$hashCode: function(_) {
      var t1, t2, t3;
      t1 = J.$shl$n(this._workerId, 16);
      t2 = J.$shl$n(this._isolateId, 8);
      t3 = this._receivePortId;
      if (typeof t3 !== "number")
        return H.iae(t3);
      return (t1 ^ t2 ^ t3) >>> 0;
    },
    $is_WorkerSendPort: true,
    $isSendPort: true,
    $isCapability: true
  },
  RawReceivePortImpl: {
    "^": "Object;__isolate_helper$_id<,_handler,__isolate_helper$_isClosed<",
    _handler$1: function(arg0) {
      return this._handler.call$1(arg0);
    },
    __isolate_helper$_close$0: function() {
      this.__isolate_helper$_isClosed = true;
      this._handler = null;
    },
    close$0: function() {
      var t1, t2;
      if (this.__isolate_helper$_isClosed)
        return;
      this.__isolate_helper$_isClosed = true;
      this._handler = null;
      t1 = init.globalState.currentContext;
      t2 = this.__isolate_helper$_id;
      t1.ports.remove$1(0, t2);
      t1.weakPorts.remove$1(0, t2);
      t1._updateGlobalState$0();
    },
    __isolate_helper$_add$1: function(dataEvent) {
      if (this.__isolate_helper$_isClosed)
        return;
      this._handler$1(dataEvent);
    },
    static: {"^": "RawReceivePortImpl__nextFreeId"}
  },
  ReceivePortImpl: {
    "^": "Stream;_rawPort,__isolate_helper$_controller",
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var t1 = this.__isolate_helper$_controller;
      t1.toString;
      return H.setRuntimeTypeInfo(new P._ControllerStream(t1), [null]).listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    listen$1: function(onData) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
    },
    close$0: [function() {
      this._rawPort.close$0();
      this.__isolate_helper$_controller.close$0();
    }, "call$0", "get$close", 0, 0, 12],
    ReceivePortImpl$fromRawReceivePort$1: function(_rawPort) {
      var t1 = P.StreamController_StreamController(this.get$close(), null, null, null, true, null);
      this.__isolate_helper$_controller = t1;
      this._rawPort._handler = t1.get$add(t1);
    },
    $asStream: function() {
      return [null];
    }
  },
  _JsSerializer: {
    "^": "_Serializer;_nextFreeRefId,_visited",
    visitSendPort$1: function(x) {
      if (!!x.$is_NativeJsSendPort)
        return ["sendport", init.globalState.currentManagerId, x._isolateId, x.__isolate_helper$_receivePort.get$__isolate_helper$_id()];
      if (!!x.$is_WorkerSendPort)
        return ["sendport", x._workerId, x._isolateId, x._receivePortId];
      throw H.wrapException("Illegal underlying port " + x.toString$0(0));
    },
    visitCapability$1: function(x) {
      if (!!x.$isCapabilityImpl)
        return ["capability", x.__isolate_helper$_id];
      throw H.wrapException("Capability not serializable: " + x.toString$0(0));
    }
  },
  _JsCopier: {
    "^": "_Copier;_visited",
    visitSendPort$1: function(x) {
      if (!!x.$is_NativeJsSendPort)
        return new H._NativeJsSendPort(x.__isolate_helper$_receivePort, x._isolateId);
      if (!!x.$is_WorkerSendPort)
        return new H._WorkerSendPort(x._workerId, x._receivePortId, x._isolateId);
      throw H.wrapException("Illegal underlying port " + x.toString$0(0));
    },
    visitCapability$1: function(x) {
      if (!!x.$isCapabilityImpl)
        return new H.CapabilityImpl(x.__isolate_helper$_id);
      throw H.wrapException("Capability not serializable: " + x.toString$0(0));
    }
  },
  _JsDeserializer: {
    "^": "_Deserializer;_deserialized",
    deserializeSendPort$1: function(list) {
      var t1, managerId, isolateId, receivePortId, isolate, receivePort;
      t1 = J.getInterceptor$asx(list);
      managerId = t1.$index(list, 1);
      isolateId = t1.$index(list, 2);
      receivePortId = t1.$index(list, 3);
      if (J.$eq(managerId, init.globalState.currentManagerId)) {
        isolate = init.globalState.isolates.$index(0, isolateId);
        if (isolate == null)
          return;
        receivePort = isolate.lookup$1(receivePortId);
        if (receivePort == null)
          return;
        return new H._NativeJsSendPort(receivePort, isolateId);
      } else
        return new H._WorkerSendPort(managerId, receivePortId, isolateId);
    },
    deserializeCapability$1: function(list) {
      return new H.CapabilityImpl(J.$index$asx(list, 1));
    }
  },
  _JsVisitedMap: {
    "^": "Object;tagged",
    $index: function(_, object) {
      return object.__MessageTraverser__attached_info__;
    },
    $indexSet: function(_, object, info) {
      this.tagged.push(object);
      object.__MessageTraverser__attached_info__ = info;
    },
    reset$0: function() {
      this.tagged = [];
    },
    cleanup$0: function() {
      var $length, i, t1;
      for ($length = this.tagged.length, i = 0; i < $length; ++i) {
        t1 = this.tagged;
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i].__MessageTraverser__attached_info__ = null;
      }
      this.tagged = null;
    }
  },
  _MessageTraverserVisitedMap: {
    "^": "Object;",
    $index: function(_, object) {
      return;
    },
    $indexSet: function(_, object, info) {
    },
    reset$0: function() {
    },
    cleanup$0: function() {
    }
  },
  _MessageTraverser: {
    "^": "Object;",
    traverse$1: function(x) {
      var result;
      if (H._MessageTraverser_isPrimitive(x))
        return this.visitPrimitive$1(x);
      this._visited.reset$0();
      result = null;
      try {
        result = this._dispatch$1(x);
      } finally {
        this._visited.cleanup$0();
      }
      return result;
    },
    _dispatch$1: function(x) {
      var t1;
      if (x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean")
        return this.visitPrimitive$1(x);
      t1 = J.getInterceptor(x);
      if (!!t1.$isList)
        return this.visitList$1(x);
      if (!!t1.$isMap)
        return this.visitMap$1(x);
      if (!!t1.$isSendPort)
        return this.visitSendPort$1(x);
      if (!!t1.$isCapability)
        return this.visitCapability$1(x);
      return this.visitObject$1(x);
    },
    visitObject$1: function(x) {
      throw H.wrapException("Message serialization: Illegal value " + H.S(x) + " passed");
    }
  },
  _Copier: {
    "^": "_MessageTraverser;",
    visitPrimitive$1: function(x) {
      return x;
    },
    visitList$1: function(list) {
      var copy, t1, len, i;
      copy = this._visited.$index(0, list);
      if (copy != null)
        return copy;
      t1 = J.getInterceptor$asx(list);
      len = t1.get$length(list);
      copy = Array(len);
      copy.fixed$length = init;
      this._visited.$indexSet(0, list, copy);
      for (i = 0; i < len; ++i)
        copy[i] = this._dispatch$1(t1.$index(list, i));
      return copy;
    },
    visitMap$1: function(map) {
      var t1, copy;
      t1 = {};
      copy = this._visited.$index(0, map);
      t1.copy_0 = copy;
      if (copy != null)
        return copy;
      copy = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t1.copy_0 = copy;
      this._visited.$indexSet(0, map, copy);
      map.forEach$1(0, new H._Copier_visitMap_closure(t1, this));
      return t1.copy_0;
    },
    visitSendPort$1: function(x) {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    visitCapability$1: function(x) {
      return H.throwExpression(P.UnimplementedError$(null));
    }
  },
  _Copier_visitMap_closure: {
    "^": "Closure:56;box_0,this_1",
    call$2: function(key, val) {
      var t1 = this.this_1;
      J.$indexSet$ax(this.box_0.copy_0, t1._dispatch$1(key), t1._dispatch$1(val));
    },
    $isFunction: true
  },
  _Serializer: {
    "^": "_MessageTraverser;",
    visitPrimitive$1: function(x) {
      return x;
    },
    visitList$1: function(list) {
      var copyId, t1;
      copyId = this._visited.$index(0, list);
      if (copyId != null)
        return ["ref", copyId];
      t1 = this._nextFreeRefId++;
      this._visited.$indexSet(0, list, t1);
      return ["list", t1, this._serializeList$1(list)];
    },
    visitMap$1: function(map) {
      var copyId, t1, keys, t2;
      copyId = this._visited.$index(0, map);
      if (copyId != null)
        return ["ref", copyId];
      t1 = this._nextFreeRefId++;
      this._visited.$indexSet(0, map, t1);
      keys = this._serializeList$1(map.get$keys().toList$0(0));
      t2 = map.get$values();
      return ["map", t1, keys, this._serializeList$1(P.List_List$from(t2, true, H.getRuntimeTypeArgument(t2, "IterableBase", 0)))];
    },
    _serializeList$1: function(list) {
      var t1, len, result, i, t2;
      t1 = J.getInterceptor$asx(list);
      len = t1.get$length(list);
      result = [];
      C.JSArray_methods.set$length(result, len);
      for (i = 0; i < len; ++i) {
        t2 = this._dispatch$1(t1.$index(list, i));
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = t2;
      }
      return result;
    },
    visitSendPort$1: function(x) {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    visitCapability$1: function(x) {
      return H.throwExpression(P.UnimplementedError$(null));
    }
  },
  _Deserializer: {
    "^": "Object;",
    deserialize$1: function(x) {
      if (H._Deserializer_isPrimitive(x))
        return x;
      this._deserialized = P.HashMap_HashMap(null, null, null, null, null);
      return this._deserializeHelper$1(x);
    },
    _deserializeHelper$1: function(x) {
      var t1, id;
      if (x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean")
        return x;
      t1 = J.getInterceptor$asx(x);
      switch (t1.$index(x, 0)) {
        case "ref":
          id = t1.$index(x, 1);
          return this._deserialized.$index(0, id);
        case "list":
          return this._deserializeList$1(x);
        case "map":
          return this._deserializeMap$1(x);
        case "sendport":
          return this.deserializeSendPort$1(x);
        case "capability":
          return this.deserializeCapability$1(x);
        default:
          return this.deserializeObject$1(x);
      }
    },
    _deserializeList$1: function(x) {
      var t1, id, dartList, len, i;
      t1 = J.getInterceptor$asx(x);
      id = t1.$index(x, 1);
      dartList = t1.$index(x, 2);
      this._deserialized.$indexSet(0, id, dartList);
      t1 = J.getInterceptor$asx(dartList);
      len = t1.get$length(dartList);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        t1.$indexSet(dartList, i, this._deserializeHelper$1(t1.$index(dartList, i)));
      return dartList;
    },
    _deserializeMap$1: function(x) {
      var result, t1, id, keys, values, len, t2, i;
      result = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t1 = J.getInterceptor$asx(x);
      id = t1.$index(x, 1);
      this._deserialized.$indexSet(0, id, result);
      keys = t1.$index(x, 2);
      values = t1.$index(x, 3);
      t1 = J.getInterceptor$asx(keys);
      len = t1.get$length(keys);
      if (typeof len !== "number")
        return H.iae(len);
      t2 = J.getInterceptor$asx(values);
      i = 0;
      for (; i < len; ++i)
        result.$indexSet(0, this._deserializeHelper$1(t1.$index(keys, i)), this._deserializeHelper$1(t2.$index(values, i)));
      return result;
    },
    deserializeObject$1: function(x) {
      throw H.wrapException("Unexpected serialized object");
    }
  },
  TimerImpl: {
    "^": "Object;_once,_inEventLoop,_handle",
    cancel$0: function() {
      if (self.setTimeout != null) {
        if (this._inEventLoop)
          throw H.wrapException(P.UnsupportedError$("Timer in event loop cannot be canceled."));
        if (this._handle == null)
          return;
        H.leaveJsAsync();
        var t1 = this._handle;
        if (this._once)
          self.clearTimeout(t1);
        else
          self.clearInterval(t1);
        this._handle = null;
      } else
        throw H.wrapException(P.UnsupportedError$("Canceling a timer."));
    },
    TimerImpl$periodic$2: function(milliseconds, callback) {
      if (self.setTimeout != null) {
        ++init.globalState.topEventLoop._activeJsAsyncCount;
        this._handle = self.setInterval(H.convertDartClosureToJS(new H.TimerImpl$periodic_closure(this, callback), 0), milliseconds);
      } else
        throw H.wrapException(P.UnsupportedError$("Periodic timer."));
    },
    TimerImpl$2: function(milliseconds, callback) {
      var t1, t2;
      if (milliseconds === 0)
        t1 = self.setTimeout == null || init.globalState.isWorker === true;
      else
        t1 = false;
      if (t1) {
        this._handle = 1;
        t1 = init.globalState.topEventLoop;
        t2 = init.globalState.currentContext;
        t1.events._add$1(new H._IsolateEvent(t2, new H.TimerImpl_internalCallback(this, callback), "timer"));
        this._inEventLoop = true;
      } else if (self.setTimeout != null) {
        ++init.globalState.topEventLoop._activeJsAsyncCount;
        this._handle = self.setTimeout(H.convertDartClosureToJS(new H.TimerImpl_internalCallback0(this, callback), 0), milliseconds);
      } else
        throw H.wrapException(P.UnsupportedError$("Timer greater than 0."));
    },
    static: {TimerImpl$: function(milliseconds, callback) {
        var t1 = new H.TimerImpl(true, false, null);
        t1.TimerImpl$2(milliseconds, callback);
        return t1;
      }, TimerImpl$periodic: function(milliseconds, callback) {
        var t1 = new H.TimerImpl(false, false, null);
        t1.TimerImpl$periodic$2(milliseconds, callback);
        return t1;
      }}
  },
  TimerImpl_internalCallback: {
    "^": "Closure:12;this_0,callback_1",
    call$0: [function() {
      this.this_0._handle = null;
      this.callback_1.call$0();
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  TimerImpl_internalCallback0: {
    "^": "Closure:12;this_2,callback_3",
    call$0: [function() {
      this.this_2._handle = null;
      H.leaveJsAsync();
      this.callback_3.call$0();
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  TimerImpl$periodic_closure: {
    "^": "Closure:55;this_0,callback_1",
    call$0: [function() {
      this.callback_1.call$1(this.this_0);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  CapabilityImpl: {
    "^": "Object;__isolate_helper$_id<",
    get$hashCode: function(_) {
      var hash, t1, t2;
      hash = this.__isolate_helper$_id;
      t1 = J.getInterceptor$n(hash);
      t2 = t1.$shr(hash, 0);
      t1 = t1.$tdiv(hash, 4294967296);
      if (typeof t1 !== "number")
        return H.iae(t1);
      hash = t2 ^ t1;
      hash = (~hash >>> 0) + (hash << 15 >>> 0) & 4294967295;
      hash = ((hash ^ hash >>> 12) >>> 0) * 5 & 4294967295;
      hash = ((hash ^ hash >>> 4) >>> 0) * 2057 & 4294967295;
      return (hash ^ hash >>> 16) >>> 0;
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (other === this)
        return true;
      if (!!J.getInterceptor(other).$isCapabilityImpl) {
        t1 = this.__isolate_helper$_id;
        t2 = other.__isolate_helper$_id;
        return t1 == null ? t2 == null : t1 === t2;
      }
      return false;
    },
    $isCapabilityImpl: true,
    $isCapability: true
  }
}],
["_js_helper", "dart:_js_helper", , H, {
  "^": "",
  isJsIndexable: function(object, record) {
    var result;
    if (record != null) {
      result = record.x;
      if (result != null)
        return result;
    }
    return !!J.getInterceptor(object).$isJavaScriptIndexingBehavior;
  },
  S: function(value) {
    var res;
    if (typeof value === "string")
      return value;
    if (typeof value === "number") {
      if (value !== 0)
        return "" + value;
    } else if (true === value)
      return "true";
    else if (false === value)
      return "false";
    else if (value == null)
      return "null";
    res = J.toString$0(value);
    if (typeof res !== "string")
      throw H.wrapException(P.ArgumentError$(value));
    return res;
  },
  Primitives_objectHashCode: function(object) {
    var hash = object.$identityHash;
    if (hash == null) {
      hash = Math.random() * 0x3fffffff | 0;
      object.$identityHash = hash;
    }
    return hash;
  },
  Primitives__throwFormatException: [function(string) {
    throw H.wrapException(P.FormatException$(string, null, null));
  }, "call$1", "Primitives__throwFormatException$closure", 2, 0, 3],
  Primitives_parseInt: function(source, radix, handleError) {
    var match, t1, maxCharCode, digitsPart, i, t2;
    handleError = H.Primitives__throwFormatException$closure();
    if (typeof source !== "string")
      H.throwExpression(P.ArgumentError$(source));
    match = /^\s*[+-]?((0x[a-f0-9]+)|(\d+)|([a-z0-9]+))\s*$/i.exec(source);
    if (radix == null) {
      if (match != null) {
        t1 = match.length;
        if (2 >= t1)
          return H.ioore(match, 2);
        if (match[2] != null)
          return parseInt(source, 16);
        if (3 >= t1)
          return H.ioore(match, 3);
        if (match[3] != null)
          return parseInt(source, 10);
        return handleError.call$1(source);
      }
      radix = 10;
    } else {
      if (radix < 2 || radix > 36)
        throw H.wrapException(P.RangeError$("Radix " + H.S(radix) + " not in range 2..36"));
      if (match != null) {
        if (radix === 10) {
          if (3 >= match.length)
            return H.ioore(match, 3);
          t1 = match[3] != null;
        } else
          t1 = false;
        if (t1)
          return parseInt(source, 10);
        if (!(radix < 10)) {
          if (3 >= match.length)
            return H.ioore(match, 3);
          t1 = match[3] == null;
        } else
          t1 = true;
        if (t1) {
          maxCharCode = radix <= 10 ? 48 + radix - 1 : 97 + radix - 10 - 1;
          if (1 >= match.length)
            return H.ioore(match, 1);
          digitsPart = match[1];
          t1 = J.getInterceptor$asx(digitsPart);
          i = 0;
          while (true) {
            t2 = t1.get$length(digitsPart);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            t1.codeUnitAt$1(digitsPart, 0);
            if (t1.codeUnitAt$1(digitsPart, i) > maxCharCode)
              return handleError.call$1(source);
            ++i;
          }
        }
      }
    }
    if (match == null)
      return handleError.call$1(source);
    return parseInt(source, radix);
  },
  Primitives_objectTypeName: function(object) {
    var $name, decompiled;
    $name = C.JS_CONST_8ZY(J.getInterceptor(object));
    if ($name === "Object") {
      decompiled = String(object.constructor).match(/^\s*function\s*(\S*)\s*\(/)[1];
      if (typeof decompiled === "string")
        $name = /^\w+$/.test(decompiled) ? decompiled : $name;
    }
    if ($name.length > 1 && C.JSString_methods.codeUnitAt$1($name, 0) === 36)
      $name = C.JSString_methods.substring$1($name, 1);
    return ($name + H.joinArguments(H.getRuntimeTypeInfo(object), 0, null)).replace(/[^<,> ]+/g, function(m) {
      return init.mangledGlobalNames[m] || m;
    });
  },
  Primitives_objectToString: function(object) {
    return "Instance of '" + H.Primitives_objectTypeName(object) + "'";
  },
  Primitives_currentUri: function() {
    if (!!self.location)
      return self.location.href;
    return;
  },
  Primitives__fromCharCodeApply: function(array) {
    var end, t1, result, i, subarray, t2;
    end = array.length;
    for (t1 = end <= 500, result = "", i = 0; i < end; i += 500) {
      if (t1)
        subarray = array;
      else {
        t2 = i + 500;
        t2 = t2 < end ? t2 : end;
        subarray = array.slice(i, t2);
      }
      result += String.fromCharCode.apply(null, subarray);
    }
    return result;
  },
  Primitives_stringFromCodePoints: function(codePoints) {
    var a, t1, i;
    a = [];
    a.$builtinTypeInfo = [P.$int];
    t1 = new H.ListIterator(codePoints, codePoints.length, 0, null);
    t1.$builtinTypeInfo = [H.getTypeArgumentByIndex(codePoints, 0)];
    for (; t1.moveNext$0();) {
      i = t1._current;
      if (typeof i !== "number" || Math.floor(i) !== i)
        throw H.wrapException(P.ArgumentError$(i));
      if (i <= 65535)
        a.push(i);
      else if (i <= 1114111) {
        a.push(55296 + (C.JSInt_methods._shrOtherPositive$1(i - 65536, 10) & 1023));
        a.push(56320 + (i & 1023));
      } else
        throw H.wrapException(P.ArgumentError$(i));
    }
    return H.Primitives__fromCharCodeApply(a);
  },
  Primitives_stringFromCharCodes: function(charCodes) {
    var t1, i;
    for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(charCodes, charCodes.length, 0, null), [H.getTypeArgumentByIndex(charCodes, 0)]); t1.moveNext$0();) {
      i = t1._current;
      if (typeof i !== "number" || Math.floor(i) !== i)
        throw H.wrapException(P.ArgumentError$(i));
      if (i < 0)
        throw H.wrapException(P.ArgumentError$(i));
      if (i > 65535)
        return H.Primitives_stringFromCodePoints(charCodes);
    }
    return H.Primitives__fromCharCodeApply(charCodes);
  },
  Primitives_stringFromCharCode: function(charCode) {
    var bits;
    if (typeof charCode !== "number")
      return H.iae(charCode);
    if (0 <= charCode) {
      if (charCode <= 65535)
        return String.fromCharCode(charCode);
      if (charCode <= 1114111) {
        bits = charCode - 65536;
        return String.fromCharCode((55296 | C.JSNumber_methods._shrOtherPositive$1(bits, 10)) >>> 0, (56320 | bits & 1023) >>> 0);
      }
    }
    throw H.wrapException(P.RangeError$range(charCode, 0, 1114111));
  },
  Primitives_lazyAsJsDate: function(receiver) {
    if (receiver.date === void 0)
      receiver.date = new Date(receiver.millisecondsSinceEpoch);
    return receiver.date;
  },
  Primitives_getYear: function(receiver) {
    return receiver.isUtc === true ? H.Primitives_lazyAsJsDate(receiver).getUTCFullYear() + 0 : H.Primitives_lazyAsJsDate(receiver).getFullYear() + 0;
  },
  Primitives_getMonth: function(receiver) {
    return receiver.isUtc === true ? H.Primitives_lazyAsJsDate(receiver).getUTCMonth() + 1 : H.Primitives_lazyAsJsDate(receiver).getMonth() + 1;
  },
  Primitives_getDay: function(receiver) {
    return receiver.isUtc === true ? H.Primitives_lazyAsJsDate(receiver).getUTCDate() + 0 : H.Primitives_lazyAsJsDate(receiver).getDate() + 0;
  },
  Primitives_getHours: function(receiver) {
    return receiver.isUtc === true ? H.Primitives_lazyAsJsDate(receiver).getUTCHours() + 0 : H.Primitives_lazyAsJsDate(receiver).getHours() + 0;
  },
  Primitives_getMinutes: function(receiver) {
    return receiver.isUtc === true ? H.Primitives_lazyAsJsDate(receiver).getUTCMinutes() + 0 : H.Primitives_lazyAsJsDate(receiver).getMinutes() + 0;
  },
  Primitives_getSeconds: function(receiver) {
    return receiver.isUtc === true ? H.Primitives_lazyAsJsDate(receiver).getUTCSeconds() + 0 : H.Primitives_lazyAsJsDate(receiver).getSeconds() + 0;
  },
  Primitives_getMilliseconds: function(receiver) {
    return receiver.isUtc === true ? H.Primitives_lazyAsJsDate(receiver).getUTCMilliseconds() + 0 : H.Primitives_lazyAsJsDate(receiver).getMilliseconds() + 0;
  },
  Primitives_getProperty: function(object, key) {
    if (object == null || typeof object === "boolean" || typeof object === "number" || typeof object === "string")
      throw H.wrapException(P.ArgumentError$(object));
    return object[key];
  },
  Primitives_setProperty: function(object, key, value) {
    if (object == null || typeof object === "boolean" || typeof object === "number" || typeof object === "string")
      throw H.wrapException(P.ArgumentError$(object));
    object[key] = value;
  },
  Primitives_functionNoSuchMethod: function($function, positionalArguments, namedArguments) {
    var t1, $arguments, namedArgumentList;
    t1 = {};
    t1.argumentCount_0 = 0;
    $arguments = [];
    namedArgumentList = [];
    if (positionalArguments != null) {
      t1.argumentCount_0 = positionalArguments.length;
      C.JSArray_methods.addAll$1($arguments, positionalArguments);
    }
    t1.names_1 = "";
    if (namedArguments != null && !namedArguments.get$isEmpty(namedArguments))
      namedArguments.forEach$1(0, new H.Primitives_functionNoSuchMethod_closure(t1, $arguments, namedArgumentList));
    return $function.noSuchMethod$1(0, new H.JSInvocationMirror(C.Symbol_call, "call$" + t1.argumentCount_0 + t1.names_1, 0, $arguments, namedArgumentList, null));
  },
  Primitives_applyFunction: function($function, positionalArguments, namedArguments) {
    var t1, jsFunction, info, t2, defaultArguments, t3, i, index, $arguments, argumentCount;
    t1 = {};
    if (namedArguments != null && !namedArguments.get$isEmpty(namedArguments)) {
      jsFunction = J.getInterceptor($function)["call*"];
      if (jsFunction == null)
        return H.Primitives_functionNoSuchMethod($function, positionalArguments, namedArguments);
      info = H.ReflectionInfo_ReflectionInfo(jsFunction);
      if (info == null || !info.areOptionalParametersNamed)
        return H.Primitives_functionNoSuchMethod($function, positionalArguments, namedArguments);
      positionalArguments = P.List_List$from(positionalArguments, true, null);
      t2 = info.requiredParameterCount;
      if (t2 !== positionalArguments.length)
        return H.Primitives_functionNoSuchMethod($function, positionalArguments, namedArguments);
      defaultArguments = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      for (t3 = info.optionalParameterCount, i = 0; i < t3; ++i) {
        index = i + t2;
        defaultArguments.$indexSet(0, info.parameterNameInOrder$1(index), init.metadata[info.defaultValueInOrder$1(index)]);
      }
      t1.bad_0 = false;
      namedArguments.forEach$1(0, new H.Primitives_applyFunction_closure(t1, defaultArguments));
      if (t1.bad_0)
        return H.Primitives_functionNoSuchMethod($function, positionalArguments, namedArguments);
      C.JSArray_methods.addAll$1(positionalArguments, defaultArguments.get$values());
      return jsFunction.apply($function, positionalArguments);
    }
    $arguments = [];
    argumentCount = positionalArguments.length;
    C.JSArray_methods.addAll$1($arguments, positionalArguments);
    jsFunction = $function["call$" + argumentCount];
    if (jsFunction == null)
      return H.Primitives_functionNoSuchMethod($function, positionalArguments, namedArguments);
    return jsFunction.apply($function, $arguments);
  },
  iae: function(argument) {
    throw H.wrapException(P.ArgumentError$(argument));
  },
  ioore: function(receiver, index) {
    if (receiver == null)
      J.get$length$asx(receiver);
    if (typeof index !== "number" || Math.floor(index) !== index)
      H.iae(index);
    throw H.wrapException(P.RangeError$value(index));
  },
  wrapException: function(ex) {
    var wrapper;
    if (ex == null)
      ex = new P.NullThrownError();
    wrapper = new Error();
    wrapper.dartException = ex;
    if ("defineProperty" in Object) {
      Object.defineProperty(wrapper, "message", {get: H.toStringWrapper});
      wrapper.name = "";
    } else
      wrapper.toString = H.toStringWrapper;
    return wrapper;
  },
  toStringWrapper: [function() {
    return J.toString$0(this.dartException);
  }, "call$0", "toStringWrapper$closure", 0, 0, null],
  throwExpression: function(ex) {
    throw H.wrapException(ex);
  },
  unwrapException: function(ex) {
    var t1, message, number, ieErrorCode, t2, t3, t4, nullLiteralCall, t5, t6, t7, t8, t9, match;
    t1 = new H.unwrapException_saveStackTrace(ex);
    if (ex == null)
      return;
    if (typeof ex !== "object")
      return ex;
    if ("dartException" in ex)
      return t1.call$1(ex.dartException);
    else if (!("message" in ex))
      return ex;
    message = ex.message;
    if ("number" in ex && typeof ex.number == "number") {
      number = ex.number;
      ieErrorCode = number & 65535;
      if ((C.JSInt_methods._shrOtherPositive$1(number, 16) & 8191) === 10)
        switch (ieErrorCode) {
          case 438:
            return t1.call$1(H.JsNoSuchMethodError$(H.S(message) + " (Error " + ieErrorCode + ")", null));
          case 445:
          case 5007:
            t2 = H.S(message) + " (Error " + ieErrorCode + ")";
            return t1.call$1(new H.NullError(t2, null));
        }
    }
    if (ex instanceof TypeError) {
      t2 = $.get$TypeErrorDecoder_noSuchMethodPattern();
      t3 = $.get$TypeErrorDecoder_notClosurePattern();
      t4 = $.get$TypeErrorDecoder_nullCallPattern();
      nullLiteralCall = $.get$TypeErrorDecoder_nullLiteralCallPattern();
      t5 = $.get$TypeErrorDecoder_undefinedCallPattern();
      t6 = $.get$TypeErrorDecoder_undefinedLiteralCallPattern();
      t7 = $.get$TypeErrorDecoder_nullPropertyPattern();
      $.get$TypeErrorDecoder_nullLiteralPropertyPattern();
      t8 = $.get$TypeErrorDecoder_undefinedPropertyPattern();
      t9 = $.get$TypeErrorDecoder_undefinedLiteralPropertyPattern();
      match = t2.matchTypeError$1(message);
      if (match != null)
        return t1.call$1(H.JsNoSuchMethodError$(message, match));
      else {
        match = t3.matchTypeError$1(message);
        if (match != null) {
          match.method = "call";
          return t1.call$1(H.JsNoSuchMethodError$(message, match));
        } else {
          match = t4.matchTypeError$1(message);
          if (match == null) {
            match = nullLiteralCall.matchTypeError$1(message);
            if (match == null) {
              match = t5.matchTypeError$1(message);
              if (match == null) {
                match = t6.matchTypeError$1(message);
                if (match == null) {
                  match = t7.matchTypeError$1(message);
                  if (match == null) {
                    match = nullLiteralCall.matchTypeError$1(message);
                    if (match == null) {
                      match = t8.matchTypeError$1(message);
                      if (match == null) {
                        match = t9.matchTypeError$1(message);
                        t2 = match != null;
                      } else
                        t2 = true;
                    } else
                      t2 = true;
                  } else
                    t2 = true;
                } else
                  t2 = true;
              } else
                t2 = true;
            } else
              t2 = true;
          } else
            t2 = true;
          if (t2) {
            t2 = match == null ? null : match.method;
            return t1.call$1(new H.NullError(message, t2));
          }
        }
      }
      t2 = typeof message === "string" ? message : "";
      return t1.call$1(new H.UnknownJsTypeError(t2));
    }
    if (ex instanceof RangeError) {
      if (typeof message === "string" && message.indexOf("call stack") !== -1)
        return new P.StackOverflowError();
      return t1.call$1(new P.ArgumentError(null));
    }
    if (typeof InternalError == "function" && ex instanceof InternalError)
      if (typeof message === "string" && message === "too much recursion")
        return new P.StackOverflowError();
    return ex;
  },
  objectHashCode: function(object) {
    if (object == null || typeof object != 'object')
      return J.get$hashCode$(object);
    else
      return H.Primitives_objectHashCode(object);
  },
  fillLiteralMap: function(keyValuePairs, result) {
    var $length, index, index0, index1;
    $length = keyValuePairs.length;
    for (index = 0; index < $length; index = index1) {
      index0 = index + 1;
      index1 = index0 + 1;
      result.$indexSet(0, keyValuePairs[index], keyValuePairs[index0]);
    }
    return result;
  },
  invokeClosure: [function(closure, isolate, numberOfArguments, arg1, arg2, arg3, arg4) {
    var t1 = J.getInterceptor(numberOfArguments);
    if (t1.$eq(numberOfArguments, 0))
      return H._callInIsolate(isolate, new H.invokeClosure_closure(closure));
    else if (t1.$eq(numberOfArguments, 1))
      return H._callInIsolate(isolate, new H.invokeClosure_closure0(closure, arg1));
    else if (t1.$eq(numberOfArguments, 2))
      return H._callInIsolate(isolate, new H.invokeClosure_closure1(closure, arg1, arg2));
    else if (t1.$eq(numberOfArguments, 3))
      return H._callInIsolate(isolate, new H.invokeClosure_closure2(closure, arg1, arg2, arg3));
    else if (t1.$eq(numberOfArguments, 4))
      return H._callInIsolate(isolate, new H.invokeClosure_closure3(closure, arg1, arg2, arg3, arg4));
    else
      throw H.wrapException(P.Exception_Exception("Unsupported number of arguments for wrapped closure"));
  }, "call$7", "invokeClosure$closure", 14, 0, null, 4, 5, 6, 7, 8, 9, 10],
  convertDartClosureToJS: function(closure, arity) {
    var $function;
    if (closure == null)
      return;
    $function = closure.$identity;
    if (!!$function)
      return $function;
    $function = function(closure, arity, context, invoke) {
      return function(a1, a2, a3, a4) {
        return invoke(closure, context, arity, a1, a2, a3, a4);
      };
    }(closure, arity, init.globalState.currentContext, H.invokeClosure);
    closure.$identity = $function;
    return $function;
  },
  Closure_fromTearOff: function(receiver, functions, reflectionInfo, isStatic, jsArguments, propertyName) {
    var $function, callName, functionType, $prototype, $constructor, t1, isIntercepted, trampoline, signatureFunction, getReceiver, i, stub, stubCallName, t2;
    $function = functions[0];
    $function.$stubName;
    callName = $function.$callName;
    $function.$reflectionInfo = reflectionInfo;
    functionType = H.ReflectionInfo_ReflectionInfo($function).functionType;
    $prototype = isStatic ? Object.create(new H.TearOffClosure().constructor.prototype) : Object.create(new H.BoundClosure(null, null, null, null).constructor.prototype);
    $prototype.$initialize = $prototype.constructor;
    if (isStatic)
      $constructor = function() {
        this.$initialize();
      };
    else if (typeof dart_precompiled == "function") {
      t1 = function(a, b, c, d) {
        this.$initialize(a, b, c, d);
      };
      $constructor = t1;
    } else {
      t1 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t1, 1);
      t1 = new Function("a", "b", "c", "d", "this.$initialize(a,b,c,d);" + t1);
      $constructor = t1;
    }
    $prototype.constructor = $constructor;
    $constructor.prototype = $prototype;
    t1 = !isStatic;
    if (t1) {
      isIntercepted = jsArguments.length == 1 && true;
      trampoline = H.Closure_forwardCallTo(receiver, $function, isIntercepted);
      trampoline.$reflectionInfo = reflectionInfo;
    } else {
      $prototype.$name = propertyName;
      trampoline = $function;
      isIntercepted = false;
    }
    if (typeof functionType == "number")
      signatureFunction = function(s) {
        return function() {
          return init.metadata[s];
        };
      }(functionType);
    else if (t1 && typeof functionType == "function") {
      getReceiver = isIntercepted ? H.BoundClosure_receiverOf : H.BoundClosure_selfOf;
      signatureFunction = function(f, r) {
        return function() {
          return f.apply({$receiver: r(this)}, arguments);
        };
      }(functionType, getReceiver);
    } else
      throw H.wrapException("Error in reflectionInfo.");
    $prototype.$signature = signatureFunction;
    $prototype[callName] = trampoline;
    for (t1 = functions.length, i = 1; i < t1; ++i) {
      stub = functions[i];
      stubCallName = stub.$callName;
      if (stubCallName != null) {
        t2 = isStatic ? stub : H.Closure_forwardCallTo(receiver, stub, isIntercepted);
        $prototype[stubCallName] = t2;
      }
    }
    $prototype["call*"] = trampoline;
    return $constructor;
  },
  Closure_cspForwardCall: function(arity, isSuperCall, stubName, $function) {
    var getSelf = H.BoundClosure_selfOf;
    switch (isSuperCall ? -1 : arity) {
      case 0:
        return function(n, S) {
          return function() {
            return S(this)[n]();
          };
        }(stubName, getSelf);
      case 1:
        return function(n, S) {
          return function(a) {
            return S(this)[n](a);
          };
        }(stubName, getSelf);
      case 2:
        return function(n, S) {
          return function(a, b) {
            return S(this)[n](a, b);
          };
        }(stubName, getSelf);
      case 3:
        return function(n, S) {
          return function(a, b, c) {
            return S(this)[n](a, b, c);
          };
        }(stubName, getSelf);
      case 4:
        return function(n, S) {
          return function(a, b, c, d) {
            return S(this)[n](a, b, c, d);
          };
        }(stubName, getSelf);
      case 5:
        return function(n, S) {
          return function(a, b, c, d, e) {
            return S(this)[n](a, b, c, d, e);
          };
        }(stubName, getSelf);
      default:
        return function(f, s) {
          return function() {
            return f.apply(s(this), arguments);
          };
        }($function, getSelf);
    }
  },
  Closure_forwardCallTo: function(receiver, $function, isIntercepted) {
    var stubName, arity, lookedUpFunction, t1, t2, $arguments;
    if (isIntercepted)
      return H.Closure_forwardInterceptedCallTo(receiver, $function);
    stubName = $function.$stubName;
    arity = $function.length;
    lookedUpFunction = receiver[stubName];
    t1 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
    if (typeof dart_precompiled == "function" || !t1 || arity >= 27)
      return H.Closure_cspForwardCall(arity, !t1, stubName, $function);
    if (arity === 0) {
      t1 = $.BoundClosure_selfFieldNameCache;
      if (t1 == null) {
        t1 = H.BoundClosure_computeFieldNamed("self");
        $.BoundClosure_selfFieldNameCache = t1;
      }
      t1 = "return function(){return this." + H.S(t1) + "." + H.S(stubName) + "();";
      t2 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t2, 1);
      return new Function(t1 + H.S(t2) + "}")();
    }
    $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity).join(",");
    t1 = "return function(" + $arguments + "){return this.";
    t2 = $.BoundClosure_selfFieldNameCache;
    if (t2 == null) {
      t2 = H.BoundClosure_computeFieldNamed("self");
      $.BoundClosure_selfFieldNameCache = t2;
    }
    t2 = t1 + H.S(t2) + "." + H.S(stubName) + "(" + $arguments + ");";
    t1 = $.Closure_functionCounter;
    $.Closure_functionCounter = J.$add$ns(t1, 1);
    return new Function(t2 + H.S(t1) + "}")();
  },
  Closure_cspForwardInterceptedCall: function(arity, isSuperCall, $name, $function) {
    var getSelf, getReceiver;
    getSelf = H.BoundClosure_selfOf;
    getReceiver = H.BoundClosure_receiverOf;
    switch (isSuperCall ? -1 : arity) {
      case 0:
        throw H.wrapException(H.RuntimeError$("Intercepted function with no arguments."));
      case 1:
        return function(n, s, r) {
          return function() {
            return s(this)[n](r(this));
          };
        }($name, getSelf, getReceiver);
      case 2:
        return function(n, s, r) {
          return function(a) {
            return s(this)[n](r(this), a);
          };
        }($name, getSelf, getReceiver);
      case 3:
        return function(n, s, r) {
          return function(a, b) {
            return s(this)[n](r(this), a, b);
          };
        }($name, getSelf, getReceiver);
      case 4:
        return function(n, s, r) {
          return function(a, b, c) {
            return s(this)[n](r(this), a, b, c);
          };
        }($name, getSelf, getReceiver);
      case 5:
        return function(n, s, r) {
          return function(a, b, c, d) {
            return s(this)[n](r(this), a, b, c, d);
          };
        }($name, getSelf, getReceiver);
      case 6:
        return function(n, s, r) {
          return function(a, b, c, d, e) {
            return s(this)[n](r(this), a, b, c, d, e);
          };
        }($name, getSelf, getReceiver);
      default:
        return function(f, s, r, a) {
          return function() {
            a = [r(this)];
            Array.prototype.push.apply(a, arguments);
            return f.apply(s(this), a);
          };
        }($function, getSelf, getReceiver);
    }
  },
  Closure_forwardInterceptedCallTo: function(receiver, $function) {
    var selfField, t1, stubName, arity, isCsp, lookedUpFunction, t2, $arguments;
    selfField = H.BoundClosure_selfFieldName();
    t1 = $.BoundClosure_receiverFieldNameCache;
    if (t1 == null) {
      t1 = H.BoundClosure_computeFieldNamed("receiver");
      $.BoundClosure_receiverFieldNameCache = t1;
    }
    stubName = $function.$stubName;
    arity = $function.length;
    isCsp = typeof dart_precompiled == "function";
    lookedUpFunction = receiver[stubName];
    t2 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
    if (isCsp || !t2 || arity >= 28)
      return H.Closure_cspForwardInterceptedCall(arity, !t2, stubName, $function);
    if (arity === 1) {
      t1 = "return function(){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(t1) + ");";
      t2 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t2, 1);
      return new Function(t1 + H.S(t2) + "}")();
    }
    $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity - 1).join(",");
    t1 = "return function(" + $arguments + "){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(t1) + ", " + $arguments + ");";
    t2 = $.Closure_functionCounter;
    $.Closure_functionCounter = J.$add$ns(t2, 1);
    return new Function(t1 + H.S(t2) + "}")();
  },
  closureFromTearOff: function(receiver, functions, reflectionInfo, isStatic, jsArguments, $name) {
    functions.fixed$length = init;
    reflectionInfo.fixed$length = init;
    return H.Closure_fromTearOff(receiver, functions, reflectionInfo, !!isStatic, jsArguments, $name);
  },
  throwCyclicInit: function(staticName) {
    throw H.wrapException(P.CyclicInitializationError$("Cyclic initialization for static " + H.S(staticName)));
  },
  buildFunctionType: function(returnType, parameterTypes, optionalParameterTypes) {
    return new H.RuntimeFunctionType(returnType, parameterTypes, optionalParameterTypes, null);
  },
  getDynamicRuntimeType: function() {
    return C.C_DynamicRuntimeType;
  },
  random64: function() {
    return (Math.random() * 0x100000000 >>> 0) + (Math.random() * 0x100000000 >>> 0) * 4294967296;
  },
  createRuntimeType: function($name) {
    return new H.TypeImpl($name, null);
  },
  setRuntimeTypeInfo: function(target, typeInfo) {
    if (target != null)
      target.$builtinTypeInfo = typeInfo;
    return target;
  },
  getRuntimeTypeInfo: function(target) {
    if (target == null)
      return;
    return target.$builtinTypeInfo;
  },
  getRuntimeTypeArguments: function(target, substitutionName) {
    return H.substitute(target["$as" + H.S(substitutionName)], H.getRuntimeTypeInfo(target));
  },
  getRuntimeTypeArgument: function(target, substitutionName, index) {
    var $arguments = H.getRuntimeTypeArguments(target, substitutionName);
    return $arguments == null ? null : $arguments[index];
  },
  getTypeArgumentByIndex: function(target, index) {
    var rti = H.getRuntimeTypeInfo(target);
    return rti == null ? null : rti[index];
  },
  runtimeTypeToString: function(type, onTypeVariable) {
    if (type == null)
      return "dynamic";
    else if (typeof type === "object" && type !== null && type.constructor === Array)
      return type[0].builtin$cls + H.joinArguments(type, 1, onTypeVariable);
    else if (typeof type == "function")
      return type.builtin$cls;
    else if (typeof type === "number" && Math.floor(type) === type)
      return C.JSInt_methods.toString$0(type);
    else
      return;
  },
  joinArguments: function(types, startIndex, onTypeVariable) {
    var buffer, index, firstArgument, allDynamic, argument, str;
    if (types == null)
      return "";
    buffer = P.StringBuffer$("");
    for (index = startIndex, firstArgument = true, allDynamic = true; index < types.length; ++index) {
      if (firstArgument)
        firstArgument = false;
      else
        buffer._contents += ", ";
      argument = types[index];
      if (argument != null)
        allDynamic = false;
      str = H.runtimeTypeToString(argument, onTypeVariable);
      buffer._contents += typeof str === "string" ? str : H.S(str);
    }
    return allDynamic ? "" : "<" + H.S(buffer) + ">";
  },
  getRuntimeTypeString: function(object) {
    var className = J.getInterceptor(object).constructor.builtin$cls;
    if (object == null)
      return className;
    return className + H.joinArguments(object.$builtinTypeInfo, 0, null);
  },
  substitute: function(substitution, $arguments) {
    if (typeof substitution === "object" && substitution !== null && substitution.constructor === Array)
      $arguments = substitution;
    else if (typeof substitution == "function") {
      substitution = H.invokeOn(substitution, null, $arguments);
      if (typeof substitution === "object" && substitution !== null && substitution.constructor === Array)
        $arguments = substitution;
      else if (typeof substitution == "function")
        $arguments = H.invokeOn(substitution, null, $arguments);
    }
    return $arguments;
  },
  areSubtypes: function(s, t) {
    var len, i;
    if (s == null || t == null)
      return true;
    len = s.length;
    for (i = 0; i < len; ++i)
      if (!H.isSubtype(s[i], t[i]))
        return false;
    return true;
  },
  computeSignature: function(signature, context, contextName) {
    return H.invokeOn(signature, context, H.getRuntimeTypeArguments(context, contextName));
  },
  isSubtype: function(s, t) {
    var targetSignatureFunction, t1, typeOfS, t2, typeOfT, $name, substitution;
    if (s === t)
      return true;
    if (s == null || t == null)
      return true;
    if ("func" in t) {
      if (!("func" in s)) {
        if ("$is_" + H.S(t.func) in s)
          return true;
        targetSignatureFunction = s.$signature;
        if (targetSignatureFunction == null)
          return false;
        s = targetSignatureFunction.apply(s, null);
      }
      return H.isFunctionSubtype(s, t);
    }
    if (t.builtin$cls === "Function" && "func" in s)
      return true;
    t1 = typeof s === "object" && s !== null && s.constructor === Array;
    typeOfS = t1 ? s[0] : s;
    t2 = typeof t === "object" && t !== null && t.constructor === Array;
    typeOfT = t2 ? t[0] : t;
    $name = H.runtimeTypeToString(typeOfT, null);
    if (typeOfT !== typeOfS) {
      if (!("$is" + H.S($name) in typeOfS))
        return false;
      substitution = typeOfS["$as" + H.S(H.runtimeTypeToString(typeOfT, null))];
    } else
      substitution = null;
    if (!t1 && substitution == null || !t2)
      return true;
    t1 = t1 ? s.slice(1) : null;
    t2 = t2 ? t.slice(1) : null;
    return H.areSubtypes(H.substitute(substitution, t1), t2);
  },
  areAssignable: function(s, t, allowShorter) {
    var sLength, tLength, i, t1, t2;
    if (t == null && s == null)
      return true;
    if (t == null)
      return allowShorter;
    if (s == null)
      return false;
    sLength = s.length;
    tLength = t.length;
    if (allowShorter) {
      if (sLength < tLength)
        return false;
    } else if (sLength !== tLength)
      return false;
    for (i = 0; i < tLength; ++i) {
      t1 = s[i];
      t2 = t[i];
      if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
        return false;
    }
    return true;
  },
  areAssignableMaps: function(s, t) {
    var t1, names, i, $name, tType, sType;
    if (t == null)
      return true;
    if (s == null)
      return false;
    t1 = Object.getOwnPropertyNames(t);
    t1.fixed$length = init;
    names = t1;
    for (t1 = names.length, i = 0; i < t1; ++i) {
      $name = names[i];
      if (!Object.hasOwnProperty.call(s, $name))
        return false;
      tType = t[$name];
      sType = s[$name];
      if (!(H.isSubtype(tType, sType) || H.isSubtype(sType, tType)))
        return false;
    }
    return true;
  },
  isFunctionSubtype: function(s, t) {
    var sReturnType, tReturnType, sParameterTypes, tParameterTypes, sOptionalParameterTypes, tOptionalParameterTypes, sParametersLen, tParametersLen, sOptionalParametersLen, tOptionalParametersLen, pos, t1, t2, tPos, sPos;
    if (!("func" in s))
      return false;
    if ("void" in s) {
      if (!("void" in t) && "ret" in t)
        return false;
    } else if (!("void" in t)) {
      sReturnType = s.ret;
      tReturnType = t.ret;
      if (!(H.isSubtype(sReturnType, tReturnType) || H.isSubtype(tReturnType, sReturnType)))
        return false;
    }
    sParameterTypes = s.args;
    tParameterTypes = t.args;
    sOptionalParameterTypes = s.opt;
    tOptionalParameterTypes = t.opt;
    sParametersLen = sParameterTypes != null ? sParameterTypes.length : 0;
    tParametersLen = tParameterTypes != null ? tParameterTypes.length : 0;
    sOptionalParametersLen = sOptionalParameterTypes != null ? sOptionalParameterTypes.length : 0;
    tOptionalParametersLen = tOptionalParameterTypes != null ? tOptionalParameterTypes.length : 0;
    if (sParametersLen > tParametersLen)
      return false;
    if (sParametersLen + sOptionalParametersLen < tParametersLen + tOptionalParametersLen)
      return false;
    if (sParametersLen === tParametersLen) {
      if (!H.areAssignable(sParameterTypes, tParameterTypes, false))
        return false;
      if (!H.areAssignable(sOptionalParameterTypes, tOptionalParameterTypes, true))
        return false;
    } else {
      for (pos = 0; pos < sParametersLen; ++pos) {
        t1 = sParameterTypes[pos];
        t2 = tParameterTypes[pos];
        if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
          return false;
      }
      for (tPos = pos, sPos = 0; tPos < tParametersLen; ++sPos, ++tPos) {
        t1 = sOptionalParameterTypes[sPos];
        t2 = tParameterTypes[tPos];
        if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
          return false;
      }
      for (tPos = 0; tPos < tOptionalParametersLen; ++sPos, ++tPos) {
        t1 = sOptionalParameterTypes[sPos];
        t2 = tOptionalParameterTypes[tPos];
        if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
          return false;
      }
    }
    return H.areAssignableMaps(s.named, t.named);
  },
  invokeOn: function($function, receiver, $arguments) {
    return $function.apply(receiver, $arguments);
  },
  toStringForNativeObject: function(obj) {
    var t1 = $.getTagFunction;
    return "Instance of " + (t1 == null ? "<Unknown>" : t1.call$1(obj));
  },
  hashCodeForNativeObject: function(object) {
    return H.Primitives_objectHashCode(object);
  },
  defineProperty: function(obj, property, value) {
    Object.defineProperty(obj, property, {value: value, enumerable: false, writable: true, configurable: true});
  },
  lookupAndCacheInterceptor: function(obj) {
    var tag, record, interceptor, interceptorClass, mark, t1;
    tag = $.getTagFunction.call$1(obj);
    record = $.dispatchRecordsForInstanceTags[tag];
    if (record != null) {
      Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
      return record.i;
    }
    interceptor = $.interceptorsForUncacheableTags[tag];
    if (interceptor != null)
      return interceptor;
    interceptorClass = init.interceptorsByTag[tag];
    if (interceptorClass == null) {
      tag = $.alternateTagFunction.call$2(obj, tag);
      if (tag != null) {
        record = $.dispatchRecordsForInstanceTags[tag];
        if (record != null) {
          Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
          return record.i;
        }
        interceptor = $.interceptorsForUncacheableTags[tag];
        if (interceptor != null)
          return interceptor;
        interceptorClass = init.interceptorsByTag[tag];
      }
    }
    if (interceptorClass == null)
      return;
    interceptor = interceptorClass.prototype;
    mark = tag[0];
    if (mark === "!") {
      record = H.makeLeafDispatchRecord(interceptor);
      $.dispatchRecordsForInstanceTags[tag] = record;
      Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
      return record.i;
    }
    if (mark === "~") {
      $.interceptorsForUncacheableTags[tag] = interceptor;
      return interceptor;
    }
    if (mark === "-") {
      t1 = H.makeLeafDispatchRecord(interceptor);
      Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
      return t1.i;
    }
    if (mark === "+")
      return H.patchInteriorProto(obj, interceptor);
    if (mark === "*")
      throw H.wrapException(P.UnimplementedError$(tag));
    if (init.leafTags[tag] === true) {
      t1 = H.makeLeafDispatchRecord(interceptor);
      Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
      return t1.i;
    } else
      return H.patchInteriorProto(obj, interceptor);
  },
  patchInteriorProto: function(obj, interceptor) {
    var proto, record;
    proto = Object.getPrototypeOf(obj);
    record = J.makeDispatchRecord(interceptor, proto, null, null);
    Object.defineProperty(proto, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
    return interceptor;
  },
  makeLeafDispatchRecord: function(interceptor) {
    return J.makeDispatchRecord(interceptor, false, null, !!interceptor.$isJavaScriptIndexingBehavior);
  },
  makeDefaultDispatchRecord: function(tag, interceptorClass, proto) {
    var interceptor = interceptorClass.prototype;
    if (init.leafTags[tag] === true)
      return J.makeDispatchRecord(interceptor, false, null, !!interceptor.$isJavaScriptIndexingBehavior);
    else
      return J.makeDispatchRecord(interceptor, proto, null, null);
  },
  initNativeDispatch: function() {
    if (true === $.initNativeDispatchFlag)
      return;
    $.initNativeDispatchFlag = true;
    H.initNativeDispatchContinue();
  },
  initNativeDispatchContinue: function() {
    var map, tags, fun, i, tag, proto, record, interceptorClass;
    $.dispatchRecordsForInstanceTags = Object.create(null);
    $.interceptorsForUncacheableTags = Object.create(null);
    H.initHooks();
    map = init.interceptorsByTag;
    tags = Object.getOwnPropertyNames(map);
    if (typeof window != "undefined") {
      window;
      fun = function() {
      };
      for (i = 0; i < tags.length; ++i) {
        tag = tags[i];
        proto = $.prototypeForTagFunction.call$1(tag);
        if (proto != null) {
          record = H.makeDefaultDispatchRecord(tag, map[tag], proto);
          if (record != null) {
            Object.defineProperty(proto, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
            fun.prototype = proto;
          }
        }
      }
    }
    for (i = 0; i < tags.length; ++i) {
      tag = tags[i];
      if (/^[A-Za-z_]/.test(tag)) {
        interceptorClass = map[tag];
        map["!" + tag] = interceptorClass;
        map["~" + tag] = interceptorClass;
        map["-" + tag] = interceptorClass;
        map["+" + tag] = interceptorClass;
        map["*" + tag] = interceptorClass;
      }
    }
  },
  initHooks: function() {
    var hooks, transformers, i, transformer, getTag, getUnknownTag, prototypeForTag;
    hooks = C.JS_CONST_oRe();
    hooks = H.applyHooksTransformer(C.JS_CONST_0, H.applyHooksTransformer(C.JS_CONST_rr7, H.applyHooksTransformer(C.JS_CONST_Fs4, H.applyHooksTransformer(C.JS_CONST_Fs4, H.applyHooksTransformer(C.JS_CONST_gkc, H.applyHooksTransformer(C.JS_CONST_4hp, H.applyHooksTransformer(C.JS_CONST_QJm(C.JS_CONST_8ZY), hooks)))))));
    if (typeof dartNativeDispatchHooksTransformer != "undefined") {
      transformers = dartNativeDispatchHooksTransformer;
      if (typeof transformers == "function")
        transformers = [transformers];
      if (transformers.constructor == Array)
        for (i = 0; i < transformers.length; ++i) {
          transformer = transformers[i];
          if (typeof transformer == "function")
            hooks = transformer(hooks) || hooks;
        }
    }
    getTag = hooks.getTag;
    getUnknownTag = hooks.getUnknownTag;
    prototypeForTag = hooks.prototypeForTag;
    $.getTagFunction = new H.initHooks_closure(getTag);
    $.alternateTagFunction = new H.initHooks_closure0(getUnknownTag);
    $.prototypeForTagFunction = new H.initHooks_closure1(prototypeForTag);
  },
  applyHooksTransformer: function(transformer, hooks) {
    return transformer(hooks) || hooks;
  },
  allMatchesInStringUnchecked: function(needle, haystack, startIndex) {
    var result, t1, $length, patternLength, position, endIndex;
    result = H.setRuntimeTypeInfo([], [P.Match]);
    t1 = J.getInterceptor$asx(haystack);
    $length = t1.get$length(haystack);
    patternLength = needle.length;
    for (; true;) {
      position = t1.indexOf$2(haystack, needle, startIndex);
      if (position === -1)
        break;
      result.push(new H.StringMatch(position, haystack, needle));
      endIndex = position + patternLength;
      if (endIndex === $length)
        break;
      else
        startIndex = position === endIndex ? startIndex + 1 : endIndex;
    }
    return result;
  },
  stringContainsUnchecked: function(receiver, other, startIndex) {
    var t1, t2;
    if (typeof other === "string")
      return C.JSString_methods.indexOf$2(receiver, other, startIndex) !== -1;
    else {
      t1 = J.getInterceptor(other);
      if (!!t1.$isJSSyntaxRegExp) {
        t1 = C.JSString_methods.substring$1(receiver, startIndex);
        t2 = other._nativeRegExp;
        return t2.test(t1);
      } else
        return J.get$isNotEmpty$asx(t1.allMatches$1(other, C.JSString_methods.substring$1(receiver, startIndex)));
    }
  },
  stringReplaceAllUnchecked: function(receiver, from, to) {
    var result, $length, i, t1, nativeRegexp;
    if (typeof from === "string")
      if (from === "")
        if (receiver === "")
          return to;
        else {
          result = P.StringBuffer$("");
          $length = receiver.length;
          result.write$1(to);
          for (i = 0; i < $length; ++i) {
            t1 = receiver[i];
            t1 = result._contents += t1;
            result._contents = t1 + to;
          }
          return result._contents;
        }
      else
        return receiver.replace(new RegExp(from.replace(new RegExp("[[\\]{}()*+?.\\\\^$|]", 'g'), "\\$&"), 'g'), to.replace(/\$/g, "$$$$"));
    else if (!!J.getInterceptor(from).$isJSSyntaxRegExp) {
      nativeRegexp = from.get$_nativeGlobalVersion();
      nativeRegexp.lastIndex = 0;
      return receiver.replace(nativeRegexp, to.replace(/\$/g, "$$$$"));
    } else {
      if (from == null)
        H.throwExpression(P.ArgumentError$(null));
      throw H.wrapException("String.replaceAll(Pattern) UNIMPLEMENTED");
    }
  },
  stringReplaceFirstUnchecked: function(receiver, from, to) {
    if (typeof from === "string")
      return receiver.replace(from, to.replace(/\$/g, "$$$$"));
    else if (!!J.getInterceptor(from).$isJSSyntaxRegExp)
      return receiver.replace(from._nativeRegExp, to.replace(/\$/g, "$$$$"));
    else {
      if (from == null)
        H.throwExpression(P.ArgumentError$(null));
      throw H.wrapException("String.replace(Pattern) UNIMPLEMENTED");
    }
  },
  JSInvocationMirror: {
    "^": "Object;__js_helper$_memberName,_internalName,_kind,_arguments,_namedArgumentNames,_namedIndices",
    static: {"^": "JSInvocationMirror_METHOD,JSInvocationMirror_GETTER,JSInvocationMirror_SETTER"}
  },
  ReflectionInfo: {
    "^": "Object;jsFunction,data,isAccessor,requiredParameterCount,optionalParameterCount,areOptionalParametersNamed,functionType,cachedSortedIndices",
    parameterName$1: function(parameter) {
      var metadataIndex = this.data[parameter + this.optionalParameterCount + 3];
      return init.metadata[metadataIndex];
    },
    defaultValue$1: function(parameter) {
      var t1 = this.requiredParameterCount;
      if (typeof parameter !== "number")
        return parameter.$lt();
      if (parameter < t1)
        return;
      return this.data[3 + parameter - t1];
    },
    defaultValueInOrder$1: function(parameter) {
      var t1 = this.requiredParameterCount;
      if (parameter < t1)
        return;
      if (!this.areOptionalParametersNamed || this.optionalParameterCount === 1)
        return this.defaultValue$1(parameter);
      return this.defaultValue$1(this.sortedIndex$1(parameter - t1));
    },
    parameterNameInOrder$1: function(parameter) {
      var t1 = this.requiredParameterCount;
      if (parameter < t1)
        return;
      if (!this.areOptionalParametersNamed || this.optionalParameterCount === 1)
        return this.parameterName$1(parameter);
      return this.parameterName$1(this.sortedIndex$1(parameter - t1));
    },
    sortedIndex$1: function(unsortedIndex) {
      var t1, t2, positions, t3, i, index, compare;
      t1 = {};
      if (this.cachedSortedIndices == null) {
        t2 = this.optionalParameterCount;
        this.cachedSortedIndices = Array(t2);
        positions = P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.$int);
        for (t3 = this.requiredParameterCount, i = 0; i < t2; ++i) {
          index = t3 + i;
          positions.$indexSet(0, this.parameterName$1(index), index);
        }
        t1.index_0 = 0;
        t2 = positions.get$keys().toList$0(0);
        compare = P.Comparable_compare$closure();
        H.Sort__doSort(t2, 0, t2.length - 1, compare);
        H.IterableMixinWorkaround_forEach(t2, new H.ReflectionInfo_sortedIndex_closure(t1, this, positions));
      }
      t1 = this.cachedSortedIndices;
      if (unsortedIndex < 0 || unsortedIndex >= t1.length)
        return H.ioore(t1, unsortedIndex);
      return t1[unsortedIndex];
    },
    static: {"^": "ReflectionInfo_REQUIRED_PARAMETERS_INFO,ReflectionInfo_OPTIONAL_PARAMETERS_INFO,ReflectionInfo_FUNCTION_TYPE_INDEX,ReflectionInfo_FIRST_DEFAULT_ARGUMENT", ReflectionInfo_ReflectionInfo: function(jsFunction) {
        var data, requiredParametersInfo, optionalParametersInfo;
        data = jsFunction.$reflectionInfo;
        if (data == null)
          return;
        data.fixed$length = init;
        data = data;
        requiredParametersInfo = data[0];
        optionalParametersInfo = data[1];
        return new H.ReflectionInfo(jsFunction, data, (requiredParametersInfo & 1) === 1, requiredParametersInfo >> 1, optionalParametersInfo >> 1, (optionalParametersInfo & 1) === 1, data[2], null);
      }}
  },
  ReflectionInfo_sortedIndex_closure: {
    "^": "Closure:3;box_0,this_1,positions_2",
    call$1: function($name) {
      var t1, t2, t3;
      t1 = this.this_1.cachedSortedIndices;
      t2 = this.box_0.index_0++;
      t3 = this.positions_2.$index(0, $name);
      if (t2 >= t1.length)
        return H.ioore(t1, t2);
      t1[t2] = t3;
    },
    $isFunction: true
  },
  Primitives_functionNoSuchMethod_closure: {
    "^": "Closure:57;box_0,arguments_1,namedArgumentList_2",
    call$2: function($name, argument) {
      var t1 = this.box_0;
      t1.names_1 = t1.names_1 + "$" + H.S($name);
      this.namedArgumentList_2.push($name);
      this.arguments_1.push(argument);
      ++t1.argumentCount_0;
    },
    $isFunction: true
  },
  Primitives_applyFunction_closure: {
    "^": "Closure:57;box_0,defaultArguments_1",
    call$2: function(parameter, value) {
      var t1 = this.defaultArguments_1;
      if (t1.containsKey$1(parameter))
        t1.$indexSet(0, parameter, value);
      else
        this.box_0.bad_0 = true;
    },
    $isFunction: true
  },
  TypeErrorDecoder: {
    "^": "Object;_pattern,_arguments,_argumentsExpr,_expr,_method,_receiver",
    matchTypeError$1: function(message) {
      var match, result, t1;
      match = new RegExp(this._pattern).exec(message);
      if (match == null)
        return;
      result = {};
      t1 = this._arguments;
      if (t1 !== -1)
        result.arguments = match[t1 + 1];
      t1 = this._argumentsExpr;
      if (t1 !== -1)
        result.argumentsExpr = match[t1 + 1];
      t1 = this._expr;
      if (t1 !== -1)
        result.expr = match[t1 + 1];
      t1 = this._method;
      if (t1 !== -1)
        result.method = match[t1 + 1];
      t1 = this._receiver;
      if (t1 !== -1)
        result.receiver = match[t1 + 1];
      return result;
    },
    static: {"^": "TypeErrorDecoder_noSuchMethodPattern,TypeErrorDecoder_notClosurePattern,TypeErrorDecoder_nullCallPattern,TypeErrorDecoder_nullLiteralCallPattern,TypeErrorDecoder_undefinedCallPattern,TypeErrorDecoder_undefinedLiteralCallPattern,TypeErrorDecoder_nullPropertyPattern,TypeErrorDecoder_nullLiteralPropertyPattern,TypeErrorDecoder_undefinedPropertyPattern,TypeErrorDecoder_undefinedLiteralPropertyPattern", TypeErrorDecoder_extractPattern: function(message) {
        var match, $arguments, argumentsExpr, expr, method, receiver;
        message = message.replace(String({}), '$receiver$').replace(new RegExp("[[\\]{}()*+?.\\\\^$|]", 'g'), '\\$&');
        match = message.match(/\\\$[a-zA-Z]+\\\$/g);
        if (match == null)
          match = [];
        $arguments = match.indexOf("\\$arguments\\$");
        argumentsExpr = match.indexOf("\\$argumentsExpr\\$");
        expr = match.indexOf("\\$expr\\$");
        method = match.indexOf("\\$method\\$");
        receiver = match.indexOf("\\$receiver\\$");
        return new H.TypeErrorDecoder(message.replace('\\$arguments\\$', '((?:x|[^x])*)').replace('\\$argumentsExpr\\$', '((?:x|[^x])*)').replace('\\$expr\\$', '((?:x|[^x])*)').replace('\\$method\\$', '((?:x|[^x])*)').replace('\\$receiver\\$', '((?:x|[^x])*)'), $arguments, argumentsExpr, expr, method, receiver);
      }, TypeErrorDecoder_provokeCallErrorOn: function(expression) {
        return function($expr$) {
          var $argumentsExpr$ = '$arguments$';
          try {
            $expr$.$method$($argumentsExpr$);
          } catch (e) {
            return e.message;
          }

        }(expression);
      }, TypeErrorDecoder_provokePropertyErrorOn: function(expression) {
        return function($expr$) {
          try {
            $expr$.$method$;
          } catch (e) {
            return e.message;
          }

        }(expression);
      }}
  },
  NullError: {
    "^": "Error;_message,_method",
    toString$0: function(_) {
      var t1 = this._method;
      if (t1 == null)
        return "NullError: " + H.S(this._message);
      return "NullError: Cannot call \"" + H.S(t1) + "\" on null";
    },
    $isError: true
  },
  JsNoSuchMethodError: {
    "^": "Error;_message,_method,_receiver",
    toString$0: function(_) {
      var t1, t2;
      t1 = this._method;
      if (t1 == null)
        return "NoSuchMethodError: " + H.S(this._message);
      t2 = this._receiver;
      if (t2 == null)
        return "NoSuchMethodError: Cannot call \"" + H.S(t1) + "\" (" + H.S(this._message) + ")";
      return "NoSuchMethodError: Cannot call \"" + H.S(t1) + "\" on \"" + H.S(t2) + "\" (" + H.S(this._message) + ")";
    },
    $isError: true,
    static: {JsNoSuchMethodError$: function(_message, match) {
        var t1, t2;
        t1 = match == null;
        t2 = t1 ? null : match.method;
        t1 = t1 ? null : match.receiver;
        return new H.JsNoSuchMethodError(_message, t2, t1);
      }}
  },
  UnknownJsTypeError: {
    "^": "Error;_message",
    toString$0: function(_) {
      var t1 = this._message;
      return C.JSString_methods.get$isEmpty(t1) ? "Error" : "Error: " + t1;
    }
  },
  unwrapException_saveStackTrace: {
    "^": "Closure:58;ex_0",
    call$1: function(error) {
      if (!!J.getInterceptor(error).$isError)
        if (error.$thrownJsError == null)
          error.$thrownJsError = this.ex_0;
      return error;
    },
    $isFunction: true
  },
  _StackTrace: {
    "^": "Object;_exception,_trace",
    toString$0: function(_) {
      var t1, trace;
      t1 = this._trace;
      if (t1 != null)
        return t1;
      t1 = this._exception;
      trace = typeof t1 === "object" ? t1.stack : null;
      t1 = trace == null ? "" : trace;
      this._trace = t1;
      return t1;
    },
    $isStackTrace: true
  },
  invokeClosure_closure: {
    "^": "Closure:55;closure_0",
    call$0: function() {
      return this.closure_0.call$0();
    },
    $isFunction: true
  },
  invokeClosure_closure0: {
    "^": "Closure:55;closure_1,arg1_2",
    call$0: function() {
      return this.closure_1.call$1(this.arg1_2);
    },
    $isFunction: true
  },
  invokeClosure_closure1: {
    "^": "Closure:55;closure_3,arg1_4,arg2_5",
    call$0: function() {
      return this.closure_3.call$2(this.arg1_4, this.arg2_5);
    },
    $isFunction: true
  },
  invokeClosure_closure2: {
    "^": "Closure:55;closure_6,arg1_7,arg2_8,arg3_9",
    call$0: function() {
      return this.closure_6.call$3(this.arg1_7, this.arg2_8, this.arg3_9);
    },
    $isFunction: true
  },
  invokeClosure_closure3: {
    "^": "Closure:55;closure_10,arg1_11,arg2_12,arg3_13,arg4_14",
    call$0: function() {
      return this.closure_10.call$4(this.arg1_11, this.arg2_12, this.arg3_13, this.arg4_14);
    },
    $isFunction: true
  },
  Closure: {
    "^": "Object;",
    toString$0: function(_) {
      return "Closure";
    },
    $isFunction: true,
    get$$call: function() {
      return this;
    }
  },
  TearOffClosure: {
    "^": "Closure;"
  },
  BoundClosure: {
    "^": "TearOffClosure;_self,_target,_receiver,__js_helper$_name",
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!J.getInterceptor(other).$isBoundClosure)
        return false;
      return this._self === other._self && this._target === other._target && this._receiver === other._receiver;
    },
    get$hashCode: function(_) {
      var t1, receiverHashCode;
      t1 = this._receiver;
      if (t1 == null)
        receiverHashCode = H.Primitives_objectHashCode(this._self);
      else
        receiverHashCode = typeof t1 !== "object" ? J.get$hashCode$(t1) : H.Primitives_objectHashCode(t1);
      return J.$xor$n(receiverHashCode, H.Primitives_objectHashCode(this._target));
    },
    $isBoundClosure: true,
    static: {"^": "BoundClosure_selfFieldNameCache,BoundClosure_receiverFieldNameCache", BoundClosure_selfOf: function(closure) {
        return closure._self;
      }, BoundClosure_receiverOf: function(closure) {
        return closure._receiver;
      }, BoundClosure_selfFieldName: function() {
        var t1 = $.BoundClosure_selfFieldNameCache;
        if (t1 == null) {
          t1 = H.BoundClosure_computeFieldNamed("self");
          $.BoundClosure_selfFieldNameCache = t1;
        }
        return t1;
      }, BoundClosure_computeFieldNamed: function(fieldName) {
        var template, t1, names, i, $name;
        template = new H.BoundClosure("self", "target", "receiver", "name");
        t1 = Object.getOwnPropertyNames(template);
        t1.fixed$length = init;
        names = t1;
        for (t1 = names.length, i = 0; i < t1; ++i) {
          $name = names[i];
          if (template[$name] === fieldName)
            return $name;
        }
      }}
  },
  RuntimeError: {
    "^": "Error;message<",
    toString$0: function(_) {
      return "RuntimeError: " + H.S(this.message);
    },
    static: {RuntimeError$: function(message) {
        return new H.RuntimeError(message);
      }}
  },
  RuntimeType: {
    "^": "Object;"
  },
  RuntimeFunctionType: {
    "^": "RuntimeType;returnType,parameterTypes,optionalParameterTypes,namedParameters",
    _isTest$1: function(expression) {
      var functionTypeObject = this._extractFunctionTypeObjectFrom$1(expression);
      return functionTypeObject == null ? false : H.isFunctionSubtype(functionTypeObject, this.toRti$0());
    },
    _extractFunctionTypeObjectFrom$1: function(o) {
      var interceptor = J.getInterceptor(o);
      return "$signature" in interceptor ? interceptor.$signature() : null;
    },
    toRti$0: function() {
      var result, t1, t2, namedRti, keys, i, $name;
      result = {func: "dynafunc"};
      t1 = this.returnType;
      t2 = J.getInterceptor(t1);
      if (!!t2.$isVoidRuntimeType)
        result.void = true;
      else if (!t2.$isDynamicRuntimeType)
        result.ret = t1.toRti$0();
      t1 = this.parameterTypes;
      if (t1 != null && t1.length !== 0)
        result.args = H.RuntimeFunctionType_listToRti(t1);
      t1 = this.optionalParameterTypes;
      if (t1 != null && t1.length !== 0)
        result.opt = H.RuntimeFunctionType_listToRti(t1);
      t1 = this.namedParameters;
      if (t1 != null) {
        namedRti = {};
        keys = H.extractKeys(t1);
        for (t2 = keys.length, i = 0; i < t2; ++i) {
          $name = keys[i];
          namedRti[$name] = t1[$name].toRti$0();
        }
        result.named = namedRti;
      }
      return result;
    },
    toString$0: function(_) {
      var t1, t2, result, needsComma, i, type, keys, $name;
      t1 = this.parameterTypes;
      if (t1 != null)
        for (t2 = t1.length, result = "(", needsComma = false, i = 0; i < t2; ++i, needsComma = true) {
          type = t1[i];
          if (needsComma)
            result += ", ";
          result += H.S(type);
        }
      else {
        result = "(";
        needsComma = false;
      }
      t1 = this.optionalParameterTypes;
      if (t1 != null && t1.length !== 0) {
        result = (needsComma ? result + ", " : result) + "[";
        for (t2 = t1.length, needsComma = false, i = 0; i < t2; ++i, needsComma = true) {
          type = t1[i];
          if (needsComma)
            result += ", ";
          result += H.S(type);
        }
        result += "]";
      } else {
        t1 = this.namedParameters;
        if (t1 != null) {
          result = (needsComma ? result + ", " : result) + "{";
          keys = H.extractKeys(t1);
          for (t2 = keys.length, needsComma = false, i = 0; i < t2; ++i, needsComma = true) {
            $name = keys[i];
            if (needsComma)
              result += ", ";
            result += H.S(t1[$name].toRti$0()) + " " + $name;
          }
          result += "}";
        }
      }
      return result + (") -> " + H.S(this.returnType));
    },
    static: {"^": "RuntimeFunctionType_inAssert", RuntimeFunctionType_listToRti: function(list) {
        var result, t1, i;
        list = list;
        result = [];
        for (t1 = list.length, i = 0; i < t1; ++i)
          result.push(list[i].toRti$0());
        return result;
      }}
  },
  DynamicRuntimeType: {
    "^": "RuntimeType;",
    toString$0: function(_) {
      return "dynamic";
    },
    toRti$0: function() {
      return;
    },
    $isDynamicRuntimeType: true
  },
  TypeImpl: {
    "^": "Object;_typeName,_unmangledName",
    toString$0: function(_) {
      var t1, unmangledName;
      t1 = this._unmangledName;
      if (t1 != null)
        return t1;
      unmangledName = this._typeName.replace(/[^<,> ]+/g, function(m) {
        return init.mangledGlobalNames[m] || m;
      });
      this._unmangledName = unmangledName;
      return unmangledName;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this._typeName);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor(other).$isTypeImpl && J.$eq(this._typeName, other._typeName);
    },
    $isTypeImpl: true
  },
  initHooks_closure: {
    "^": "Closure:58;getTag_0",
    call$1: function(o) {
      return this.getTag_0(o);
    },
    $isFunction: true
  },
  initHooks_closure0: {
    "^": "Closure:59;getUnknownTag_1",
    call$2: function(o, tag) {
      return this.getUnknownTag_1(o, tag);
    },
    $isFunction: true
  },
  initHooks_closure1: {
    "^": "Closure:3;prototypeForTag_2",
    call$1: function(tag) {
      return this.prototypeForTag_2(tag);
    },
    $isFunction: true
  },
  JSSyntaxRegExp: {
    "^": "Object;pattern,_nativeRegExp,_nativeGlobalRegExp,_nativeAnchoredRegExp",
    get$_nativeGlobalVersion: function() {
      var t1 = this._nativeGlobalRegExp;
      if (t1 != null)
        return t1;
      t1 = this._nativeRegExp;
      t1 = H.JSSyntaxRegExp_makeNative(this.pattern, t1.multiline, !t1.ignoreCase, true);
      this._nativeGlobalRegExp = t1;
      return t1;
    },
    get$_nativeAnchoredVersion: function() {
      var t1 = this._nativeAnchoredRegExp;
      if (t1 != null)
        return t1;
      t1 = this._nativeRegExp;
      t1 = H.JSSyntaxRegExp_makeNative(this.pattern + "|()", t1.multiline, !t1.ignoreCase, true);
      this._nativeAnchoredRegExp = t1;
      return t1;
    },
    firstMatch$1: function(string) {
      var m;
      if (typeof string !== "string")
        H.throwExpression(P.ArgumentError$(string));
      m = this._nativeRegExp.exec(string);
      if (m == null)
        return;
      return H._MatchImplementation$(this, m);
    },
    allMatches$2: function(_, string, start) {
      if (start > string.length)
        throw H.wrapException(P.RangeError$range(start, 0, string.length));
      return new H._AllMatchesIterable(this, string, start);
    },
    allMatches$1: function($receiver, string) {
      return this.allMatches$2($receiver, string, 0);
    },
    _execGlobal$2: function(string, start) {
      var regexp, match;
      regexp = this.get$_nativeGlobalVersion();
      regexp.lastIndex = start;
      match = regexp.exec(string);
      if (match == null)
        return;
      return H._MatchImplementation$(this, match);
    },
    _execAnchored$2: function(string, start) {
      var regexp, match, t1, t2;
      regexp = this.get$_nativeAnchoredVersion();
      regexp.lastIndex = start;
      match = regexp.exec(string);
      if (match == null)
        return;
      t1 = match.length;
      t2 = t1 - 1;
      if (t2 < 0)
        return H.ioore(match, t2);
      if (match[t2] != null)
        return;
      C.JSArray_methods.set$length(match, t2);
      return H._MatchImplementation$(this, match);
    },
    matchAsPrefix$2: function(_, string, start) {
      if (start < 0 || start > string.length)
        throw H.wrapException(P.RangeError$range(start, 0, string.length));
      return this._execAnchored$2(string, start);
    },
    $isJSSyntaxRegExp: true,
    static: {JSSyntaxRegExp_makeNative: function(source, multiLine, caseSensitive, global) {
        var m, i, g, regexp, errorMessage;
        m = multiLine ? "m" : "";
        i = caseSensitive ? "" : "i";
        g = global ? "g" : "";
        regexp = function() {
          try {
            return new RegExp(source, m + i + g);
          } catch (e) {
            return e;
          }

        }();
        if (regexp instanceof RegExp)
          return regexp;
        errorMessage = String(regexp);
        throw H.wrapException(P.FormatException$("Illegal RegExp pattern: " + source + ", " + errorMessage, null, null));
      }}
  },
  _MatchImplementation: {
    "^": "Object;pattern,_match",
    $index: function(_, index) {
      var t1 = this._match;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    _MatchImplementation$2: function(pattern, _match) {
    },
    static: {_MatchImplementation$: function(pattern, _match) {
        var t1 = new H._MatchImplementation(pattern, _match);
        t1._MatchImplementation$2(pattern, _match);
        return t1;
      }}
  },
  _AllMatchesIterable: {
    "^": "IterableBase;_re,__js_helper$_string,__js_helper$_start",
    get$iterator: function(_) {
      return new H._AllMatchesIterator(this._re, this.__js_helper$_string, this.__js_helper$_start, null);
    },
    $asIterableBase: function() {
      return [P.Match];
    },
    $asIterable: function() {
      return [P.Match];
    }
  },
  _AllMatchesIterator: {
    "^": "Object;_regExp,__js_helper$_string,_nextIndex,__js_helper$_current",
    get$current: function() {
      return this.__js_helper$_current;
    },
    moveNext$0: function() {
      var t1, t2, match, t3, nextIndex;
      t1 = this.__js_helper$_string;
      if (t1 == null)
        return false;
      t2 = this._nextIndex;
      if (t2 <= t1.length) {
        match = this._regExp._execGlobal$2(t1, t2);
        if (match != null) {
          this.__js_helper$_current = match;
          t1 = match._match;
          t2 = t1.index;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          t3 = J.get$length$asx(t1[0]);
          if (typeof t3 !== "number")
            return H.iae(t3);
          nextIndex = t2 + t3;
          this._nextIndex = t1.index === nextIndex ? nextIndex + 1 : nextIndex;
          return true;
        }
      }
      this.__js_helper$_current = null;
      this.__js_helper$_string = null;
      return false;
    }
  },
  StringMatch: {
    "^": "Object;start,input,pattern",
    $index: function(_, g) {
      if (g !== 0)
        H.throwExpression(P.RangeError$value(g));
      return this.pattern;
    }
  }
}],
["dart._internal", "dart:_internal", , H, {
  "^": "",
  IterableElementError_noElement: function() {
    return new P.StateError("No element");
  },
  IterableElementError_tooFew: function() {
    return new P.StateError("Too few elements");
  },
  Lists_copy: function(src, srcStart, dst, dstStart, count) {
    var i, j, t1;
    if (srcStart < dstStart)
      for (i = srcStart + count - 1, j = dstStart + count - 1; i >= srcStart; --i, --j) {
        if (i >>> 0 !== i || i >= src.length)
          return H.ioore(src, i);
        C.JSArray_methods.$indexSet(dst, j, src[i]);
      }
    else
      for (t1 = srcStart + count, j = dstStart, i = srcStart; i < t1; ++i, ++j) {
        if (i >>> 0 !== i || i >= src.length)
          return H.ioore(src, i);
        C.JSArray_methods.$indexSet(dst, j, src[i]);
      }
  },
  Lists_indexOf: function(a, element, startIndex, endIndex) {
    var i;
    if (startIndex >= a.length)
      return -1;
    if (startIndex < 0)
      startIndex = 0;
    for (i = startIndex; i < endIndex; ++i) {
      if (i >>> 0 !== i || i >= a.length)
        return H.ioore(a, i);
      if (J.$eq(a[i], element))
        return i;
    }
    return -1;
  },
  Sort__doSort: function(a, left, right, compare) {
    if (right - left <= 32)
      H.Sort__insertionSort(a, left, right, compare);
    else
      H.Sort__dualPivotQuicksort(a, left, right, compare);
  },
  Sort__insertionSort: function(a, left, right, compare) {
    var i, t1, el, j, j0;
    for (i = left + 1, t1 = J.getInterceptor$asx(a); i <= right; ++i) {
      el = t1.$index(a, i);
      j = i;
      while (true) {
        if (!(j > left && J.$gt$n(compare.call$2(t1.$index(a, j - 1), el), 0)))
          break;
        j0 = j - 1;
        t1.$indexSet(a, j, t1.$index(a, j0));
        j = j0;
      }
      t1.$indexSet(a, j, el);
    }
  },
  Sort__dualPivotQuicksort: function(a, left, right, compare) {
    var sixth, index1, index5, index3, index2, index4, t1, el1, el2, el3, el4, el5, t0, less, great, k, ak, comp, t2, great0, less0, pivots_are_equal;
    sixth = C.JSInt_methods._tdivFast$1(right - left + 1, 6);
    index1 = left + sixth;
    index5 = right - sixth;
    index3 = C.JSInt_methods._tdivFast$1(left + right, 2);
    index2 = index3 - sixth;
    index4 = index3 + sixth;
    t1 = J.getInterceptor$asx(a);
    el1 = t1.$index(a, index1);
    el2 = t1.$index(a, index2);
    el3 = t1.$index(a, index3);
    el4 = t1.$index(a, index4);
    el5 = t1.$index(a, index5);
    if (J.$gt$n(compare.call$2(el1, el2), 0)) {
      t0 = el2;
      el2 = el1;
      el1 = t0;
    }
    if (J.$gt$n(compare.call$2(el4, el5), 0)) {
      t0 = el5;
      el5 = el4;
      el4 = t0;
    }
    if (J.$gt$n(compare.call$2(el1, el3), 0)) {
      t0 = el3;
      el3 = el1;
      el1 = t0;
    }
    if (J.$gt$n(compare.call$2(el2, el3), 0)) {
      t0 = el3;
      el3 = el2;
      el2 = t0;
    }
    if (J.$gt$n(compare.call$2(el1, el4), 0)) {
      t0 = el4;
      el4 = el1;
      el1 = t0;
    }
    if (J.$gt$n(compare.call$2(el3, el4), 0)) {
      t0 = el4;
      el4 = el3;
      el3 = t0;
    }
    if (J.$gt$n(compare.call$2(el2, el5), 0)) {
      t0 = el5;
      el5 = el2;
      el2 = t0;
    }
    if (J.$gt$n(compare.call$2(el2, el3), 0)) {
      t0 = el3;
      el3 = el2;
      el2 = t0;
    }
    if (J.$gt$n(compare.call$2(el4, el5), 0)) {
      t0 = el5;
      el5 = el4;
      el4 = t0;
    }
    t1.$indexSet(a, index1, el1);
    t1.$indexSet(a, index3, el3);
    t1.$indexSet(a, index5, el5);
    t1.$indexSet(a, index2, t1.$index(a, left));
    t1.$indexSet(a, index4, t1.$index(a, right));
    less = left + 1;
    great = right - 1;
    if (J.$eq(compare.call$2(el2, el4), 0)) {
      for (k = less; k <= great; ++k) {
        ak = t1.$index(a, k);
        comp = compare.call$2(ak, el2);
        t2 = J.getInterceptor(comp);
        if (t2.$eq(comp, 0))
          continue;
        if (t2.$lt(comp, 0)) {
          if (k !== less) {
            t1.$indexSet(a, k, t1.$index(a, less));
            t1.$indexSet(a, less, ak);
          }
          ++less;
        } else
          for (; true;) {
            comp = compare.call$2(t1.$index(a, great), el2);
            t2 = J.getInterceptor$n(comp);
            if (t2.$gt(comp, 0)) {
              --great;
              continue;
            } else {
              great0 = great - 1;
              if (t2.$lt(comp, 0)) {
                t1.$indexSet(a, k, t1.$index(a, less));
                less0 = less + 1;
                t1.$indexSet(a, less, t1.$index(a, great));
                t1.$indexSet(a, great, ak);
                great = great0;
                less = less0;
                break;
              } else {
                t1.$indexSet(a, k, t1.$index(a, great));
                t1.$indexSet(a, great, ak);
                great = great0;
                break;
              }
            }
          }
      }
      pivots_are_equal = true;
    } else {
      for (k = less; k <= great; ++k) {
        ak = t1.$index(a, k);
        if (J.$lt$n(compare.call$2(ak, el2), 0)) {
          if (k !== less) {
            t1.$indexSet(a, k, t1.$index(a, less));
            t1.$indexSet(a, less, ak);
          }
          ++less;
        } else if (J.$gt$n(compare.call$2(ak, el4), 0))
          for (; true;)
            if (J.$gt$n(compare.call$2(t1.$index(a, great), el4), 0)) {
              --great;
              if (great < k)
                break;
              continue;
            } else {
              great0 = great - 1;
              if (J.$lt$n(compare.call$2(t1.$index(a, great), el2), 0)) {
                t1.$indexSet(a, k, t1.$index(a, less));
                less0 = less + 1;
                t1.$indexSet(a, less, t1.$index(a, great));
                t1.$indexSet(a, great, ak);
                great = great0;
                less = less0;
              } else {
                t1.$indexSet(a, k, t1.$index(a, great));
                t1.$indexSet(a, great, ak);
                great = great0;
              }
              break;
            }
      }
      pivots_are_equal = false;
    }
    t2 = less - 1;
    t1.$indexSet(a, left, t1.$index(a, t2));
    t1.$indexSet(a, t2, el2);
    t2 = great + 1;
    t1.$indexSet(a, right, t1.$index(a, t2));
    t1.$indexSet(a, t2, el4);
    H.Sort__doSort(a, left, less - 2, compare);
    H.Sort__doSort(a, great + 2, right, compare);
    if (pivots_are_equal)
      return;
    if (less < index1 && great > index5) {
      for (; J.$eq(compare.call$2(t1.$index(a, less), el2), 0);)
        ++less;
      for (; J.$eq(compare.call$2(t1.$index(a, great), el4), 0);)
        --great;
      for (k = less; k <= great; ++k) {
        ak = t1.$index(a, k);
        if (J.$eq(compare.call$2(ak, el2), 0)) {
          if (k !== less) {
            t1.$indexSet(a, k, t1.$index(a, less));
            t1.$indexSet(a, less, ak);
          }
          ++less;
        } else if (J.$eq(compare.call$2(ak, el4), 0))
          for (; true;)
            if (J.$eq(compare.call$2(t1.$index(a, great), el4), 0)) {
              --great;
              if (great < k)
                break;
              continue;
            } else {
              great0 = great - 1;
              if (J.$lt$n(compare.call$2(t1.$index(a, great), el2), 0)) {
                t1.$indexSet(a, k, t1.$index(a, less));
                less0 = less + 1;
                t1.$indexSet(a, less, t1.$index(a, great));
                t1.$indexSet(a, great, ak);
                great = great0;
                less = less0;
              } else {
                t1.$indexSet(a, k, t1.$index(a, great));
                t1.$indexSet(a, great, ak);
                great = great0;
              }
              break;
            }
      }
      H.Sort__doSort(a, less, great, compare);
    } else
      H.Sort__doSort(a, less, great, compare);
  },
  ListIterable: {
    "^": "IterableBase;",
    get$iterator: function(_) {
      return H.setRuntimeTypeInfo(new H.ListIterator(this, this.get$length(this), 0, null), [H.getRuntimeTypeArgument(this, "ListIterable", 0)]);
    },
    forEach$1: function(_, action) {
      var $length, i;
      $length = this.get$length(this);
      for (i = 0; i < $length; ++i) {
        action.call$1(this.elementAt$1(0, i));
        if ($length !== this.get$length(this))
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
    },
    get$isEmpty: function(_) {
      return this.get$length(this) === 0;
    },
    get$first: function(_) {
      if (this.get$length(this) === 0)
        throw H.wrapException(H.IterableElementError_noElement());
      return this.elementAt$1(0, 0);
    },
    get$last: function(_) {
      if (this.get$length(this) === 0)
        throw H.wrapException(H.IterableElementError_noElement());
      return this.elementAt$1(0, this.get$length(this) - 1);
    },
    contains$1: function(_, element) {
      var $length, i;
      $length = this.get$length(this);
      for (i = 0; i < $length; ++i) {
        if (J.$eq(this.elementAt$1(0, i), element))
          return true;
        if ($length !== this.get$length(this))
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
      return false;
    },
    join$1: function(_, separator) {
      var $length, first, buffer, i, str;
      $length = this.get$length(this);
      if (separator.length !== 0) {
        if ($length === 0)
          return "";
        first = H.S(this.elementAt$1(0, 0));
        if ($length !== this.get$length(this))
          throw H.wrapException(P.ConcurrentModificationError$(this));
        buffer = P.StringBuffer$(first);
        for (i = 1; i < $length; ++i) {
          buffer._contents += separator;
          str = this.elementAt$1(0, i);
          buffer._contents += typeof str === "string" ? str : H.S(str);
          if ($length !== this.get$length(this))
            throw H.wrapException(P.ConcurrentModificationError$(this));
        }
        return buffer._contents;
      } else {
        buffer = P.StringBuffer$("");
        for (i = 0; i < $length; ++i) {
          str = this.elementAt$1(0, i);
          buffer._contents += typeof str === "string" ? str : H.S(str);
          if ($length !== this.get$length(this))
            throw H.wrapException(P.ConcurrentModificationError$(this));
        }
        return buffer._contents;
      }
    },
    join$0: function($receiver) {
      return this.join$1($receiver, "");
    },
    fold$2: function(_, initialValue, combine) {
      var $length, value, i;
      $length = this.get$length(this);
      for (value = initialValue, i = 0; i < $length; ++i) {
        value = combine.call$2(value, this.elementAt$1(0, i));
        if ($length !== this.get$length(this))
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
      return value;
    },
    skip$1: function(_, count) {
      return H.SubListIterable$(this, count, null, H.getRuntimeTypeArgument(this, "ListIterable", 0));
    },
    toList$1$growable: function(_, growable) {
      var result, t1, i;
      if (growable) {
        result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(this, "ListIterable", 0)]);
        C.JSArray_methods.set$length(result, this.get$length(this));
      } else {
        t1 = Array(this.get$length(this));
        t1.fixed$length = init;
        result = H.setRuntimeTypeInfo(t1, [H.getRuntimeTypeArgument(this, "ListIterable", 0)]);
      }
      for (i = 0; i < this.get$length(this); ++i) {
        t1 = this.elementAt$1(0, i);
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = t1;
      }
      return result;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    $isEfficientLength: true
  },
  SubListIterable: {
    "^": "ListIterable;_iterable,_start,_endOrLength",
    get$_endIndex: function() {
      var $length, t1, t2;
      $length = J.get$length$asx(this._iterable);
      t1 = this._endOrLength;
      if (t1 != null) {
        if (typeof t1 !== "number")
          return t1.$gt();
        t2 = t1 > $length;
      } else
        t2 = true;
      if (t2)
        return $length;
      return t1;
    },
    get$_startIndex: function() {
      var $length, t1;
      $length = J.get$length$asx(this._iterable);
      t1 = this._start;
      if (t1 > $length)
        return $length;
      return t1;
    },
    get$length: function(_) {
      var $length, t1, t2, t3;
      $length = J.get$length$asx(this._iterable);
      t1 = this._start;
      if (t1 >= $length)
        return 0;
      t2 = this._endOrLength;
      if (t2 != null) {
        if (typeof t2 !== "number")
          return t2.$ge();
        t3 = t2 >= $length;
      } else
        t3 = true;
      if (t3)
        return $length - t1;
      if (typeof t2 !== "number")
        return t2.$sub();
      return t2 - t1;
    },
    elementAt$1: function(_, index) {
      var realIndex, t1;
      realIndex = this.get$_startIndex() + index;
      if (!(index < 0)) {
        t1 = this.get$_endIndex();
        if (typeof t1 !== "number")
          return H.iae(t1);
        t1 = realIndex >= t1;
      } else
        t1 = true;
      if (t1)
        throw H.wrapException(P.RangeError$range(index, 0, this.get$length(this)));
      return J.elementAt$1$ax(this._iterable, realIndex);
    },
    skip$1: function(_, count) {
      var newStart, t1, t2;
      if (count < 0)
        throw H.wrapException(P.RangeError$value(count));
      newStart = this._start + count;
      t1 = this._endOrLength;
      if (t1 != null) {
        if (typeof t1 !== "number")
          return H.iae(t1);
        t2 = newStart >= t1;
      } else
        t2 = false;
      if (t2) {
        t1 = new H.EmptyIterable();
        t1.$builtinTypeInfo = this.$builtinTypeInfo;
        return t1;
      }
      return H.SubListIterable$(this._iterable, newStart, t1, H.getTypeArgumentByIndex(this, 0));
    },
    SubListIterable$3: function(_iterable, _start, _endOrLength, $E) {
      var t1, t2;
      t1 = this._start;
      if (t1 < 0)
        throw H.wrapException(P.RangeError$value(t1));
      t2 = this._endOrLength;
      if (t2 != null) {
        if (typeof t2 !== "number")
          return t2.$lt();
        if (t2 < 0)
          throw H.wrapException(P.RangeError$value(t2));
        if (t1 > t2)
          throw H.wrapException(P.RangeError$range(t1, 0, t2));
      }
    },
    static: {SubListIterable$: function(_iterable, _start, _endOrLength, $E) {
        var t1 = H.setRuntimeTypeInfo(new H.SubListIterable(_iterable, _start, _endOrLength), [$E]);
        t1.SubListIterable$3(_iterable, _start, _endOrLength, $E);
        return t1;
      }}
  },
  ListIterator: {
    "^": "Object;_iterable,_length,_index,_current",
    get$current: function() {
      return this._current;
    },
    moveNext$0: function() {
      var t1, t2, $length, t3;
      t1 = this._iterable;
      t2 = J.getInterceptor$asx(t1);
      $length = t2.get$length(t1);
      if (this._length !== $length)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      t3 = this._index;
      if (t3 >= $length) {
        this._current = null;
        return false;
      }
      this._current = t2.elementAt$1(t1, t3);
      ++this._index;
      return true;
    }
  },
  MappedIterable: {
    "^": "IterableBase;_iterable,_f",
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    },
    get$iterator: function(_) {
      var t1 = new H.MappedIterator(null, J.get$iterator$ax(this._iterable), this._f);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    get$length: function(_) {
      return J.get$length$asx(this._iterable);
    },
    get$isEmpty: function(_) {
      return J.get$isEmpty$asx(this._iterable);
    },
    get$first: function(_) {
      return this._f$1(J.get$first$ax(this._iterable));
    },
    get$last: function(_) {
      return this._f$1(J.get$last$ax(this._iterable));
    },
    $asIterableBase: function($S, $T) {
      return [$T];
    },
    $asIterable: function($S, $T) {
      return [$T];
    },
    static: {MappedIterable_MappedIterable: function(iterable, $function, $S, $T) {
        if (!!J.getInterceptor(iterable).$isEfficientLength)
          return H.setRuntimeTypeInfo(new H.EfficientLengthMappedIterable(iterable, $function), [$S, $T]);
        return H.setRuntimeTypeInfo(new H.MappedIterable(iterable, $function), [$S, $T]);
      }}
  },
  EfficientLengthMappedIterable: {
    "^": "MappedIterable;_iterable,_f",
    $isEfficientLength: true
  },
  MappedIterator: {
    "^": "Iterator;_current,_iterator,_f",
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    },
    moveNext$0: function() {
      var t1 = this._iterator;
      if (t1.moveNext$0()) {
        this._current = this._f$1(t1.get$current());
        return true;
      }
      this._current = null;
      return false;
    },
    get$current: function() {
      return this._current;
    },
    $asIterator: function($S, $T) {
      return [$T];
    }
  },
  MappedListIterable: {
    "^": "ListIterable;_source,_f",
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    },
    get$length: function(_) {
      return J.get$length$asx(this._source);
    },
    elementAt$1: function(_, index) {
      return this._f$1(J.elementAt$1$ax(this._source, index));
    },
    $asListIterable: function($S, $T) {
      return [$T];
    },
    $asIterableBase: function($S, $T) {
      return [$T];
    },
    $asIterable: function($S, $T) {
      return [$T];
    },
    $isEfficientLength: true
  },
  WhereIterable: {
    "^": "IterableBase;_iterable,_f",
    get$iterator: function(_) {
      var t1 = new H.WhereIterator(J.get$iterator$ax(this._iterable), this._f);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    }
  },
  WhereIterator: {
    "^": "Iterator;_iterator,_f",
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    },
    moveNext$0: function() {
      for (var t1 = this._iterator; t1.moveNext$0();)
        if (this._f$1(t1.get$current()) === true)
          return true;
      return false;
    },
    get$current: function() {
      return this._iterator.get$current();
    }
  },
  ExpandIterable: {
    "^": "IterableBase;_iterable,_f",
    get$iterator: function(_) {
      var t1 = new H.ExpandIterator(J.get$iterator$ax(this._iterable), this._f, C.C_EmptyIterator, null);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    $asIterableBase: function($S, $T) {
      return [$T];
    },
    $asIterable: function($S, $T) {
      return [$T];
    }
  },
  ExpandIterator: {
    "^": "Object;_iterator,_f,_currentExpansion,_current",
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    },
    get$current: function() {
      return this._current;
    },
    moveNext$0: function() {
      var t1, t2;
      t1 = this._currentExpansion;
      if (t1 == null)
        return false;
      for (t2 = this._iterator; !t1.moveNext$0();) {
        this._current = null;
        if (t2.moveNext$0()) {
          this._currentExpansion = null;
          t1 = J.get$iterator$ax(this._f$1(t2.get$current()));
          this._currentExpansion = t1;
        } else
          return false;
      }
      this._current = this._currentExpansion.get$current();
      return true;
    }
  },
  TakeWhileIterable: {
    "^": "IterableBase;_iterable,_f",
    get$iterator: function(_) {
      var t1 = new H.TakeWhileIterator(J.get$iterator$ax(this._iterable), this._f, false);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    }
  },
  TakeWhileIterator: {
    "^": "Iterator;_iterator,_f,_isFinished",
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    },
    moveNext$0: function() {
      if (this._isFinished)
        return false;
      var t1 = this._iterator;
      if (!t1.moveNext$0() || this._f$1(t1.get$current()) !== true) {
        this._isFinished = true;
        return false;
      }
      return true;
    },
    get$current: function() {
      if (this._isFinished)
        return;
      return this._iterator.get$current();
    }
  },
  SkipIterable: {
    "^": "IterableBase;_iterable,_skipCount",
    skip$1: function(_, n) {
      if (typeof n !== "number" || Math.floor(n) !== n || n < 0)
        throw H.wrapException(P.RangeError$value(n));
      return H.SkipIterable_SkipIterable(this._iterable, this._skipCount + n, H.getTypeArgumentByIndex(this, 0));
    },
    get$iterator: function(_) {
      var t1 = this._iterable;
      t1 = new H.SkipIterator(t1.get$iterator(t1), this._skipCount);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    SkipIterable$_$2: function(_iterable, _skipCount, $E) {
      var t1 = this._skipCount;
      if (typeof t1 !== "number" || Math.floor(t1) !== t1 || t1 < 0)
        throw H.wrapException(P.RangeError$(t1));
    },
    static: {SkipIterable_SkipIterable: function(iterable, skipCount, $E) {
        var t1;
        if (!!iterable.$isEfficientLength) {
          t1 = H.setRuntimeTypeInfo(new H.EfficientLengthSkipIterable(iterable, skipCount), [$E]);
          t1.SkipIterable$_$2(iterable, skipCount, $E);
          return t1;
        }
        return H.SkipIterable$_(iterable, skipCount, $E);
      }, SkipIterable$_: function(_iterable, _skipCount, $E) {
        var t1 = H.setRuntimeTypeInfo(new H.SkipIterable(_iterable, _skipCount), [$E]);
        t1.SkipIterable$_$2(_iterable, _skipCount, $E);
        return t1;
      }}
  },
  EfficientLengthSkipIterable: {
    "^": "SkipIterable;_iterable,_skipCount",
    get$length: function(_) {
      var t1, $length;
      t1 = this._iterable;
      $length = t1.get$length(t1) - this._skipCount;
      if ($length >= 0)
        return $length;
      return 0;
    },
    $isEfficientLength: true
  },
  SkipIterator: {
    "^": "Iterator;_iterator,_skipCount",
    moveNext$0: function() {
      var t1, i;
      for (t1 = this._iterator, i = 0; i < this._skipCount; ++i)
        t1.moveNext$0();
      this._skipCount = 0;
      return t1.moveNext$0();
    },
    get$current: function() {
      return this._iterator.get$current();
    }
  },
  SkipWhileIterable: {
    "^": "IterableBase;_iterable,_f",
    get$iterator: function(_) {
      var t1 = new H.SkipWhileIterator(J.get$iterator$ax(this._iterable), this._f, false);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    }
  },
  SkipWhileIterator: {
    "^": "Iterator;_iterator,_f,_hasSkipped",
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    },
    moveNext$0: function() {
      if (!this._hasSkipped) {
        this._hasSkipped = true;
        for (var t1 = this._iterator; t1.moveNext$0();)
          if (this._f$1(t1.get$current()) !== true)
            return true;
      }
      return this._iterator.moveNext$0();
    },
    get$current: function() {
      return this._iterator.get$current();
    }
  },
  EmptyIterable: {
    "^": "IterableBase;",
    get$iterator: function(_) {
      return C.C_EmptyIterator;
    },
    forEach$1: function(_, action) {
    },
    get$isEmpty: function(_) {
      return true;
    },
    get$length: function(_) {
      return 0;
    },
    get$first: function(_) {
      throw H.wrapException(H.IterableElementError_noElement());
    },
    get$last: function(_) {
      throw H.wrapException(H.IterableElementError_noElement());
    },
    contains$1: function(_, element) {
      return false;
    },
    skip$1: function(_, count) {
      if (count < 0)
        throw H.wrapException(P.RangeError$value(count));
      return this;
    },
    toList$1$growable: function(_, growable) {
      var t1;
      if (growable)
        t1 = H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(this, 0)]);
      else {
        t1 = Array(0);
        t1.fixed$length = init;
        t1 = H.setRuntimeTypeInfo(t1, [H.getTypeArgumentByIndex(this, 0)]);
      }
      return t1;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    $isEfficientLength: true
  },
  EmptyIterator: {
    "^": "Object;",
    moveNext$0: function() {
      return false;
    },
    get$current: function() {
      return;
    }
  },
  IterableMixinWorkaround: {
    "^": "Object;",
    static: {IterableMixinWorkaround_forEach: function(iterable, f) {
        var t1;
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(iterable, iterable.length, 0, null), [H.getTypeArgumentByIndex(iterable, 0)]); t1.moveNext$0();)
          f.call$1(t1._current);
      }, IterableMixinWorkaround_fold: function(iterable, initialValue, combine) {
        var t1;
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(iterable, iterable.length, 0, null), [H.getTypeArgumentByIndex(iterable, 0)]); t1.moveNext$0();)
          initialValue = combine.call$2(initialValue, t1._current);
        return initialValue;
      }, IterableMixinWorkaround_removeWhereList: function(list, test) {
        var retained, $length, t1, i, element;
        retained = [];
        $length = list.length;
        for (t1 = $length, i = 0; i < $length; ++i) {
          if (i >= t1)
            return H.ioore(list, i);
          element = list[i];
          if (test.call$1(element) !== true)
            retained.push(element);
          t1 = list.length;
          if ($length !== t1)
            throw H.wrapException(P.ConcurrentModificationError$(list));
        }
        t1 = retained.length;
        if (t1 === $length)
          return;
        C.JSArray_methods.set$length(list, t1);
        for (i = 0; i < retained.length; ++i)
          C.JSArray_methods.$indexSet(list, i, retained[i]);
      }, IterableMixinWorkaround__rangeCheck: function(list, start, end) {
        if (start < 0 || start > list.length)
          throw H.wrapException(P.RangeError$range(start, 0, list.length));
        if (end < start || end > list.length)
          throw H.wrapException(P.RangeError$range(end, start, list.length));
      }, IterableMixinWorkaround_setRangeList: function(list, start, end, from, skipCount) {
        var $length;
        H.IterableMixinWorkaround__rangeCheck(list, start, end);
        $length = end - start;
        if ($length === 0)
          return;
        if (skipCount < 0)
          throw H.wrapException(P.ArgumentError$(skipCount));
        if (skipCount + $length > from.length)
          throw H.wrapException(H.IterableElementError_tooFew());
        H.Lists_copy(from, skipCount, list, start, $length);
      }, IterableMixinWorkaround_insertAllList: function(list, index, iterable) {
        var insertionLength, t1, index0;
        if (index > list.length)
          throw H.wrapException(P.RangeError$range(index, 0, list.length));
        insertionLength = iterable.length;
        C.JSArray_methods.set$length(list, list.length + insertionLength);
        t1 = list.length;
        if (!!list.immutable$list)
          H.throwExpression(P.UnsupportedError$("set range"));
        H.IterableMixinWorkaround_setRangeList(list, index + insertionLength, t1, list, index);
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(iterable, iterable.length, 0, null), [H.getTypeArgumentByIndex(iterable, 0)]); t1.moveNext$0(); index = index0) {
          index0 = index + 1;
          C.JSArray_methods.$indexSet(list, index, t1._current);
        }
      }}
  },
  FixedLengthListMixin: {
    "^": "Object;",
    set$length: function(receiver, newLength) {
      throw H.wrapException(P.UnsupportedError$("Cannot change the length of a fixed-length list"));
    },
    add$1: [function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot add to a fixed-length list"));
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "void__E0", void: true, args: [E]};
      }, this.$receiver, "FixedLengthListMixin");
    }],
    removeRange$2: function(receiver, start, end) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from a fixed-length list"));
    }
  },
  UnmodifiableListMixin: {
    "^": "Object;",
    $indexSet: function(_, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable list"));
    },
    set$length: function(_, newLength) {
      throw H.wrapException(P.UnsupportedError$("Cannot change the length of an unmodifiable list"));
    },
    add$1: [function(_, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot add to an unmodifiable list"));
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "void__E1", void: true, args: [E]};
      }, this.$receiver, "UnmodifiableListMixin");
    }],
    setRange$4: function(_, start, end, iterable, skipCount) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable list"));
    },
    removeRange$2: function(_, start, end) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from an unmodifiable list"));
    },
    $isList: true,
    $asList: null,
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: null
  },
  UnmodifiableListBase: {
    "^": "ListBase+UnmodifiableListMixin;",
    $isList: true,
    $asList: null,
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: null
  },
  ReversedListIterable: {
    "^": "ListIterable;_source",
    get$length: function(_) {
      return J.get$length$asx(this._source);
    },
    elementAt$1: function(_, index) {
      var t1, t2;
      t1 = this._source;
      t2 = J.getInterceptor$asx(t1);
      return t2.elementAt$1(t1, t2.get$length(t1) - 1 - index);
    }
  },
  Symbol: {
    "^": "Object;_name<",
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor(other).$isSymbol && J.$eq(this._name, other._name);
    },
    get$hashCode: function(_) {
      var t1 = J.get$hashCode$(this._name);
      if (typeof t1 !== "number")
        return H.iae(t1);
      return 536870911 & 664597 * t1;
    },
    toString$0: function(_) {
      return "Symbol(\"" + H.S(this._name) + "\")";
    },
    $isSymbol: true,
    static: {"^": "Symbol_reservedWordRE,Symbol_publicIdentifierRE,Symbol_identifierRE,Symbol_operatorRE,Symbol_publicSymbolPattern,Symbol_symbolPattern"}
  }
}],
["dart._js_names", "dart:_js_names", , H, {
  "^": "",
  extractKeys: function(victim) {
    var t1 = H.setRuntimeTypeInfo(function(victim, hasOwnProperty) {
      var result = [];
      for (var key in victim) {
        if (hasOwnProperty.call(victim, key))
          result.push(key);
      }
      return result;
    }(victim, Object.prototype.hasOwnProperty), [null]);
    t1.fixed$length = init;
    return t1;
  }
}],
["dart.async", "dart:async", , P, {
  "^": "",
  _AsyncRun__initializeScheduleImmediate: function() {
    var t1, div, span;
    t1 = {};
    if (self.scheduleImmediate != null)
      return P._AsyncRun__scheduleImmediateJsOverride$closure();
    if (self.MutationObserver != null && self.document != null) {
      div = self.document.createElement("div");
      span = self.document.createElement("span");
      t1.storedCallback_0 = null;
      new self.MutationObserver(H.convertDartClosureToJS(new P._AsyncRun__initializeScheduleImmediate_internalCallback(t1), 1)).observe(div, {childList: true});
      return new P._AsyncRun__initializeScheduleImmediate_closure(t1, div, span);
    }
    return P._AsyncRun__scheduleImmediateWithTimer$closure();
  },
  _AsyncRun__scheduleImmediateJsOverride: [function(callback) {
    ++init.globalState.topEventLoop._activeJsAsyncCount;
    self.scheduleImmediate(H.convertDartClosureToJS(new P._AsyncRun__scheduleImmediateJsOverride_internalCallback(callback), 0));
  }, "call$1", "_AsyncRun__scheduleImmediateJsOverride$closure", 2, 0, 11],
  _AsyncRun__scheduleImmediateWithTimer: [function(callback) {
    P.Timer__createTimer(C.Duration_0, callback);
  }, "call$1", "_AsyncRun__scheduleImmediateWithTimer$closure", 2, 0, 11],
  _invokeErrorHandler: function(errorHandler, error, stackTrace) {
    var t1 = H.getDynamicRuntimeType();
    t1 = H.buildFunctionType(t1, [t1, t1])._isTest$1(errorHandler);
    if (t1)
      return errorHandler.call$2(error, stackTrace);
    else
      return errorHandler.call$1(error);
  },
  _registerErrorHandler: function(errorHandler, zone) {
    var t1 = H.getDynamicRuntimeType();
    t1 = H.buildFunctionType(t1, [t1, t1])._isTest$1(errorHandler);
    if (t1)
      return zone.registerBinaryCallback$1(errorHandler);
    else
      return zone.registerUnaryCallback$1(errorHandler);
  },
  Future_Future$sync: function(computation, $T) {
    var result, T0, error, stackTrace, t1, exception;
    try {
      result = computation.call$0();
      t1 = P._Future$immediate(result, T0);
      return t1;
    } catch (exception) {
      t1 = H.unwrapException(exception);
      error = t1;
      stackTrace = new H._StackTrace(exception, null);
      return P._Future$immediateError(error, stackTrace, T0);
    }

  },
  Future_wait: function(futures, eagerError) {
    var t1, t2, t3, values, completer;
    t1 = {};
    t1.completer_0 = null;
    t1.values_1 = null;
    t1.remaining_2 = 0;
    t1.error_3 = null;
    t1.stackTrace_4 = null;
    t2 = new P.Future_wait_handleError(t1, eagerError);
    for (t3 = H.setRuntimeTypeInfo(new H.ListIterator(futures, 2, 0, null), [H.getTypeArgumentByIndex(futures, 0)]); t3.moveNext$0();)
      t3._current.then$2$onError(new P.Future_wait_closure(t1, eagerError, t1.remaining_2++), t2);
    t2 = t1.remaining_2;
    if (t2 === 0)
      return P._Future$immediate(C.List_empty, null);
    values = Array(t2);
    values.fixed$length = init;
    t1.values_1 = values;
    t2 = P.List;
    completer = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(t2)), [t2]);
    t1.completer_0 = completer;
    return completer.future;
  },
  _asyncRunCallbackLoop: function() {
    var t1, t2;
    for (; t1 = $._nextCallback, t1 != null;) {
      $._lastPriorityCallback = null;
      t2 = t1.get$next();
      $._nextCallback = t2;
      if (t2 == null)
        $._lastCallback = null;
      t1.callback$0();
    }
  },
  _asyncRunCallback: [function() {
    $._isInCallbackLoop = true;
    try {
      P._asyncRunCallbackLoop();
    } finally {
      $._lastPriorityCallback = null;
      $._isInCallbackLoop = false;
      if ($._nextCallback != null)
        $.get$_AsyncRun_scheduleImmediateClosure().call$1(P._asyncRunCallback$closure());
    }
  }, "call$0", "_asyncRunCallback$closure", 0, 0, 12],
  scheduleMicrotask: function(callback) {
    var t1 = $.Zone__current;
    if (C.C__RootZone === t1) {
      P._rootScheduleMicrotask(null, null, C.C__RootZone, callback);
      return;
    }
    t1.scheduleMicrotask$1(t1.bindCallback$2$runGuarded(callback, true));
  },
  Stream_Stream$fromIterable: function(data, $T) {
    return H.setRuntimeTypeInfo(new P._GeneratedStreamImpl(new P.Stream_Stream$fromIterable_closure($T, data), false), [$T]);
  },
  StreamController_StreamController: function(onCancel, onListen, onPause, onResume, sync, $T) {
    if (onListen == null && onPause == null && onResume == null && onCancel == null)
      return sync ? new P._NoCallbackSyncStreamController(null, 0, null) : new P._NoCallbackAsyncStreamController(null, 0, null);
    return sync ? H.setRuntimeTypeInfo(new P._SyncStreamController(onListen, onPause, onResume, onCancel, null, 0, null), [$T]) : H.setRuntimeTypeInfo(new P._AsyncStreamController(onListen, onPause, onResume, onCancel, null, 0, null), [$T]);
  },
  _runGuarded: function(notificationHandler) {
    var result, e, s, exception, t1;
    if (notificationHandler == null)
      return;
    try {
      result = notificationHandler.call$0();
      if (!!J.getInterceptor(result).$isFuture)
        return result;
      return;
    } catch (exception) {
      t1 = H.unwrapException(exception);
      e = t1;
      s = new H._StackTrace(exception, null);
      $.Zone__current.handleUncaughtError$2(e, s);
    }

  },
  _AddStreamState_makeErrorHandler: function(controller) {
    return new P._AddStreamState_makeErrorHandler_closure(controller);
  },
  _nullDataHandler: [function(value) {
  }, "call$1", "_nullDataHandler$closure", 2, 0, 13, 14],
  _nullErrorHandler: [function(error, stackTrace) {
    $.Zone__current.handleUncaughtError$2(error, stackTrace);
  }, function(error) {
    return P._nullErrorHandler(error, null);
  }, null, "call$2", "call$1", "_nullErrorHandler$closure", 2, 2, 15, 16, 17, 18],
  _nullDoneHandler: [function() {
  }, "call$0", "_nullDoneHandler$closure", 0, 0, 12],
  _runUserCode: function(userCode, onSuccess, onError) {
    var e, s, exception, t1;
    try {
      onSuccess.call$1(userCode.call$0());
    } catch (exception) {
      t1 = H.unwrapException(exception);
      e = t1;
      s = new H._StackTrace(exception, null);
      onError.call$2(e, s);
    }

  },
  _cancelAndError: function(subscription, future, error, stackTrace) {
    var cancelFuture = subscription.cancel$0();
    if (!!J.getInterceptor(cancelFuture).$isFuture)
      cancelFuture.whenComplete$1(new P._cancelAndError_closure(future, error, stackTrace));
    else
      future._completeError$2(error, stackTrace);
  },
  _cancelAndErrorClosure: function(subscription, future) {
    return new P._cancelAndErrorClosure_closure(subscription, future);
  },
  _cancelAndValue: function(subscription, future, value) {
    var cancelFuture = subscription.cancel$0();
    if (!!J.getInterceptor(cancelFuture).$isFuture)
      cancelFuture.whenComplete$1(new P._cancelAndValue_closure(future, value));
    else
      future._complete$1(value);
  },
  Timer_Timer: function(duration, callback) {
    var t1;
    if (J.$eq($.Zone__current, C.C__RootZone))
      return $.Zone__current.createTimer$2(duration, callback);
    t1 = $.Zone__current;
    return t1.createTimer$2(duration, t1.bindCallback$2$runGuarded(callback, true));
  },
  Timer_Timer$periodic: function(duration, callback) {
    var t1;
    if (J.$eq($.Zone__current, C.C__RootZone))
      return $.Zone__current.createPeriodicTimer$2(duration, callback);
    t1 = $.Zone__current;
    return t1.createPeriodicTimer$2(duration, t1.bindUnaryCallback$2$runGuarded(callback, true));
  },
  Timer__createTimer: function(duration, callback) {
    var milliseconds = duration.get$inMilliseconds();
    return H.TimerImpl$(milliseconds < 0 ? 0 : milliseconds, callback);
  },
  Timer__createPeriodicTimer: function(duration, callback) {
    var milliseconds = duration.get$inMilliseconds();
    return H.TimerImpl$periodic(milliseconds < 0 ? 0 : milliseconds, callback);
  },
  Zone__enter: function(zone) {
    var previous = $.Zone__current;
    $.Zone__current = zone;
    return previous;
  },
  _parentDelegate: function(zone) {
    if (zone.get$parent() == null)
      return;
    return zone.get$parent().get$_delegate();
  },
  _rootHandleUncaughtError: [function($self, $parent, zone, error, stackTrace) {
    var entry, t1, t2;
    entry = new P._AsyncCallbackEntry(new P._rootHandleUncaughtError_closure(error, stackTrace), null);
    t1 = $._nextCallback;
    if (t1 == null) {
      $._lastPriorityCallback = entry;
      $._lastCallback = entry;
      $._nextCallback = entry;
      if (!$._isInCallbackLoop)
        $.get$_AsyncRun_scheduleImmediateClosure().call$1(P._asyncRunCallback$closure());
    } else {
      t2 = $._lastPriorityCallback;
      if (t2 == null) {
        entry.next = t1;
        $._lastPriorityCallback = entry;
        $._nextCallback = entry;
      } else {
        entry.next = t2.next;
        t2.next = entry;
        $._lastPriorityCallback = entry;
        if (entry.next == null)
          $._lastCallback = entry;
      }
    }
  }, "call$5", "_rootHandleUncaughtError$closure", 10, 0, 19, 20, 21, 22, 17, 18],
  _rootRun: [function($self, $parent, zone, f) {
    var old, t1;
    if (J.$eq($.Zone__current, zone))
      return f.call$0();
    old = P.Zone__enter(zone);
    try {
      t1 = f.call$0();
      return t1;
    } finally {
      $.Zone__current = old;
    }
  }, "call$4", "_rootRun$closure", 8, 0, 23, 20, 21, 22, 24],
  _rootRunUnary: [function($self, $parent, zone, f, arg) {
    var old, t1;
    if (J.$eq($.Zone__current, zone))
      return f.call$1(arg);
    old = P.Zone__enter(zone);
    try {
      t1 = f.call$1(arg);
      return t1;
    } finally {
      $.Zone__current = old;
    }
  }, "call$5", "_rootRunUnary$closure", 10, 0, 25, 20, 21, 22, 24, 26],
  _rootRunBinary: [function($self, $parent, zone, f, arg1, arg2) {
    var old, t1;
    if (J.$eq($.Zone__current, zone))
      return f.call$2(arg1, arg2);
    old = P.Zone__enter(zone);
    try {
      t1 = f.call$2(arg1, arg2);
      return t1;
    } finally {
      $.Zone__current = old;
    }
  }, "call$6", "_rootRunBinary$closure", 12, 0, 27, 20, 21, 22, 24, 7, 8],
  _rootRegisterCallback: [function($self, $parent, zone, f) {
    return f;
  }, "call$4", "_rootRegisterCallback$closure", 8, 0, 28, 20, 21, 22, 24],
  _rootRegisterUnaryCallback: [function($self, $parent, zone, f) {
    return f;
  }, "call$4", "_rootRegisterUnaryCallback$closure", 8, 0, 29, 20, 21, 22, 24],
  _rootRegisterBinaryCallback: [function($self, $parent, zone, f) {
    return f;
  }, "call$4", "_rootRegisterBinaryCallback$closure", 8, 0, 30, 20, 21, 22, 24],
  _rootScheduleMicrotask: [function($self, $parent, zone, f) {
    var t1, newEntry;
    if (C.C__RootZone !== zone)
      f = zone.bindCallback$1(f);
    if ($._nextCallback == null) {
      t1 = new P._AsyncCallbackEntry(f, null);
      $._lastCallback = t1;
      $._nextCallback = t1;
      if (!$._isInCallbackLoop)
        $.get$_AsyncRun_scheduleImmediateClosure().call$1(P._asyncRunCallback$closure());
    } else {
      newEntry = new P._AsyncCallbackEntry(f, null);
      $._lastCallback.next = newEntry;
      $._lastCallback = newEntry;
    }
  }, "call$4", "_rootScheduleMicrotask$closure", 8, 0, 31, 20, 21, 22, 24],
  _rootCreateTimer: [function($self, $parent, zone, duration, callback) {
    return P.Timer__createTimer(duration, C.C__RootZone !== zone ? zone.bindCallback$1(callback) : callback);
  }, "call$5", "_rootCreateTimer$closure", 10, 0, 32, 20, 21, 22, 33, 34],
  _rootCreatePeriodicTimer: [function($self, $parent, zone, duration, callback) {
    return P.Timer__createPeriodicTimer(duration, C.C__RootZone !== zone ? zone.bindUnaryCallback$1(callback) : callback);
  }, "call$5", "_rootCreatePeriodicTimer$closure", 10, 0, 35, 20, 21, 22, 33, 34],
  _rootPrint: [function($self, $parent, zone, line) {
    H.printString(H.S(line));
  }, "call$4", "_rootPrint$closure", 8, 0, 36, 20, 21, 22, 37],
  _printToZone: [function(line) {
    $.Zone__current.print$1(line);
  }, "call$1", "_printToZone$closure", 2, 0, 38],
  _rootFork: [function($self, $parent, zone, specification, zoneValues) {
    var valueMap, t1;
    $.printToZone = P._printToZone$closure();
    if (specification == null)
      specification = C._ZoneSpecification_woc;
    else if (!J.getInterceptor(specification).$is_ZoneSpecification)
      throw H.wrapException(P.ArgumentError$("ZoneSpecifications must be instantiated with the provided constructor."));
    if (zoneValues == null)
      valueMap = !!J.getInterceptor(zone).$is_Zone ? zone.get$_async$_map() : P.HashMap_HashMap(null, null, null, null, null);
    else {
      valueMap = P.HashMap_HashMap(null, null, null, null, null);
      valueMap.addAll$1(0, zoneValues);
    }
    t1 = new P._CustomZone(null, null, null, null, null, null, null, null, null, null, null, null, null, zone, valueMap);
    t1._CustomZone$3(zone, specification, valueMap);
    return t1;
  }, "call$5", "_rootFork$closure", 10, 0, 39, 20, 21, 22, 40, 41],
  runZoned: function(body, onError, zoneSpecification, zoneValues) {
    var errorHandler, zone;
    errorHandler = new P.runZoned_closure(onError);
    zoneSpecification = new P._ZoneSpecification(errorHandler, null, null, null, null, null, null, null, null, null, null, null);
    zone = $.Zone__current.fork$2$specification$zoneValues(zoneSpecification, zoneValues);
    return zone.runGuarded$1(body);
  },
  _AsyncRun__initializeScheduleImmediate_internalCallback: {
    "^": "Closure:58;box_0",
    call$1: [function(_) {
      var t1, f;
      H.leaveJsAsync();
      t1 = this.box_0;
      f = t1.storedCallback_0;
      t1.storedCallback_0 = null;
      f.call$0();
    }, "call$1", null, 2, 0, null, 60, "call"],
    $isFunction: true
  },
  _AsyncRun__initializeScheduleImmediate_closure: {
    "^": "Closure:61;box_0,div_1,span_2",
    call$1: function(callback) {
      var t1, t2;
      ++init.globalState.topEventLoop._activeJsAsyncCount;
      this.box_0.storedCallback_0 = callback;
      t1 = this.div_1;
      t2 = this.span_2;
      t1.firstChild ? t1.removeChild(t2) : t1.appendChild(t2);
    },
    $isFunction: true
  },
  _AsyncRun__scheduleImmediateJsOverride_internalCallback: {
    "^": "Closure:55;callback_0",
    call$0: [function() {
      H.leaveJsAsync();
      this.callback_0.call$0();
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _AsyncError: {
    "^": "Object;error<,stackTrace<",
    $isError: true
  },
  _UncaughtAsyncError: {
    "^": "_AsyncError;error,stackTrace",
    toString$0: function(_) {
      var result, t1;
      result = "Uncaught Error: " + H.S(this.error);
      t1 = this.stackTrace;
      return t1 != null ? result + ("\nStack Trace:\n" + H.S(t1)) : result;
    },
    static: {_UncaughtAsyncError$: function(error, stackTrace) {
        return new P._UncaughtAsyncError(error, P._UncaughtAsyncError__getBestStackTrace(error, stackTrace));
      }, _UncaughtAsyncError__getBestStackTrace: function(error, stackTrace) {
        if (stackTrace != null)
          return stackTrace;
        if (!!J.getInterceptor(error).$isError)
          return error.get$stackTrace();
        return;
      }}
  },
  Future: {
    "^": "Object;",
    $isFuture: true
  },
  Future_wait_handleError: {
    "^": "Closure:56;box_0,eagerError_1",
    call$2: [function(theError, theStackTrace) {
      var t1, t2, t3;
      t1 = this.box_0;
      t2 = t1.values_1;
      t1.values_1 = null;
      t3 = --t1.remaining_2;
      if (t2 != null)
        if (t3 === 0 || this.eagerError_1)
          t1.completer_0.completeError$2(theError, theStackTrace);
        else {
          t1.error_3 = theError;
          t1.stackTrace_4 = theStackTrace;
        }
      else if (t3 === 0 && !this.eagerError_1)
        t1.completer_0.completeError$2(t1.error_3, t1.stackTrace_4);
    }, "call$2", null, 4, 0, null, 62, 63, "call"],
    $isFunction: true
  },
  Future_wait_closure: {
    "^": "Closure:64;box_0,eagerError_2,pos_3",
    call$1: [function(value) {
      var t1, t2, t3, t4;
      t1 = this.box_0;
      t2 = --t1.remaining_2;
      t3 = t1.values_1;
      if (t3 != null) {
        t4 = this.pos_3;
        if (t4 < 0 || t4 >= t3.length)
          return H.ioore(t3, t4);
        t3[t4] = value;
        if (t2 === 0) {
          t1 = t1.completer_0.future;
          if (t1._state !== 0)
            H.throwExpression(P.StateError$("Future already completed"));
          t1._asyncComplete$1(t3);
        }
      } else if (t2 === 0 && !this.eagerError_2)
        t1.completer_0.completeError$2(t1.error_3, t1.stackTrace_4);
    }, "call$1", null, 2, 0, null, 14, "call"],
    $isFunction: true
  },
  _Completer: {
    "^": "Object;"
  },
  _AsyncCompleter: {
    "^": "_Completer;future",
    complete$1: [function(value) {
      var t1 = this.future;
      if (t1._state !== 0)
        throw H.wrapException(P.StateError$("Future already completed"));
      t1._asyncComplete$1(value);
    }, function() {
      return this.complete$1(null);
    }, "complete$0", "call$1", "call$0", "get$complete", 0, 2, 65, 16, 14],
    completeError$2: [function(error, stackTrace) {
      var t1;
      if (error == null)
        throw H.wrapException(P.ArgumentError$("Error must not be null"));
      t1 = this.future;
      if (t1._state !== 0)
        throw H.wrapException(P.StateError$("Future already completed"));
      t1._asyncCompleteError$2(error, stackTrace);
    }, function(error) {
      return this.completeError$2(error, null);
    }, "completeError$1", "call$2", "call$1", "get$completeError", 2, 2, 66, 16, 17, 18]
  },
  _Future: {
    "^": "Object;_state,_zone<,_resultOrListeners,_nextListener@,_onValueCallback?,_errorTestCallback?,_onErrorCallback?,_whenCompleteActionCallback?",
    get$_isComplete: function() {
      return this._state >= 4;
    },
    get$_hasValue: function() {
      return this._state === 4;
    },
    get$_hasError: function() {
      return this._state === 8;
    },
    set$_isChained: function(value) {
      if (value)
        this._state = 2;
      else
        this._state = 0;
    },
    get$_onValue: function() {
      return this._state === 2 ? null : this._onValueCallback;
    },
    get$_errorTest: function() {
      return this._state === 2 ? null : this._errorTestCallback;
    },
    get$_onError: function() {
      return this._state === 2 ? null : this._onErrorCallback;
    },
    get$_whenCompleteAction: function() {
      return this._state === 2 ? null : this._whenCompleteActionCallback;
    },
    then$2$onError: function(f, onError) {
      var t1, result;
      t1 = $.Zone__current;
      result = H.setRuntimeTypeInfo(new P._Future(0, t1, null, null, t1.registerUnaryCallback$1(f), null, P._registerErrorHandler(onError, $.Zone__current), null), [null]);
      this._addListener$1(result);
      return result;
    },
    then$1: function(f) {
      return this.then$2$onError(f, null);
    },
    catchError$2$test: function(onError, test) {
      var t1, t2, result;
      t1 = $.Zone__current;
      t2 = P._registerErrorHandler(onError, t1);
      result = H.setRuntimeTypeInfo(new P._Future(0, t1, null, null, null, $.Zone__current.registerUnaryCallback$1(test), t2, null), [null]);
      this._addListener$1(result);
      return result;
    },
    catchError$1: function(onError) {
      return this.catchError$2$test(onError, null);
    },
    whenComplete$1: function(action) {
      var t1, result;
      t1 = $.Zone__current;
      result = new P._Future(0, t1, null, null, null, null, null, t1.registerCallback$1(action));
      result.$builtinTypeInfo = this.$builtinTypeInfo;
      this._addListener$1(result);
      return result;
    },
    get$_value: function() {
      return this._resultOrListeners;
    },
    get$_error: function() {
      return this._resultOrListeners;
    },
    _setValue$1: function(value) {
      this._state = 4;
      this._resultOrListeners = value;
    },
    _setError$2: function(error, stackTrace) {
      this._state = 8;
      this._resultOrListeners = new P._AsyncError(error, stackTrace);
    },
    _addListener$1: function(listener) {
      if (this._state >= 4)
        this._zone.scheduleMicrotask$1(new P._Future__addListener_closure(this, listener));
      else {
        listener.set$_nextListener(this._resultOrListeners);
        this._resultOrListeners = listener;
      }
    },
    _removeListeners$0: function() {
      var current, prev, next;
      current = this._resultOrListeners;
      this._resultOrListeners = null;
      for (prev = null; current != null; prev = current, current = next) {
        next = current.get$_nextListener();
        current.set$_nextListener(prev);
      }
      return prev;
    },
    _complete$1: function(value) {
      var t1, listeners;
      t1 = J.getInterceptor(value);
      if (!!t1.$isFuture)
        if (!!t1.$is_Future)
          P._Future__chainCoreFuture(value, this);
        else
          P._Future__chainForeignFuture(value, this);
      else {
        listeners = this._removeListeners$0();
        this._setValue$1(value);
        P._Future__propagateToListeners(this, listeners);
      }
    },
    _completeWithValue$1: function(value) {
      var listeners = this._removeListeners$0();
      this._setValue$1(value);
      P._Future__propagateToListeners(this, listeners);
    },
    _completeError$2: [function(error, stackTrace) {
      var listeners = this._removeListeners$0();
      this._setError$2(error, stackTrace);
      P._Future__propagateToListeners(this, listeners);
    }, function(error) {
      return this._completeError$2(error, null);
    }, "_completeError$1", "call$2", "call$1", "get$_completeError", 2, 2, 15, 16, 17, 18],
    _asyncComplete$1: function(value) {
      var t1;
      if (value == null)
        ;
      else {
        t1 = J.getInterceptor(value);
        if (!!t1.$isFuture) {
          if (!!t1.$is_Future) {
            t1 = value._state;
            if (t1 >= 4 && t1 === 8) {
              if (this._state !== 0)
                H.throwExpression(P.StateError$("Future already completed"));
              this._state = 1;
              this._zone.scheduleMicrotask$1(new P._Future__asyncComplete_closure(this, value));
            } else
              P._Future__chainCoreFuture(value, this);
          } else
            P._Future__chainForeignFuture(value, this);
          return;
        }
      }
      if (this._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      this._state = 1;
      this._zone.scheduleMicrotask$1(new P._Future__asyncComplete_closure0(this, value));
    },
    _asyncCompleteError$2: function(error, stackTrace) {
      if (this._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      this._state = 1;
      this._zone.scheduleMicrotask$1(new P._Future__asyncCompleteError_closure(this, error, stackTrace));
    },
    _async$_Future$immediateError$2: function(error, stackTrace, $T) {
      this._asyncCompleteError$2(error, stackTrace);
    },
    _async$_Future$immediate$1: function(value, $T) {
      this._asyncComplete$1(value);
    },
    $is_Future: true,
    $isFuture: true,
    static: {"^": "_Future__INCOMPLETE,_Future__PENDING_COMPLETE,_Future__CHAINED,_Future__VALUE,_Future__ERROR", _Future$: function($T) {
        return H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null, null, null, null, null, null), [$T]);
      }, _Future$immediate: function(value, $T) {
        var t1 = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null, null, null, null, null, null), [$T]);
        t1._async$_Future$immediate$1(value, $T);
        return t1;
      }, _Future$immediateError: function(error, stackTrace, $T) {
        var t1 = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null, null, null, null, null, null), [$T]);
        t1._async$_Future$immediateError$2(error, stackTrace, $T);
        return t1;
      }, _Future__chainForeignFuture: function(source, target) {
        target.set$_isChained(true);
        source.then$2$onError(new P._Future__chainForeignFuture_closure(target), new P._Future__chainForeignFuture_closure0(target));
      }, _Future__chainCoreFuture: function(source, target) {
        target.set$_isChained(true);
        if (source._state >= 4)
          P._Future__propagateToListeners(source, target);
        else
          source._addListener$1(target);
      }, _Future__propagateMultipleListeners: function(source, listeners) {
        var listeners0;
        do {
          listeners0 = listeners.get$_nextListener();
          listeners.set$_nextListener(null);
          P._Future__propagateToListeners(source, listeners);
          if (listeners0 != null) {
            listeners = listeners0;
            continue;
          } else
            break;
        } while (true);
      }, _Future__propagateToListeners: function(source, listeners) {
        var t1, t2, t3, hasError, asyncError, sourceValue, zone, oldZone, chainSource, listeners0;
        t1 = {};
        t1.source_4 = source;
        for (t2 = source; true;) {
          t3 = {};
          if (!t2.get$_isComplete())
            return;
          hasError = t1.source_4.get$_hasError();
          if (hasError && listeners == null) {
            asyncError = t1.source_4.get$_error();
            t1.source_4.get$_zone().handleUncaughtError$2(asyncError.get$error(), asyncError.get$stackTrace());
            return;
          }
          if (listeners == null)
            return;
          if (listeners.get$_nextListener() != null) {
            P._Future__propagateMultipleListeners(t1.source_4, listeners);
            return;
          }
          t3.listenerHasValue_1 = true;
          sourceValue = t1.source_4.get$_hasValue() ? t1.source_4.get$_value() : null;
          t3.listenerValueOrError_2 = sourceValue;
          t3.isPropagationAborted_3 = false;
          t2 = !hasError;
          if (!t2 || listeners.get$_onValue() != null || listeners.get$_whenCompleteAction() != null) {
            zone = listeners.get$_zone();
            if (hasError && !t1.source_4.get$_zone().inSameErrorZone$1(zone)) {
              asyncError = t1.source_4.get$_error();
              t1.source_4.get$_zone().handleUncaughtError$2(asyncError.get$error(), asyncError.get$stackTrace());
              return;
            }
            oldZone = $.Zone__current;
            if (oldZone == null ? zone != null : oldZone !== zone)
              $.Zone__current = zone;
            else
              oldZone = null;
            if (t2) {
              if (listeners.get$_onValue() != null)
                t3.listenerHasValue_1 = new P._Future__propagateToListeners_handleValueCallback(t3, listeners, sourceValue, zone).call$0();
            } else
              new P._Future__propagateToListeners_handleError(t1, t3, listeners, zone).call$0();
            if (listeners.get$_whenCompleteAction() != null)
              new P._Future__propagateToListeners_handleWhenCompleteCallback(t1, t3, hasError, listeners, zone).call$0();
            if (oldZone != null)
              $.Zone__current = oldZone;
            listeners.set$_onValueCallback(null);
            listeners.set$_errorTestCallback(null);
            listeners.set$_onErrorCallback(null);
            listeners.set$_whenCompleteActionCallback(null);
            if (t3.isPropagationAborted_3)
              return;
            if (t3.listenerHasValue_1 === true) {
              t2 = t3.listenerValueOrError_2;
              t2 = (sourceValue == null ? t2 != null : sourceValue !== t2) && !!J.getInterceptor(t2).$isFuture;
            } else
              t2 = false;
            if (t2) {
              chainSource = t3.listenerValueOrError_2;
              if (!!J.getInterceptor(chainSource).$is_Future)
                if (chainSource._state >= 4) {
                  listeners.set$_isChained(true);
                  t1.source_4 = chainSource;
                  t2 = chainSource;
                  continue;
                } else
                  P._Future__chainCoreFuture(chainSource, listeners);
              else
                P._Future__chainForeignFuture(chainSource, listeners);
              return;
            }
          }
          if (t3.listenerHasValue_1 === true) {
            listeners0 = listeners._removeListeners$0();
            listeners._setValue$1(t3.listenerValueOrError_2);
          } else {
            listeners0 = listeners._removeListeners$0();
            asyncError = t3.listenerValueOrError_2;
            listeners._setError$2(asyncError.get$error(), asyncError.get$stackTrace());
          }
          t1.source_4 = listeners;
          t2 = listeners;
          listeners = listeners0;
        }
      }}
  },
  _Future__addListener_closure: {
    "^": "Closure:55;this_0,listener_1",
    call$0: [function() {
      P._Future__propagateToListeners(this.this_0, this.listener_1);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _Future__chainForeignFuture_closure: {
    "^": "Closure:58;target_0",
    call$1: [function(value) {
      this.target_0._completeWithValue$1(value);
    }, "call$1", null, 2, 0, null, 14, "call"],
    $isFunction: true
  },
  _Future__chainForeignFuture_closure0: {
    "^": "Closure:67;target_1",
    call$2: [function(error, stackTrace) {
      this.target_1._completeError$2(error, stackTrace);
    }, function(error) {
      return this.call$2(error, null);
    }, "call$1", "call$2", null, null, 2, 2, null, 16, 17, 18, "call"],
    $isFunction: true
  },
  _Future__asyncComplete_closure: {
    "^": "Closure:55;this_0,coreFuture_1",
    call$0: [function() {
      P._Future__chainCoreFuture(this.coreFuture_1, this.this_0);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _Future__asyncComplete_closure0: {
    "^": "Closure:55;this_2,value_3",
    call$0: [function() {
      this.this_2._completeWithValue$1(this.value_3);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _Future__asyncCompleteError_closure: {
    "^": "Closure:55;this_0,error_1,stackTrace_2",
    call$0: [function() {
      this.this_0._completeError$2(this.error_1, this.stackTrace_2);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _Future__propagateToListeners_handleValueCallback: {
    "^": "Closure:68;box_1,listener_3,sourceValue_4,zone_5",
    call$0: function() {
      var e, s, exception, t1;
      try {
        this.box_1.listenerValueOrError_2 = this.zone_5.runUnary$2(this.listener_3.get$_onValue(), this.sourceValue_4);
        return true;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        this.box_1.listenerValueOrError_2 = new P._AsyncError(e, s);
        return false;
      }

    },
    $isFunction: true
  },
  _Future__propagateToListeners_handleError: {
    "^": "Closure:12;box_2,box_1,listener_6,zone_7",
    call$0: function() {
      var asyncError, test, matchesTest, e, s, errorCallback, e0, s0, t1, exception, t2, listenerValueOrError, t3, t4;
      asyncError = this.box_2.source_4.get$_error();
      t1 = this.listener_6;
      test = t1.get$_errorTest();
      matchesTest = true;
      if (test != null)
        try {
          matchesTest = this.zone_7.runUnary$2(test, asyncError.get$error());
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = new H._StackTrace(exception, null);
          t1 = asyncError.get$error();
          t2 = e;
          listenerValueOrError = (t1 == null ? t2 == null : t1 === t2) ? asyncError : new P._AsyncError(e, s);
          t1 = this.box_1;
          t1.listenerValueOrError_2 = listenerValueOrError;
          t1.listenerHasValue_1 = false;
          return;
        }

      errorCallback = t1.get$_onError();
      if (matchesTest === true && errorCallback != null) {
        try {
          t1 = errorCallback;
          t2 = H.getDynamicRuntimeType();
          t2 = H.buildFunctionType(t2, [t2, t2])._isTest$1(t1);
          t3 = this.zone_7;
          t4 = this.box_1;
          if (t2)
            t4.listenerValueOrError_2 = t3.runBinary$3(errorCallback, asyncError.get$error(), asyncError.get$stackTrace());
          else
            t4.listenerValueOrError_2 = t3.runUnary$2(errorCallback, asyncError.get$error());
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e0 = t1;
          s0 = new H._StackTrace(exception, null);
          t1 = asyncError.get$error();
          t2 = e0;
          listenerValueOrError = (t1 == null ? t2 == null : t1 === t2) ? asyncError : new P._AsyncError(e0, s0);
          t1 = this.box_1;
          t1.listenerValueOrError_2 = listenerValueOrError;
          t1.listenerHasValue_1 = false;
          return;
        }

        this.box_1.listenerHasValue_1 = true;
      } else {
        t1 = this.box_1;
        t1.listenerValueOrError_2 = asyncError;
        t1.listenerHasValue_1 = false;
      }
    },
    $isFunction: true
  },
  _Future__propagateToListeners_handleWhenCompleteCallback: {
    "^": "Closure:12;box_2,box_1,hasError_8,listener_9,zone_10",
    call$0: function() {
      var t1, e, s, exception, t2, t3;
      t1 = {};
      t1.completeResult_0 = null;
      try {
        t1.completeResult_0 = this.zone_10.run$1(this.listener_9.get$_whenCompleteAction());
      } catch (exception) {
        t2 = H.unwrapException(exception);
        e = t2;
        s = new H._StackTrace(exception, null);
        if (this.hasError_8) {
          t2 = this.box_2.source_4.get$_error().get$error();
          t3 = e;
          t3 = t2 == null ? t3 == null : t2 === t3;
          t2 = t3;
        } else
          t2 = false;
        t3 = this.box_1;
        if (t2)
          t3.listenerValueOrError_2 = this.box_2.source_4.get$_error();
        else
          t3.listenerValueOrError_2 = new P._AsyncError(e, s);
        t3.listenerHasValue_1 = false;
      }

      if (!!J.getInterceptor(t1.completeResult_0).$isFuture) {
        t2 = this.listener_9;
        t2.set$_isChained(true);
        this.box_1.isPropagationAborted_3 = true;
        t1.completeResult_0.then$2$onError(new P._Future__propagateToListeners_handleWhenCompleteCallback_closure(this.box_2, t2), new P._Future__propagateToListeners_handleWhenCompleteCallback_closure0(t1, t2));
      }
    },
    $isFunction: true
  },
  _Future__propagateToListeners_handleWhenCompleteCallback_closure: {
    "^": "Closure:58;box_2,listener_11",
    call$1: [function(ignored) {
      P._Future__propagateToListeners(this.box_2.source_4, this.listener_11);
    }, "call$1", null, 2, 0, null, 69, "call"],
    $isFunction: true
  },
  _Future__propagateToListeners_handleWhenCompleteCallback_closure0: {
    "^": "Closure:67;box_0,listener_12",
    call$2: [function(error, stackTrace) {
      var t1, completeResult;
      t1 = this.box_0;
      if (!J.getInterceptor(t1.completeResult_0).$is_Future) {
        completeResult = P._Future$(null);
        t1.completeResult_0 = completeResult;
        completeResult._setError$2(error, stackTrace);
      }
      P._Future__propagateToListeners(t1.completeResult_0, this.listener_12);
    }, function(error) {
      return this.call$2(error, null);
    }, "call$1", "call$2", null, null, 2, 2, null, 16, 17, 18, "call"],
    $isFunction: true
  },
  _AsyncCallbackEntry: {
    "^": "Object;callback,next@",
    callback$0: function() {
      return this.callback.call$0();
    }
  },
  Stream: {
    "^": "Object;",
    expand$1: function(_, convert) {
      return H.setRuntimeTypeInfo(new P._ExpandStream(convert, this), [H.getRuntimeTypeArgument(this, "Stream", 0), null]);
    },
    transform$1: function(streamTransformer) {
      return streamTransformer.bind$1(this);
    },
    contains$1: function(_, needle) {
      var t1, future;
      t1 = {};
      future = P._Future$(P.bool);
      t1.subscription_0 = null;
      t1.subscription_0 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_contains_closure(t1, this, needle, future), true, new P.Stream_contains_closure0(future), future.get$_completeError());
      return future;
    },
    forEach$1: function(_, action) {
      var t1, future;
      t1 = {};
      future = P._Future$(null);
      t1.subscription_0 = null;
      t1.subscription_0 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_forEach_closure(t1, this, action, future), true, new P.Stream_forEach_closure0(future), future.get$_completeError());
      return future;
    },
    any$1: function(_, test) {
      var t1, future;
      t1 = {};
      future = P._Future$(P.bool);
      t1.subscription_0 = null;
      t1.subscription_0 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_any_closure(t1, this, test, future), true, new P.Stream_any_closure0(future), future.get$_completeError());
      return future;
    },
    get$length: function(_) {
      var t1, future;
      t1 = {};
      future = P._Future$(P.$int);
      t1.count_0 = 0;
      this.listen$4$cancelOnError$onDone$onError(new P.Stream_length_closure(t1), true, new P.Stream_length_closure0(t1, future), future.get$_completeError());
      return future;
    },
    get$isEmpty: function(_) {
      var t1, future;
      t1 = {};
      future = P._Future$(P.bool);
      t1.subscription_0 = null;
      t1.subscription_0 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_isEmpty_closure(t1, future), true, new P.Stream_isEmpty_closure0(future), future.get$_completeError());
      return future;
    },
    toList$0: function(_) {
      var result, future;
      result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(this, "Stream", 0)]);
      future = P._Future$([P.List, H.getRuntimeTypeArgument(this, "Stream", 0)]);
      this.listen$4$cancelOnError$onDone$onError(new P.Stream_toList_closure(this, result), true, new P.Stream_toList_closure0(result, future), future.get$_completeError());
      return future;
    },
    skip$1: function(_, count) {
      var t1 = H.setRuntimeTypeInfo(new P._SkipStream(count, this), [null]);
      t1._SkipStream$2(this, count, null);
      return t1;
    },
    get$first: function(_) {
      var t1, future;
      t1 = {};
      future = P._Future$(H.getRuntimeTypeArgument(this, "Stream", 0));
      t1.subscription_0 = null;
      t1.subscription_0 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_first_closure(t1, this, future), true, new P.Stream_first_closure0(future), future.get$_completeError());
      return future;
    },
    get$last: function(_) {
      var t1, future;
      t1 = {};
      future = P._Future$(H.getRuntimeTypeArgument(this, "Stream", 0));
      t1.result_0 = null;
      t1.foundResult_1 = false;
      this.listen$4$cancelOnError$onDone$onError(new P.Stream_last_closure(t1, this), true, new P.Stream_last_closure0(t1, future), future.get$_completeError());
      return future;
    }
  },
  Stream_Stream$fromIterable_closure: {
    "^": "Closure:55;T_0,data_1",
    call$0: [function() {
      var t1 = this.data_1;
      return H.setRuntimeTypeInfo(new P._IterablePendingEvents(H.setRuntimeTypeInfo(new H.ListIterator(t1, 0, 0, null), [H.getTypeArgumentByIndex(t1, 0)]), 0), [this.T_0]);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  Stream_contains_closure: {
    "^": "Closure;box_0,this_1,needle_2,future_3",
    call$1: [function(element) {
      var t1, t2;
      t1 = this.box_0;
      t2 = this.future_3;
      P._runUserCode(new P.Stream_contains__closure(this.needle_2, element), new P.Stream_contains__closure0(t1, t2), P._cancelAndErrorClosure(t1.subscription_0, t2));
    }, "call$1", null, 2, 0, null, 70, "call"],
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_1, "Stream");
    }
  },
  Stream_contains__closure: {
    "^": "Closure:55;needle_4,element_5",
    call$0: function() {
      return J.$eq(this.element_5, this.needle_4);
    },
    $isFunction: true
  },
  Stream_contains__closure0: {
    "^": "Closure:71;box_0,future_6",
    call$1: function(isMatch) {
      if (isMatch === true)
        P._cancelAndValue(this.box_0.subscription_0, this.future_6, true);
    },
    $isFunction: true
  },
  Stream_contains_closure0: {
    "^": "Closure:55;future_7",
    call$0: [function() {
      this.future_7._complete$1(false);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  Stream_forEach_closure: {
    "^": "Closure;box_0,this_1,action_2,future_3",
    call$1: [function(element) {
      P._runUserCode(new P.Stream_forEach__closure(this.action_2, element), new P.Stream_forEach__closure0(), P._cancelAndErrorClosure(this.box_0.subscription_0, this.future_3));
    }, "call$1", null, 2, 0, null, 70, "call"],
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_1, "Stream");
    }
  },
  Stream_forEach__closure: {
    "^": "Closure:55;action_4,element_5",
    call$0: function() {
      return this.action_4.call$1(this.element_5);
    },
    $isFunction: true
  },
  Stream_forEach__closure0: {
    "^": "Closure:58;",
    call$1: function(_) {
    },
    $isFunction: true
  },
  Stream_forEach_closure0: {
    "^": "Closure:55;future_6",
    call$0: [function() {
      this.future_6._complete$1(null);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  Stream_any_closure: {
    "^": "Closure;box_0,this_1,test_2,future_3",
    call$1: [function(element) {
      var t1, t2;
      t1 = this.box_0;
      t2 = this.future_3;
      P._runUserCode(new P.Stream_any__closure(this.test_2, element), new P.Stream_any__closure0(t1, t2), P._cancelAndErrorClosure(t1.subscription_0, t2));
    }, "call$1", null, 2, 0, null, 70, "call"],
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_1, "Stream");
    }
  },
  Stream_any__closure: {
    "^": "Closure:55;test_4,element_5",
    call$0: function() {
      return this.test_4.call$1(this.element_5);
    },
    $isFunction: true
  },
  Stream_any__closure0: {
    "^": "Closure:71;box_0,future_6",
    call$1: function(isMatch) {
      if (isMatch === true)
        P._cancelAndValue(this.box_0.subscription_0, this.future_6, true);
    },
    $isFunction: true
  },
  Stream_any_closure0: {
    "^": "Closure:55;future_7",
    call$0: [function() {
      this.future_7._complete$1(false);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  Stream_length_closure: {
    "^": "Closure:58;box_0",
    call$1: [function(_) {
      ++this.box_0.count_0;
    }, "call$1", null, 2, 0, null, 60, "call"],
    $isFunction: true
  },
  Stream_length_closure0: {
    "^": "Closure:55;box_0,future_1",
    call$0: [function() {
      this.future_1._complete$1(this.box_0.count_0);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  Stream_isEmpty_closure: {
    "^": "Closure:58;box_0,future_1",
    call$1: [function(_) {
      P._cancelAndValue(this.box_0.subscription_0, this.future_1, false);
    }, "call$1", null, 2, 0, null, 60, "call"],
    $isFunction: true
  },
  Stream_isEmpty_closure0: {
    "^": "Closure:55;future_2",
    call$0: [function() {
      this.future_2._complete$1(true);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  Stream_toList_closure: {
    "^": "Closure;this_0,result_1",
    call$1: [function(data) {
      this.result_1.push(data);
    }, "call$1", null, 2, 0, null, 72, "call"],
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_0, "Stream");
    }
  },
  Stream_toList_closure0: {
    "^": "Closure:55;result_2,future_3",
    call$0: [function() {
      this.future_3._complete$1(this.result_2);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  Stream_first_closure: {
    "^": "Closure;box_0,this_1,future_2",
    call$1: [function(value) {
      P._cancelAndValue(this.box_0.subscription_0, this.future_2, value);
    }, "call$1", null, 2, 0, null, 14, "call"],
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_1, "Stream");
    }
  },
  Stream_first_closure0: {
    "^": "Closure:55;future_3",
    call$0: [function() {
      var e, s, t1, exception;
      try {
        t1 = H.IterableElementError_noElement();
        throw H.wrapException(t1);
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        this.future_3._completeError$2(e, s);
      }

    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  Stream_last_closure: {
    "^": "Closure;box_0,this_1",
    call$1: [function(value) {
      var t1 = this.box_0;
      t1.foundResult_1 = true;
      t1.result_0 = value;
    }, "call$1", null, 2, 0, null, 14, "call"],
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_1, "Stream");
    }
  },
  Stream_last_closure0: {
    "^": "Closure:55;box_0,future_2",
    call$0: [function() {
      var e, s, t1, exception;
      t1 = this.box_0;
      if (t1.foundResult_1) {
        this.future_2._complete$1(t1.result_0);
        return;
      }
      try {
        t1 = H.IterableElementError_noElement();
        throw H.wrapException(t1);
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        this.future_2._completeError$2(e, s);
      }

    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  StreamSubscription: {
    "^": "Object;"
  },
  EventSink: {
    "^": "Object;"
  },
  _StreamController: {
    "^": "Object;",
    get$isPaused: function() {
      var t1 = this._state;
      return (t1 & 1) !== 0 ? this.get$_async$_subscription().get$_isInputPaused() : (t1 & 2) === 0;
    },
    get$_pendingEvents: function() {
      if ((this._state & 8) === 0)
        return this._varData;
      return this._varData.get$varData();
    },
    _ensurePendingEvents$0: function() {
      var t1, state;
      if ((this._state & 8) === 0) {
        t1 = this._varData;
        if (t1 == null) {
          t1 = new P._StreamImplEvents(null, null, 0);
          this._varData = t1;
        }
        return t1;
      }
      state = this._varData;
      if (state.get$varData() == null)
        state.set$varData(new P._StreamImplEvents(null, null, 0));
      return state.get$varData();
    },
    get$_async$_subscription: function() {
      if ((this._state & 8) !== 0)
        return this._varData.get$varData();
      return this._varData;
    },
    _badEventState$0: function() {
      if ((this._state & 4) !== 0)
        return new P.StateError("Cannot add event after closing");
      return new P.StateError("Cannot add event while adding a stream");
    },
    addStream$2$cancelOnError: function(source, cancelOnError) {
      var t1, t2, t3, t4, addState;
      t1 = this._state;
      if (t1 >= 4)
        throw H.wrapException(this._badEventState$0());
      if ((t1 & 2) !== 0)
        return P._Future$immediate(null, null);
      t1 = this._varData;
      t2 = P._Future$(null);
      t3 = this.get$_async$_add();
      t4 = cancelOnError ? P._AddStreamState_makeErrorHandler(this) : this.get$_addError();
      addState = H.setRuntimeTypeInfo(new P._StreamControllerAddStreamState(t1, t2, source.listen$4$cancelOnError$onDone$onError(t3, cancelOnError, this.get$_close(), t4)), [null]);
      t1 = this._state;
      if ((t1 & 1) !== 0 ? this.get$_async$_subscription().get$_isInputPaused() : (t1 & 2) === 0)
        addState.addSubscription.pause$0();
      this._varData = addState;
      this._state |= 8;
      return addState.addStreamFuture;
    },
    addStream$1: function(source) {
      return this.addStream$2$cancelOnError(source, true);
    },
    _ensureDoneFuture$0: function() {
      var t1 = this._doneFuture;
      if (t1 == null) {
        t1 = (this._state & 2) !== 0 ? $.get$Future__nullFuture() : P._Future$(null);
        this._doneFuture = t1;
      }
      return t1;
    },
    add$1: [function(_, value) {
      if (this._state >= 4)
        throw H.wrapException(this._badEventState$0());
      this._async$_add$1(value);
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "void__T", void: true, args: [T]};
      }, this.$receiver, "_StreamController");
    }],
    addError$2: [function(error, stackTrace) {
      if (this._state >= 4)
        throw H.wrapException(this._badEventState$0());
      this._addError$2(error, stackTrace);
    }, function(error) {
      return this.addError$2(error, null);
    }, "addError$1", "call$2", "call$1", "get$addError", 2, 2, 66, 16, 17, 18],
    close$0: [function() {
      var t1 = this._state;
      if ((t1 & 4) !== 0)
        return this._ensureDoneFuture$0();
      if (t1 >= 4)
        throw H.wrapException(this._badEventState$0());
      t1 |= 4;
      this._state = t1;
      if ((t1 & 1) !== 0)
        this._sendDone$0();
      else if ((t1 & 3) === 0)
        this._ensurePendingEvents$0().add$1(0, C.C__DelayedDone);
      return this._ensureDoneFuture$0();
    }, "call$0", "get$close", 0, 0, 73],
    _async$_add$1: [function(value) {
      var t1 = this._state;
      if ((t1 & 1) !== 0)
        this._sendData$1(value);
      else if ((t1 & 3) === 0)
        this._ensurePendingEvents$0().add$1(0, H.setRuntimeTypeInfo(new P._DelayedData(value, null), [H.getRuntimeTypeArgument(this, "_StreamController", 0)]));
    }, "call$1", "get$_async$_add", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "void__T", void: true, args: [T]};
      }, this.$receiver, "_StreamController");
    }, 14],
    _addError$2: [function(error, stackTrace) {
      var t1 = this._state;
      if ((t1 & 1) !== 0)
        this._sendError$2(error, stackTrace);
      else if ((t1 & 3) === 0)
        this._ensurePendingEvents$0().add$1(0, new P._DelayedError(error, stackTrace, null));
    }, "call$2", "get$_addError", 4, 0, 74, 17, 18],
    _close$0: [function() {
      var addState = this._varData;
      this._varData = addState.get$varData();
      this._state &= 4294967287;
      addState.complete$0();
    }, "call$0", "get$_close", 0, 0, 12],
    _subscribe$4: function(onData, onError, onDone, cancelOnError) {
      var t1, t2, subscription, pendingEvents, addState;
      if ((this._state & 3) !== 0)
        throw H.wrapException(P.StateError$("Stream has already been listened to."));
      t1 = $.Zone__current;
      t2 = cancelOnError ? 1 : 0;
      subscription = H.setRuntimeTypeInfo(new P._ControllerSubscription(this, null, null, null, t1, t2, null, null), [null]);
      subscription._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, null);
      pendingEvents = this.get$_pendingEvents();
      t2 = this._state |= 1;
      if ((t2 & 8) !== 0) {
        addState = this._varData;
        addState.set$varData(subscription);
        addState.resume$0();
      } else
        this._varData = subscription;
      subscription._setPendingEvents$1(pendingEvents);
      subscription._guardCallback$1(new P._StreamController__subscribe_closure(this));
      return subscription;
    },
    _recordCancel$1: function(subscription) {
      var result, e, s, exception, t1, result0;
      result = null;
      if ((this._state & 8) !== 0)
        result = this._varData.cancel$0();
      this._varData = null;
      this._state = this._state & 4294967286 | 2;
      if (this.get$_onCancel() != null)
        if (result == null)
          try {
            result = this._onCancel$0();
          } catch (exception) {
            t1 = H.unwrapException(exception);
            e = t1;
            s = new H._StackTrace(exception, null);
            result0 = P._Future$(null);
            result0._asyncCompleteError$2(e, s);
            result = result0;
          }

        else
          result = result.whenComplete$1(this.get$_onCancel());
      t1 = new P._StreamController__recordCancel_complete(this);
      if (result != null)
        result = result.whenComplete$1(t1);
      else
        t1.call$0();
      return result;
    },
    _recordPause$1: function(subscription) {
      if ((this._state & 8) !== 0)
        this._varData.pause$0();
      P._runGuarded(this.get$_onPause());
    },
    _recordResume$1: function(subscription) {
      if ((this._state & 8) !== 0)
        this._varData.resume$0();
      P._runGuarded(this.get$_onResume());
    }
  },
  _StreamController__subscribe_closure: {
    "^": "Closure:55;this_0",
    call$0: function() {
      P._runGuarded(this.this_0.get$_onListen());
    },
    $isFunction: true
  },
  _StreamController__recordCancel_complete: {
    "^": "Closure:12;this_0",
    call$0: [function() {
      var t1 = this.this_0._doneFuture;
      if (t1 != null && t1._state === 0)
        t1._asyncComplete$1(null);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _SyncStreamControllerDispatch: {
    "^": "Object;",
    _sendData$1: function(data) {
      this.get$_async$_subscription()._async$_add$1(data);
    },
    _sendError$2: function(error, stackTrace) {
      this.get$_async$_subscription()._addError$2(error, stackTrace);
    },
    _sendDone$0: function() {
      this.get$_async$_subscription()._close$0();
    }
  },
  _AsyncStreamControllerDispatch: {
    "^": "Object;",
    _sendData$1: function(data) {
      this.get$_async$_subscription()._addPending$1(H.setRuntimeTypeInfo(new P._DelayedData(data, null), [null]));
    },
    _sendError$2: function(error, stackTrace) {
      this.get$_async$_subscription()._addPending$1(new P._DelayedError(error, stackTrace, null));
    },
    _sendDone$0: function() {
      this.get$_async$_subscription()._addPending$1(C.C__DelayedDone);
    }
  },
  _AsyncStreamController: {
    "^": "_StreamController__AsyncStreamControllerDispatch;_onListen<,_onPause<,_onResume<,_onCancel<,_varData,_state,_doneFuture",
    _onCancel$0: function() {
      return this._onCancel.call$0();
    }
  },
  _StreamController__AsyncStreamControllerDispatch: {
    "^": "_StreamController+_AsyncStreamControllerDispatch;"
  },
  _SyncStreamController: {
    "^": "_StreamController__SyncStreamControllerDispatch;_onListen<,_onPause<,_onResume<,_onCancel<,_varData,_state,_doneFuture",
    _onCancel$0: function() {
      return this._onCancel.call$0();
    }
  },
  _StreamController__SyncStreamControllerDispatch: {
    "^": "_StreamController+_SyncStreamControllerDispatch;"
  },
  _NoCallbacks: {
    "^": "Object;",
    get$_onListen: function() {
      return;
    },
    get$_onPause: function() {
      return;
    },
    get$_onResume: function() {
      return;
    },
    get$_onCancel: function() {
      return;
    },
    _onCancel$0: function() {
      return this.get$_onCancel().call$0();
    }
  },
  _NoCallbackAsyncStreamController: {
    "^": "_StreamController__AsyncStreamControllerDispatch0+_NoCallbacks;_varData,_state,_doneFuture"
  },
  _StreamController__AsyncStreamControllerDispatch0: {
    "^": "_StreamController+_AsyncStreamControllerDispatch;",
    $as_StreamController: function() {
      return [null];
    }
  },
  _NoCallbackSyncStreamController: {
    "^": "_StreamController__SyncStreamControllerDispatch0+_NoCallbacks;_varData,_state,_doneFuture"
  },
  _StreamController__SyncStreamControllerDispatch0: {
    "^": "_StreamController+_SyncStreamControllerDispatch;",
    $as_StreamController: function() {
      return [null];
    }
  },
  _ControllerStream: {
    "^": "_StreamImpl;_async$_controller",
    _createSubscription$4: function(onData, onError, onDone, cancelOnError) {
      return this._async$_controller._subscribe$4(onData, onError, onDone, cancelOnError);
    },
    get$hashCode: function(_) {
      return (H.Primitives_objectHashCode(this._async$_controller) ^ 892482866) >>> 0;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!J.getInterceptor(other).$is_ControllerStream)
        return false;
      return other._async$_controller === this._async$_controller;
    },
    $is_ControllerStream: true
  },
  _ControllerSubscription: {
    "^": "_BufferingStreamSubscription;_async$_controller<,_onData,_onError,_onDone,_zone,_state,_cancelFuture,_pending",
    _onCancel$0: function() {
      return this.get$_async$_controller()._recordCancel$1(this);
    },
    _onPause$0: [function() {
      this.get$_async$_controller()._recordPause$1(this);
    }, "call$0", "get$_onPause", 0, 0, 12],
    _onResume$0: [function() {
      this.get$_async$_controller()._recordResume$1(this);
    }, "call$0", "get$_onResume", 0, 0, 12]
  },
  _AddStreamState: {
    "^": "Object;",
    pause$0: function() {
      this.addSubscription.pause$0();
    },
    resume$0: function() {
      this.addSubscription.resume$0();
    },
    cancel$0: function() {
      var cancel = this.addSubscription.cancel$0();
      if (cancel == null) {
        this.addStreamFuture._asyncComplete$1(null);
        return;
      }
      return cancel.whenComplete$1(new P._AddStreamState_cancel_closure(this));
    },
    complete$0: function() {
      this.addStreamFuture._asyncComplete$1(null);
    }
  },
  _AddStreamState_makeErrorHandler_closure: {
    "^": "Closure:76;controller_0",
    call$2: [function(e, s) {
      var t1 = this.controller_0;
      t1._addError$2(e, s);
      t1._close$0();
    }, "call$2", null, 4, 0, null, 2, 75, "call"],
    $isFunction: true
  },
  _AddStreamState_cancel_closure: {
    "^": "Closure:55;this_0",
    call$0: [function() {
      this.this_0.addStreamFuture._asyncComplete$1(null);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _StreamControllerAddStreamState: {
    "^": "_AddStreamState;varData@,addStreamFuture,addSubscription"
  },
  _EventSink: {
    "^": "Object;"
  },
  _BufferingStreamSubscription: {
    "^": "Object;_onData,_onError<,_onDone,_zone<,_state,_cancelFuture,_pending",
    _setPendingEvents$1: function(pendingEvents) {
      if (pendingEvents == null)
        return;
      this._pending = pendingEvents;
      if (J.get$isEmpty$asx(pendingEvents) !== true) {
        this._state = (this._state | 64) >>> 0;
        this._pending.schedule$1(this);
      }
    },
    onDone$1: function(handleDone) {
      if (handleDone == null)
        handleDone = P._nullDoneHandler$closure();
      this._onDone = this._zone.registerCallback$1(handleDone);
    },
    pause$1: function(resumeSignal) {
      var t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      this._state = (t1 + 128 | 4) >>> 0;
      if (resumeSignal != null)
        resumeSignal.whenComplete$1(this.get$resume());
      if (t1 < 128 && this._pending != null)
        this._pending.cancelSchedule$0();
      if ((t1 & 4) === 0 && (this._state & 32) === 0)
        this._guardCallback$1(this.get$_onPause());
    },
    pause$0: function() {
      return this.pause$1(null);
    },
    resume$0: [function() {
      var t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 >= 128) {
        t1 -= 128;
        this._state = t1;
        if (t1 < 128)
          if ((t1 & 64) !== 0 && J.get$isEmpty$asx(this._pending) !== true)
            this._pending.schedule$1(this);
          else {
            t1 = (this._state & 4294967291) >>> 0;
            this._state = t1;
            if ((t1 & 32) === 0)
              this._guardCallback$1(this.get$_onResume());
          }
      }
    }, "call$0", "get$resume", 0, 0, 12],
    cancel$0: function() {
      var t1 = (this._state & 4294967279) >>> 0;
      this._state = t1;
      if ((t1 & 8) !== 0)
        return this._cancelFuture;
      this._cancel$0();
      return this._cancelFuture;
    },
    asFuture$1: function(futureValue) {
      var result = P._Future$(H.getRuntimeTypeArgument(this, "_BufferingStreamSubscription", 0));
      this._onDone = new P._BufferingStreamSubscription_asFuture_closure(futureValue, result);
      this._onError = new P._BufferingStreamSubscription_asFuture_closure0(this, result);
      return result;
    },
    get$_isInputPaused: function() {
      return (this._state & 4) !== 0;
    },
    get$isPaused: function() {
      return this._state >= 128;
    },
    _cancel$0: function() {
      var t1 = (this._state | 8) >>> 0;
      this._state = t1;
      if ((t1 & 64) !== 0)
        this._pending.cancelSchedule$0();
      if ((this._state & 32) === 0)
        this._pending = null;
      this._cancelFuture = this._onCancel$0();
    },
    _async$_add$1: function(data) {
      var t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 < 32)
        this._sendData$1(data);
      else
        this._addPending$1(H.setRuntimeTypeInfo(new P._DelayedData(data, null), [null]));
    },
    _addError$2: function(error, stackTrace) {
      var t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 < 32)
        this._sendError$2(error, stackTrace);
      else
        this._addPending$1(new P._DelayedError(error, stackTrace, null));
    },
    _close$0: function() {
      var t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      t1 = (t1 | 2) >>> 0;
      this._state = t1;
      if (t1 < 32)
        this._sendDone$0();
      else
        this._addPending$1(C.C__DelayedDone);
    },
    _onPause$0: [function() {
    }, "call$0", "get$_onPause", 0, 0, 12],
    _onResume$0: [function() {
    }, "call$0", "get$_onResume", 0, 0, 12],
    _onCancel$0: function() {
      return;
    },
    _addPending$1: function($event) {
      var pending, t1;
      pending = this._pending;
      if (pending == null) {
        pending = new P._StreamImplEvents(null, null, 0);
        this._pending = pending;
      }
      J.add$1$ax(pending, $event);
      t1 = this._state;
      if ((t1 & 64) === 0) {
        t1 = (t1 | 64) >>> 0;
        this._state = t1;
        if (t1 < 128)
          this._pending.schedule$1(this);
      }
    },
    _sendData$1: function(data) {
      var t1 = this._state;
      this._state = (t1 | 32) >>> 0;
      this._zone.runUnaryGuarded$2(this._onData, data);
      this._state = (this._state & 4294967263) >>> 0;
      this._checkState$1((t1 & 4) !== 0);
    },
    _sendError$2: function(error, stackTrace) {
      var t1, t2;
      t1 = this._state;
      t2 = new P._BufferingStreamSubscription__sendError_sendError(this, error, stackTrace);
      if ((t1 & 1) !== 0) {
        this._state = (t1 | 16) >>> 0;
        this._cancel$0();
        t1 = this._cancelFuture;
        if (!!J.getInterceptor(t1).$isFuture)
          t1.whenComplete$1(t2);
        else
          t2.call$0();
      } else {
        t2.call$0();
        this._checkState$1((t1 & 4) !== 0);
      }
    },
    _sendDone$0: function() {
      var t1, t2;
      t1 = new P._BufferingStreamSubscription__sendDone_sendDone(this);
      this._cancel$0();
      this._state = (this._state | 16) >>> 0;
      t2 = this._cancelFuture;
      if (!!J.getInterceptor(t2).$isFuture)
        t2.whenComplete$1(t1);
      else
        t1.call$0();
    },
    _guardCallback$1: function(callback) {
      var t1 = this._state;
      this._state = (t1 | 32) >>> 0;
      callback.call$0();
      this._state = (this._state & 4294967263) >>> 0;
      this._checkState$1((t1 & 4) !== 0);
    },
    _checkState$1: function(wasInputPaused) {
      var t1, isInputPaused;
      if ((this._state & 64) !== 0 && J.get$isEmpty$asx(this._pending) === true) {
        t1 = (this._state & 4294967231) >>> 0;
        this._state = t1;
        if ((t1 & 4) !== 0)
          if (t1 < 128) {
            t1 = this._pending;
            t1 = t1 == null || J.get$isEmpty$asx(t1) === true;
          } else
            t1 = false;
        else
          t1 = false;
        if (t1)
          this._state = (this._state & 4294967291) >>> 0;
      }
      for (; true; wasInputPaused = isInputPaused) {
        t1 = this._state;
        if ((t1 & 8) !== 0) {
          this._pending = null;
          return;
        }
        isInputPaused = (t1 & 4) !== 0;
        if (wasInputPaused === isInputPaused)
          break;
        this._state = (t1 ^ 32) >>> 0;
        if (isInputPaused)
          this._onPause$0();
        else
          this._onResume$0();
        this._state = (this._state & 4294967263) >>> 0;
      }
      t1 = this._state;
      if ((t1 & 64) !== 0 && t1 < 128)
        this._pending.schedule$1(this);
    },
    _BufferingStreamSubscription$4: function(onData, onError, onDone, cancelOnError, $T) {
      var handleData, t1;
      handleData = onData == null ? P._nullDataHandler$closure() : onData;
      t1 = this._zone;
      this._onData = t1.registerUnaryCallback$1(handleData);
      this._onError = P._registerErrorHandler(onError == null ? P._nullErrorHandler$closure() : onError, t1);
      this.onDone$1(onDone);
    },
    static: {"^": "_BufferingStreamSubscription__STATE_CANCEL_ON_ERROR,_BufferingStreamSubscription__STATE_CLOSED,_BufferingStreamSubscription__STATE_INPUT_PAUSED,_BufferingStreamSubscription__STATE_CANCELED,_BufferingStreamSubscription__STATE_WAIT_FOR_CANCEL,_BufferingStreamSubscription__STATE_IN_CALLBACK,_BufferingStreamSubscription__STATE_HAS_PENDING,_BufferingStreamSubscription__STATE_PAUSE_COUNT,_BufferingStreamSubscription__STATE_PAUSE_COUNT_SHIFT", _BufferingStreamSubscription$: function(onData, onError, onDone, cancelOnError, $T) {
        var t1, t2;
        t1 = $.Zone__current;
        t2 = cancelOnError ? 1 : 0;
        t2 = H.setRuntimeTypeInfo(new P._BufferingStreamSubscription(null, null, null, t1, t2, null, null), [$T]);
        t2._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, $T);
        return t2;
      }}
  },
  _BufferingStreamSubscription_asFuture_closure: {
    "^": "Closure:55;futureValue_0,result_1",
    call$0: [function() {
      this.result_1._complete$1(this.futureValue_0);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _BufferingStreamSubscription_asFuture_closure0: {
    "^": "Closure:56;this_2,result_3",
    call$2: [function(error, stackTrace) {
      this.this_2.cancel$0();
      this.result_3._completeError$2(error, stackTrace);
    }, "call$2", null, 4, 0, null, 17, 18, "call"],
    $isFunction: true
  },
  _BufferingStreamSubscription__sendError_sendError: {
    "^": "Closure:12;this_0,error_1,stackTrace_2",
    call$0: [function() {
      var t1, t2, t3, t4, t5, t6;
      t1 = this.this_0;
      t2 = t1._state;
      if ((t2 & 8) !== 0 && (t2 & 16) === 0)
        return;
      t1._state = (t2 | 32) >>> 0;
      t2 = t1._onError;
      t3 = H.getDynamicRuntimeType();
      t3 = H.buildFunctionType(t3, [t3, t3])._isTest$1(t2);
      t4 = t1._zone;
      t5 = this.error_1;
      t6 = t1._onError;
      if (t3)
        t4.runBinaryGuarded$3(t6, t5, this.stackTrace_2);
      else
        t4.runUnaryGuarded$2(t6, t5);
      t1._state = (t1._state & 4294967263) >>> 0;
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _BufferingStreamSubscription__sendDone_sendDone: {
    "^": "Closure:12;this_0",
    call$0: [function() {
      var t1, t2;
      t1 = this.this_0;
      t2 = t1._state;
      if ((t2 & 16) === 0)
        return;
      t1._state = (t2 | 42) >>> 0;
      t1._zone.runGuarded$1(t1._onDone);
      t1._state = (t1._state & 4294967263) >>> 0;
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _StreamImpl: {
    "^": "Stream;",
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      return this._createSubscription$4(onData, onError, onDone, true === cancelOnError);
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    listen$1: function(onData) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
    },
    listen$2$cancelOnError: function(onData, cancelOnError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, null, null);
    },
    listen$2$onDone: function(onData, onDone) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, null);
    },
    _createSubscription$4: function(onData, onError, onDone, cancelOnError) {
      return P._BufferingStreamSubscription$(onData, onError, onDone, cancelOnError, H.getTypeArgumentByIndex(this, 0));
    }
  },
  _GeneratedStreamImpl: {
    "^": "_StreamImpl;_pending,_isUsed",
    _pending$0: function() {
      return this._pending.call$0();
    },
    _createSubscription$4: function(onData, onError, onDone, cancelOnError) {
      var t1;
      if (this._isUsed)
        throw H.wrapException(P.StateError$("Stream has already been listened to."));
      this._isUsed = true;
      t1 = P._BufferingStreamSubscription$(onData, onError, onDone, cancelOnError, null);
      t1._setPendingEvents$1(this._pending$0());
      return t1;
    }
  },
  _IterablePendingEvents: {
    "^": "_PendingEvents;_async$_iterator,_state",
    get$isEmpty: function(_) {
      return this._async$_iterator == null;
    },
    handleNext$1: function(dispatch) {
      var isDone, e, s, t1, exception;
      t1 = this._async$_iterator;
      if (t1 == null)
        throw H.wrapException(P.StateError$("No events pending."));
      isDone = null;
      try {
        isDone = !t1.moveNext$0();
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        this._async$_iterator = null;
        dispatch._sendError$2(e, s);
        return;
      }

      if (isDone !== true)
        dispatch._sendData$1(this._async$_iterator._current);
      else {
        this._async$_iterator = null;
        dispatch._sendDone$0();
      }
    }
  },
  _DelayedEvent: {
    "^": "Object;next@"
  },
  _DelayedData: {
    "^": "_DelayedEvent;value<,next",
    perform$1: function(dispatch) {
      dispatch._sendData$1(this.value);
    }
  },
  _DelayedError: {
    "^": "_DelayedEvent;error<,stackTrace<,next",
    perform$1: function(dispatch) {
      dispatch._sendError$2(this.error, this.stackTrace);
    }
  },
  _DelayedDone: {
    "^": "Object;",
    perform$1: function(dispatch) {
      dispatch._sendDone$0();
    },
    get$next: function() {
      return;
    },
    set$next: function(_) {
      throw H.wrapException(P.StateError$("No events after a done."));
    }
  },
  _PendingEvents: {
    "^": "Object;",
    schedule$1: function(dispatch) {
      var t1 = this._state;
      if (t1 === 1)
        return;
      if (t1 >= 1) {
        this._state = 1;
        return;
      }
      P.scheduleMicrotask(new P._PendingEvents_schedule_closure(this, dispatch));
      this._state = 1;
    },
    cancelSchedule$0: function() {
      if (this._state === 1)
        this._state = 3;
    }
  },
  _PendingEvents_schedule_closure: {
    "^": "Closure:55;this_0,dispatch_1",
    call$0: [function() {
      var t1, oldState;
      t1 = this.this_0;
      oldState = t1._state;
      t1._state = 0;
      if (oldState === 3)
        return;
      t1.handleNext$1(this.dispatch_1);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _StreamImplEvents: {
    "^": "_PendingEvents;firstPendingEvent,lastPendingEvent,_state",
    get$isEmpty: function(_) {
      return this.lastPendingEvent == null;
    },
    add$1: [function(_, $event) {
      var t1 = this.lastPendingEvent;
      if (t1 == null) {
        this.lastPendingEvent = $event;
        this.firstPendingEvent = $event;
      } else {
        t1.set$next($event);
        this.lastPendingEvent = $event;
      }
    }, "call$1", "get$add", 2, 0, 77],
    handleNext$1: function(dispatch) {
      var $event, t1;
      $event = this.firstPendingEvent;
      t1 = $event.get$next();
      this.firstPendingEvent = t1;
      if (t1 == null)
        this.lastPendingEvent = null;
      $event.perform$1(dispatch);
    }
  },
  _cancelAndError_closure: {
    "^": "Closure:55;future_0,error_1,stackTrace_2",
    call$0: [function() {
      return this.future_0._completeError$2(this.error_1, this.stackTrace_2);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _cancelAndErrorClosure_closure: {
    "^": "Closure:76;subscription_0,future_1",
    call$2: function(error, stackTrace) {
      return P._cancelAndError(this.subscription_0, this.future_1, error, stackTrace);
    },
    $isFunction: true
  },
  _cancelAndValue_closure: {
    "^": "Closure:55;future_0,value_1",
    call$0: [function() {
      return this.future_0._complete$1(this.value_1);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _ForwardingStream: {
    "^": "Stream;",
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      return P._ForwardingStreamSubscription$(this, onData, onError, onDone, true === cancelOnError, H.getRuntimeTypeArgument(this, "_ForwardingStream", 0), H.getRuntimeTypeArgument(this, "_ForwardingStream", 1));
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    listen$1: function(onData) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
    },
    _handleData$2: function(data, sink) {
      sink._async$_add$1(data);
    },
    _handleError$3: function(error, stackTrace, sink) {
      sink._addError$2(error, stackTrace);
    },
    $asStream: function($S, $T) {
      return [$T];
    }
  },
  _ForwardingStreamSubscription: {
    "^": "_BufferingStreamSubscription;_async$_stream,_async$_subscription,_onData,_onError,_onDone,_zone,_state,_cancelFuture,_pending",
    _async$_add$1: function(data) {
      if ((this._state & 2) !== 0)
        return;
      P._BufferingStreamSubscription.prototype._async$_add$1.call(this, data);
    },
    _addError$2: function(error, stackTrace) {
      if ((this._state & 2) !== 0)
        return;
      P._BufferingStreamSubscription.prototype._addError$2.call(this, error, stackTrace);
    },
    _onPause$0: [function() {
      var t1 = this._async$_subscription;
      if (t1 == null)
        return;
      t1.pause$0();
    }, "call$0", "get$_onPause", 0, 0, 12],
    _onResume$0: [function() {
      var t1 = this._async$_subscription;
      if (t1 == null)
        return;
      t1.resume$0();
    }, "call$0", "get$_onResume", 0, 0, 12],
    _onCancel$0: function() {
      var t1 = this._async$_subscription;
      if (t1 != null) {
        this._async$_subscription = null;
        t1.cancel$0();
      }
      return;
    },
    _handleData$1: [function(data) {
      this._async$_stream._handleData$2(data, this);
    }, "call$1", "get$_handleData", 2, 0, function() {
      return H.computeSignature(function(S, T) {
        return {func: "void__S", void: true, args: [S]};
      }, this.$receiver, "_ForwardingStreamSubscription");
    }, 72],
    _handleError$2: [function(error, stackTrace) {
      this._async$_stream._handleError$3(error, stackTrace, this);
    }, "call$2", "get$_handleError", 4, 0, 78, 17, 18],
    _handleDone$0: [function() {
      this._close$0();
    }, "call$0", "get$_handleDone", 0, 0, 12],
    _ForwardingStreamSubscription$5: function(_stream, onData, onError, onDone, cancelOnError, $S, $T) {
      var t1, t2;
      t1 = this.get$_handleData();
      t2 = this.get$_handleError();
      this._async$_subscription = this._async$_stream._async$_source.listen$3$onDone$onError(t1, this.get$_handleDone(), t2);
    },
    $as_BufferingStreamSubscription: function($S, $T) {
      return [$T];
    },
    static: {_ForwardingStreamSubscription$: function(_stream, onData, onError, onDone, cancelOnError, $S, $T) {
        var t1, t2;
        t1 = $.Zone__current;
        t2 = cancelOnError ? 1 : 0;
        t2 = H.setRuntimeTypeInfo(new P._ForwardingStreamSubscription(_stream, null, null, null, null, t1, t2, null, null), [$S, $T]);
        t2._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, $T);
        t2._ForwardingStreamSubscription$5(_stream, onData, onError, onDone, cancelOnError, $S, $T);
        return t2;
      }}
  },
  _ExpandStream: {
    "^": "_ForwardingStream;_expand,_async$_source",
    _expand$1: function(arg0) {
      return this._expand.call$1(arg0);
    },
    _handleData$2: function(inputEvent, sink) {
      var value, e, s, t1, exception;
      try {
        for (t1 = J.get$iterator$ax(this._expand$1(inputEvent)); t1.moveNext$0();) {
          value = t1.get$current();
          sink._async$_add$1(value);
        }
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        sink._addError$2(e, s);
      }

    }
  },
  _HandleErrorStream: {
    "^": "_ForwardingStream;_transform,_test,_async$_source",
    _handleError$3: function(error, stackTrace, sink) {
      var matches, e, s, exception, t1, t2;
      matches = true;
      if (matches === true)
        try {
          P._invokeErrorHandler(this._transform, error, stackTrace);
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = new H._StackTrace(exception, null);
          t1 = e;
          t2 = error;
          if (t1 == null ? t2 == null : t1 === t2)
            sink._addError$2(error, stackTrace);
          else
            sink._addError$2(e, s);
          return;
        }

      else
        sink._addError$2(error, stackTrace);
    },
    $as_ForwardingStream: function($T) {
      return [$T, $T];
    },
    $asStream: null
  },
  _SkipStream: {
    "^": "_ForwardingStream;_remaining,_async$_source",
    _handleData$2: function(inputEvent, sink) {
      var t1 = this._remaining;
      if (t1 > 0) {
        this._remaining = t1 - 1;
        return;
      }
      sink._async$_add$1(inputEvent);
    },
    _SkipStream$2: function(source, count, $T) {
      if (typeof count !== "number" || Math.floor(count) !== count || count < 0)
        throw H.wrapException(P.ArgumentError$(count));
    },
    $as_ForwardingStream: function($T) {
      return [$T, $T];
    },
    $asStream: null
  },
  _EventSinkWrapper: {
    "^": "Object;_async$_sink",
    add$1: [function(_, data) {
      var t1 = this._async$_sink;
      if ((t1._state & 2) !== 0)
        H.throwExpression(P.StateError$("Stream is already closed"));
      P._BufferingStreamSubscription.prototype._async$_add$1.call(t1, data);
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "void__T0", void: true, args: [T]};
      }, this.$receiver, "_EventSinkWrapper");
    }],
    addError$2: function(error, stackTrace) {
      var t1 = this._async$_sink;
      if ((t1._state & 2) !== 0)
        H.throwExpression(P.StateError$("Stream is already closed"));
      P._BufferingStreamSubscription.prototype._addError$2.call(t1, error, stackTrace);
    },
    close$0: function() {
      var t1 = this._async$_sink;
      if ((t1._state & 2) !== 0)
        H.throwExpression(P.StateError$("Stream is already closed"));
      P._BufferingStreamSubscription.prototype._close$0.call(t1);
    }
  },
  _SinkTransformerStreamSubscription: {
    "^": "_BufferingStreamSubscription;_transformerSink,_async$_subscription,_onData,_onError,_onDone,_zone,_state,_cancelFuture,_pending",
    _async$_add$1: function(data) {
      if ((this._state & 2) !== 0)
        throw H.wrapException(P.StateError$("Stream is already closed"));
      P._BufferingStreamSubscription.prototype._async$_add$1.call(this, data);
    },
    _addError$2: function(error, stackTrace) {
      if ((this._state & 2) !== 0)
        throw H.wrapException(P.StateError$("Stream is already closed"));
      P._BufferingStreamSubscription.prototype._addError$2.call(this, error, stackTrace);
    },
    _onPause$0: [function() {
      var t1 = this._async$_subscription;
      if (t1 != null)
        t1.pause$0();
    }, "call$0", "get$_onPause", 0, 0, 12],
    _onResume$0: [function() {
      var t1 = this._async$_subscription;
      if (t1 != null)
        t1.resume$0();
    }, "call$0", "get$_onResume", 0, 0, 12],
    _onCancel$0: function() {
      var t1 = this._async$_subscription;
      if (t1 != null) {
        this._async$_subscription = null;
        t1.cancel$0();
      }
      return;
    },
    _handleData$1: [function(data) {
      var e, s, exception, t1;
      try {
        J.add$1$ax(this._transformerSink, data);
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        if ((this._state & 2) !== 0)
          H.throwExpression(P.StateError$("Stream is already closed"));
        P._BufferingStreamSubscription.prototype._addError$2.call(this, e, s);
      }

    }, "call$1", "get$_handleData", 2, 0, function() {
      return H.computeSignature(function(S, T) {
        return {func: "void__S0", void: true, args: [S]};
      }, this.$receiver, "_SinkTransformerStreamSubscription");
    }, 72],
    _handleError$2: [function(error, stackTrace) {
      var e, s, exception, t1, t2;
      try {
        this._transformerSink.addError$2(error, stackTrace);
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        t1 = e;
        t2 = error;
        if (t1 == null ? t2 == null : t1 === t2) {
          if ((this._state & 2) !== 0)
            H.throwExpression(P.StateError$("Stream is already closed"));
          P._BufferingStreamSubscription.prototype._addError$2.call(this, error, stackTrace);
        } else {
          if ((this._state & 2) !== 0)
            H.throwExpression(P.StateError$("Stream is already closed"));
          P._BufferingStreamSubscription.prototype._addError$2.call(this, e, s);
        }
      }

    }, function(error) {
      return this._handleError$2(error, null);
    }, "_handleError$1", "call$2", "call$1", "get$_handleError", 2, 2, 79, 16, 17, 18],
    _handleDone$0: [function() {
      var e, s, exception, t1;
      try {
        this._async$_subscription = null;
        this._transformerSink.close$0();
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        if ((this._state & 2) !== 0)
          H.throwExpression(P.StateError$("Stream is already closed"));
        P._BufferingStreamSubscription.prototype._addError$2.call(this, e, s);
      }

    }, "call$0", "get$_handleDone", 0, 0, 12],
    _SinkTransformerStreamSubscription$6: function(source, mapper, onData, onError, onDone, cancelOnError, $S, $T) {
      var t1, t2;
      this._transformerSink = mapper.call$1(H.setRuntimeTypeInfo(new P._EventSinkWrapper(this), [$T]));
      t1 = this.get$_handleData();
      t2 = this.get$_handleError();
      this._async$_subscription = source.listen$3$onDone$onError(t1, this.get$_handleDone(), t2);
    },
    $as_BufferingStreamSubscription: function($S, $T) {
      return [$T];
    }
  },
  _BoundSinkStream: {
    "^": "Stream;_sinkMapper,_async$_stream",
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var t1, t2, subscription;
      cancelOnError = true === cancelOnError;
      t1 = $.Zone__current;
      t2 = cancelOnError ? 1 : 0;
      subscription = H.setRuntimeTypeInfo(new P._SinkTransformerStreamSubscription(null, null, null, null, null, t1, t2, null, null), [null, null]);
      subscription._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, null);
      subscription._SinkTransformerStreamSubscription$6(this._async$_stream, this._sinkMapper, onData, onError, onDone, cancelOnError, null, null);
      return subscription;
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    listen$1: function(onData) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
    },
    $asStream: function($S, $T) {
      return [$T];
    }
  },
  Timer: {
    "^": "Object;"
  },
  _ZoneFunction: {
    "^": "Object;zone,$function"
  },
  ZoneSpecification: {
    "^": "Object;"
  },
  _ZoneSpecification: {
    "^": "Object;handleUncaughtError,run,runUnary,runBinary,registerCallback,registerUnaryCallback,registerBinaryCallback,scheduleMicrotask,createTimer,createPeriodicTimer,print,fork",
    handleUncaughtError$2: function(arg0, arg1) {
      return this.handleUncaughtError.call$2(arg0, arg1);
    },
    handleUncaughtError$3: function(arg0, arg1, arg2) {
      return this.handleUncaughtError.call$3(arg0, arg1, arg2);
    },
    run$1: function(arg0) {
      return this.run.call$1(arg0);
    },
    runUnary$2: function(arg0, arg1) {
      return this.runUnary.call$2(arg0, arg1);
    },
    runBinary$3: function(arg0, arg1, arg2) {
      return this.runBinary.call$3(arg0, arg1, arg2);
    },
    registerCallback$1: function(arg0) {
      return this.registerCallback.call$1(arg0);
    },
    registerUnaryCallback$1: function(arg0) {
      return this.registerUnaryCallback.call$1(arg0);
    },
    registerBinaryCallback$1: function(arg0) {
      return this.registerBinaryCallback.call$1(arg0);
    },
    scheduleMicrotask$1: function(arg0) {
      return this.scheduleMicrotask.call$1(arg0);
    },
    createTimer$2: function(arg0, arg1) {
      return this.createTimer.call$2(arg0, arg1);
    },
    createPeriodicTimer$2: function(arg0, arg1) {
      return this.createPeriodicTimer.call$2(arg0, arg1);
    },
    print$1: function(arg0) {
      return this.print.call$1(arg0);
    },
    fork$2$specification$zoneValues: function(arg0, arg1) {
      return this.fork.call$2$specification$zoneValues(arg0, arg1);
    },
    $is_ZoneSpecification: true
  },
  ZoneDelegate: {
    "^": "Object;"
  },
  Zone: {
    "^": "Object;"
  },
  _ZoneDelegate: {
    "^": "Object;_delegationTarget",
    handleUncaughtError$3: function(zone, error, stackTrace) {
      var implementation, implZone;
      implementation = this._delegationTarget.get$_handleUncaughtError();
      implZone = implementation.zone;
      return implementation.$function.call$5(implZone, P._parentDelegate(implZone), zone, error, stackTrace);
    }
  },
  _Zone: {
    "^": "Object;",
    inSameErrorZone$1: function(otherZone) {
      return this.get$errorZone() === otherZone.get$errorZone();
    },
    $is_Zone: true
  },
  _CustomZone: {
    "^": "_Zone;_runUnary<,_async$_run<,_runBinary<,_registerCallback<,_registerUnaryCallback<,_registerBinaryCallback<,_scheduleMicrotask<,_createTimer<,_createPeriodicTimer<,_print<,_fork<,_handleUncaughtError<,_delegateCache,parent<,_async$_map<",
    get$_delegate: function() {
      var t1 = this._delegateCache;
      if (t1 != null)
        return t1;
      t1 = new P._ZoneDelegate(this);
      this._delegateCache = t1;
      return t1;
    },
    get$errorZone: function() {
      return this._handleUncaughtError.zone;
    },
    runGuarded$1: function(f) {
      var e, s, t1, exception;
      try {
        t1 = this.run$1(f);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        return this.handleUncaughtError$2(e, s);
      }

    },
    runUnaryGuarded$2: function(f, arg) {
      var e, s, t1, exception;
      try {
        t1 = this.runUnary$2(f, arg);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        return this.handleUncaughtError$2(e, s);
      }

    },
    runBinaryGuarded$3: function(f, arg1, arg2) {
      var e, s, t1, exception;
      try {
        t1 = this.runBinary$3(f, arg1, arg2);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        return this.handleUncaughtError$2(e, s);
      }

    },
    bindCallback$2$runGuarded: function(f, runGuarded) {
      var registered = this.registerCallback$1(f);
      if (runGuarded)
        return new P._CustomZone_bindCallback_closure(this, registered);
      else
        return new P._CustomZone_bindCallback_closure0(this, registered);
    },
    bindCallback$1: function(f) {
      return this.bindCallback$2$runGuarded(f, true);
    },
    bindUnaryCallback$2$runGuarded: function(f, runGuarded) {
      var registered = this.registerUnaryCallback$1(f);
      if (runGuarded)
        return new P._CustomZone_bindUnaryCallback_closure(this, registered);
      else
        return new P._CustomZone_bindUnaryCallback_closure0(this, registered);
    },
    bindUnaryCallback$1: function(f) {
      return this.bindUnaryCallback$2$runGuarded(f, true);
    },
    $index: function(_, key) {
      var t1, result, t2, value;
      t1 = this._async$_map;
      result = t1.$index(0, key);
      if (result != null || t1.containsKey$1(key))
        return result;
      t2 = this.parent;
      if (t2 != null) {
        value = J.$index$asx(t2, key);
        if (value != null)
          t1.$indexSet(0, key, value);
        return value;
      }
      return;
    },
    handleUncaughtError$2: function(error, stackTrace) {
      var implementation, t1, parentDelegate;
      implementation = this._handleUncaughtError;
      t1 = implementation.zone;
      parentDelegate = P._parentDelegate(t1);
      return implementation.$function.call$5(t1, parentDelegate, this, error, stackTrace);
    },
    fork$2$specification$zoneValues: function(specification, zoneValues) {
      var implementation, t1, parentDelegate;
      implementation = this._fork;
      t1 = implementation.zone;
      parentDelegate = P._parentDelegate(t1);
      return implementation.$function.call$5(t1, parentDelegate, this, specification, zoneValues);
    },
    run$1: function(f) {
      var implementation, t1, parentDelegate;
      implementation = this._async$_run;
      t1 = implementation.zone;
      parentDelegate = P._parentDelegate(t1);
      return implementation.$function.call$4(t1, parentDelegate, this, f);
    },
    runUnary$2: function(f, arg) {
      var implementation, t1, parentDelegate;
      implementation = this._runUnary;
      t1 = implementation.zone;
      parentDelegate = P._parentDelegate(t1);
      return implementation.$function.call$5(t1, parentDelegate, this, f, arg);
    },
    runBinary$3: function(f, arg1, arg2) {
      var implementation, t1, parentDelegate;
      implementation = this._runBinary;
      t1 = implementation.zone;
      parentDelegate = P._parentDelegate(t1);
      return implementation.$function.call$6(t1, parentDelegate, this, f, arg1, arg2);
    },
    registerCallback$1: function(f) {
      var implementation, t1, parentDelegate;
      implementation = this._registerCallback;
      t1 = implementation.zone;
      parentDelegate = P._parentDelegate(t1);
      return implementation.$function.call$4(t1, parentDelegate, this, f);
    },
    registerUnaryCallback$1: function(f) {
      var implementation, t1, parentDelegate;
      implementation = this._registerUnaryCallback;
      t1 = implementation.zone;
      parentDelegate = P._parentDelegate(t1);
      return implementation.$function.call$4(t1, parentDelegate, this, f);
    },
    registerBinaryCallback$1: function(f) {
      var implementation, t1, parentDelegate;
      implementation = this._registerBinaryCallback;
      t1 = implementation.zone;
      parentDelegate = P._parentDelegate(t1);
      return implementation.$function.call$4(t1, parentDelegate, this, f);
    },
    scheduleMicrotask$1: function(f) {
      var implementation, t1, parentDelegate;
      implementation = this._scheduleMicrotask;
      t1 = implementation.zone;
      parentDelegate = P._parentDelegate(t1);
      return implementation.$function.call$4(t1, parentDelegate, this, f);
    },
    createTimer$2: function(duration, f) {
      var implementation, t1, parentDelegate;
      implementation = this._createTimer;
      t1 = implementation.zone;
      parentDelegate = P._parentDelegate(t1);
      return implementation.$function.call$5(t1, parentDelegate, this, duration, f);
    },
    createPeriodicTimer$2: function(duration, f) {
      var implementation, t1, parentDelegate;
      implementation = this._createPeriodicTimer;
      t1 = implementation.zone;
      parentDelegate = P._parentDelegate(t1);
      return implementation.$function.call$5(t1, parentDelegate, this, duration, f);
    },
    print$1: function(line) {
      var implementation, t1, parentDelegate;
      implementation = this._print;
      t1 = implementation.zone;
      parentDelegate = P._parentDelegate(t1);
      return implementation.$function.call$4(t1, parentDelegate, this, line);
    },
    _CustomZone$3: function($parent, specification, _map) {
      var t1;
      this._async$_run = this.parent.get$_async$_run();
      this._runUnary = this.parent.get$_runUnary();
      this._runBinary = this.parent.get$_runBinary();
      this._registerCallback = this.parent.get$_registerCallback();
      this._registerUnaryCallback = this.parent.get$_registerUnaryCallback();
      this._registerBinaryCallback = this.parent.get$_registerBinaryCallback();
      this._scheduleMicrotask = this.parent.get$_scheduleMicrotask();
      this._createTimer = this.parent.get$_createTimer();
      this._createPeriodicTimer = this.parent.get$_createPeriodicTimer();
      this._print = this.parent.get$_print();
      this._fork = this.parent.get$_fork();
      t1 = specification.handleUncaughtError;
      this._handleUncaughtError = t1 != null ? new P._ZoneFunction(this, t1) : this.parent.get$_handleUncaughtError();
    }
  },
  _CustomZone_bindCallback_closure: {
    "^": "Closure:55;this_0,registered_1",
    call$0: [function() {
      return this.this_0.runGuarded$1(this.registered_1);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _CustomZone_bindCallback_closure0: {
    "^": "Closure:55;this_2,registered_3",
    call$0: [function() {
      return this.this_2.run$1(this.registered_3);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _CustomZone_bindUnaryCallback_closure: {
    "^": "Closure:58;this_0,registered_1",
    call$1: [function(arg) {
      return this.this_0.runUnaryGuarded$2(this.registered_1, arg);
    }, "call$1", null, 2, 0, null, 26, "call"],
    $isFunction: true
  },
  _CustomZone_bindUnaryCallback_closure0: {
    "^": "Closure:58;this_2,registered_3",
    call$1: [function(arg) {
      return this.this_2.runUnary$2(this.registered_3, arg);
    }, "call$1", null, 2, 0, null, 26, "call"],
    $isFunction: true
  },
  _rootHandleUncaughtError_closure: {
    "^": "Closure:55;error_0,stackTrace_1",
    call$0: function() {
      throw H.wrapException(P._UncaughtAsyncError$(this.error_0, this.stackTrace_1));
    },
    $isFunction: true
  },
  _RootZone: {
    "^": "_Zone;",
    get$_async$_run: function() {
      return C._ZoneFunction__RootZone__rootRun;
    },
    get$_runUnary: function() {
      return C._ZoneFunction__RootZone__rootRunUnary;
    },
    get$_runBinary: function() {
      return C._ZoneFunction__RootZone__rootRunBinary;
    },
    get$_registerCallback: function() {
      return C._ZoneFunction__RootZone__rootRegisterCallback;
    },
    get$_registerUnaryCallback: function() {
      return C._ZoneFunction_Eeh;
    },
    get$_registerBinaryCallback: function() {
      return C._ZoneFunction_7G2;
    },
    get$_scheduleMicrotask: function() {
      return C._ZoneFunction__RootZone__rootScheduleMicrotask;
    },
    get$_createTimer: function() {
      return C._ZoneFunction__RootZone__rootCreateTimer;
    },
    get$_createPeriodicTimer: function() {
      return C._ZoneFunction_3bB;
    },
    get$_print: function() {
      return C._ZoneFunction__RootZone__rootPrint;
    },
    get$_fork: function() {
      return C._ZoneFunction__RootZone__rootFork;
    },
    get$_handleUncaughtError: function() {
      return C._ZoneFunction_NMc;
    },
    get$parent: function() {
      return;
    },
    get$_async$_map: function() {
      return $.get$_RootZone__rootMap();
    },
    get$_delegate: function() {
      var t1 = $._RootZone__rootDelegate;
      if (t1 != null)
        return t1;
      t1 = new P._ZoneDelegate(this);
      $._RootZone__rootDelegate = t1;
      return t1;
    },
    get$errorZone: function() {
      return this;
    },
    runGuarded$1: function(f) {
      var e, s, t1, exception;
      try {
        if (C.C__RootZone === $.Zone__current) {
          t1 = f.call$0();
          return t1;
        }
        t1 = P._rootRun(null, null, this, f);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        return P._rootHandleUncaughtError(null, null, this, e, s);
      }

    },
    runUnaryGuarded$2: function(f, arg) {
      var e, s, t1, exception;
      try {
        if (C.C__RootZone === $.Zone__current) {
          t1 = f.call$1(arg);
          return t1;
        }
        t1 = P._rootRunUnary(null, null, this, f, arg);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        return P._rootHandleUncaughtError(null, null, this, e, s);
      }

    },
    runBinaryGuarded$3: function(f, arg1, arg2) {
      var e, s, t1, exception;
      try {
        if (C.C__RootZone === $.Zone__current) {
          t1 = f.call$2(arg1, arg2);
          return t1;
        }
        t1 = P._rootRunBinary(null, null, this, f, arg1, arg2);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        return P._rootHandleUncaughtError(null, null, this, e, s);
      }

    },
    bindCallback$2$runGuarded: function(f, runGuarded) {
      if (runGuarded)
        return new P._RootZone_bindCallback_closure(this, f);
      else
        return new P._RootZone_bindCallback_closure0(this, f);
    },
    bindCallback$1: function(f) {
      return this.bindCallback$2$runGuarded(f, true);
    },
    bindUnaryCallback$2$runGuarded: function(f, runGuarded) {
      if (runGuarded)
        return new P._RootZone_bindUnaryCallback_closure(this, f);
      else
        return new P._RootZone_bindUnaryCallback_closure0(this, f);
    },
    bindUnaryCallback$1: function(f) {
      return this.bindUnaryCallback$2$runGuarded(f, true);
    },
    $index: function(_, key) {
      return;
    },
    handleUncaughtError$2: function(error, stackTrace) {
      return P._rootHandleUncaughtError(null, null, this, error, stackTrace);
    },
    fork$2$specification$zoneValues: function(specification, zoneValues) {
      return P._rootFork(null, null, this, specification, zoneValues);
    },
    run$1: function(f) {
      if ($.Zone__current === C.C__RootZone)
        return f.call$0();
      return P._rootRun(null, null, this, f);
    },
    runUnary$2: function(f, arg) {
      if ($.Zone__current === C.C__RootZone)
        return f.call$1(arg);
      return P._rootRunUnary(null, null, this, f, arg);
    },
    runBinary$3: function(f, arg1, arg2) {
      if ($.Zone__current === C.C__RootZone)
        return f.call$2(arg1, arg2);
      return P._rootRunBinary(null, null, this, f, arg1, arg2);
    },
    registerCallback$1: function(f) {
      return f;
    },
    registerUnaryCallback$1: function(f) {
      return f;
    },
    registerBinaryCallback$1: function(f) {
      return f;
    },
    scheduleMicrotask$1: function(f) {
      P._rootScheduleMicrotask(null, null, this, f);
    },
    createTimer$2: function(duration, f) {
      return P.Timer__createTimer(duration, f);
    },
    createPeriodicTimer$2: function(duration, f) {
      return P.Timer__createPeriodicTimer(duration, f);
    },
    print$1: function(line) {
      H.printString(line);
    },
    static: {"^": "_RootZone__rootMap,_RootZone__rootDelegate"}
  },
  _RootZone_bindCallback_closure: {
    "^": "Closure:55;this_0,f_1",
    call$0: [function() {
      return this.this_0.runGuarded$1(this.f_1);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _RootZone_bindCallback_closure0: {
    "^": "Closure:55;this_2,f_3",
    call$0: [function() {
      return this.this_2.run$1(this.f_3);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _RootZone_bindUnaryCallback_closure: {
    "^": "Closure:58;this_0,f_1",
    call$1: [function(arg) {
      return this.this_0.runUnaryGuarded$2(this.f_1, arg);
    }, "call$1", null, 2, 0, null, 26, "call"],
    $isFunction: true
  },
  _RootZone_bindUnaryCallback_closure0: {
    "^": "Closure:58;this_2,f_3",
    call$1: [function(arg) {
      return this.this_2.runUnary$2(this.f_3, arg);
    }, "call$1", null, 2, 0, null, 26, "call"],
    $isFunction: true
  },
  runZoned_closure: {
    "^": "Closure:80;onError_0",
    call$5: [function($self, $parent, zone, error, stackTrace) {
      var e, s, t1, t2, exception;
      try {
        t1 = this.onError_0;
        t2 = H.getDynamicRuntimeType();
        t2 = H.buildFunctionType(t2, [t2, t2])._isTest$1(t1);
        if (t2) {
          t1 = $self.get$parent().runBinary$3(t1, error, stackTrace);
          return t1;
        }
        t1 = $self.get$parent().runUnary$2(t1, error);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        t1 = e;
        t2 = error;
        if (t1 == null ? t2 == null : t1 === t2)
          return $parent.handleUncaughtError$3(zone, error, stackTrace);
        else
          return $parent.handleUncaughtError$3(zone, e, s);
      }

    }, "call$5", null, 10, 0, null, 20, 21, 22, 17, 18, "call"],
    $isFunction: true
  }
}],
["dart.collection", "dart:collection", , P, {
  "^": "",
  LinkedHashMap_LinkedHashMap$_literal: function(keyValuePairs, $K, $V) {
    return H.fillLiteralMap(keyValuePairs, H.setRuntimeTypeInfo(new P._LinkedHashMap(0, null, null, null, null, null, 0), [$K, $V]));
  },
  LinkedHashMap_LinkedHashMap$_empty: function($K, $V) {
    return H.setRuntimeTypeInfo(new P._LinkedHashMap(0, null, null, null, null, null, 0), [$K, $V]);
  },
  _defaultEquals: [function(a, b) {
    return J.$eq(a, b);
  }, "call$2", "_defaultEquals$closure", 4, 0, 42, 43, 44],
  _defaultHashCode: [function(a) {
    return J.get$hashCode$(a);
  }, "call$1", "_defaultHashCode$closure", 2, 0, 45, 43],
  HashMap_HashMap: function(equals, hashCode, isValidKey, $K, $V) {
    return H.setRuntimeTypeInfo(new P._HashMap(0, null, null, null, null), [$K, $V]);
  },
  HashSet_HashSet: function(equals, hashCode, isValidKey, $E) {
    return H.setRuntimeTypeInfo(new P._HashSet(0, null, null, null, null), [$E]);
  },
  IterableBase_iterableToShortString: function(iterable, leftDelimiter, rightDelimiter) {
    var parts, t1;
    if (P.IterableBase__isToStringVisiting(iterable)) {
      if (leftDelimiter === "(" && rightDelimiter === ")")
        return "(...)";
      return leftDelimiter + "..." + rightDelimiter;
    }
    parts = [];
    t1 = $.get$IterableBase__toStringVisiting();
    t1.push(iterable);
    try {
      P.IterableBase__iterablePartsToStrings(iterable, parts);
    } finally {
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    }
    t1 = P.StringBuffer$(leftDelimiter);
    t1.writeAll$2(parts, ", ");
    t1.write$1(rightDelimiter);
    return t1._contents;
  },
  IterableBase_iterableToFullString: function(iterable, leftDelimiter, rightDelimiter) {
    var buffer, t1;
    if (P.IterableBase__isToStringVisiting(iterable))
      return leftDelimiter + "..." + rightDelimiter;
    buffer = P.StringBuffer$(leftDelimiter);
    t1 = $.get$IterableBase__toStringVisiting();
    t1.push(iterable);
    try {
      buffer.writeAll$2(iterable, ", ");
    } finally {
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    }
    buffer.write$1(rightDelimiter);
    return buffer.get$_contents();
  },
  IterableBase__isToStringVisiting: function(o) {
    var i, t1;
    for (i = 0; t1 = $.get$IterableBase__toStringVisiting(), i < t1.length; ++i) {
      t1 = t1[i];
      if (o == null ? t1 == null : o === t1)
        return true;
    }
    return false;
  },
  IterableBase__iterablePartsToStrings: function(iterable, parts) {
    var it, $length, count, next, ultimateString, penultimateString, penultimate, ultimate, ultimate0, elision;
    it = iterable.get$iterator(iterable);
    $length = 0;
    count = 0;
    while (true) {
      if (!($length < 80 || count < 3))
        break;
      if (!it.moveNext$0())
        return;
      next = H.S(it.get$current());
      parts.push(next);
      $length += next.length + 2;
      ++count;
    }
    if (!it.moveNext$0()) {
      if (count <= 5)
        return;
      if (0 >= parts.length)
        return H.ioore(parts, 0);
      ultimateString = parts.pop();
      if (0 >= parts.length)
        return H.ioore(parts, 0);
      penultimateString = parts.pop();
    } else {
      penultimate = it.get$current();
      ++count;
      if (!it.moveNext$0()) {
        if (count <= 4) {
          parts.push(H.S(penultimate));
          return;
        }
        ultimateString = H.S(penultimate);
        if (0 >= parts.length)
          return H.ioore(parts, 0);
        penultimateString = parts.pop();
        $length += ultimateString.length + 2;
      } else {
        ultimate = it.get$current();
        ++count;
        for (; it.moveNext$0(); penultimate = ultimate, ultimate = ultimate0) {
          ultimate0 = it.get$current();
          ++count;
          if (count > 100) {
            while (true) {
              if (!($length > 75 && count > 3))
                break;
              if (0 >= parts.length)
                return H.ioore(parts, 0);
              $length -= parts.pop().length + 2;
              --count;
            }
            parts.push("...");
            return;
          }
        }
        penultimateString = H.S(penultimate);
        ultimateString = H.S(ultimate);
        $length += ultimateString.length + penultimateString.length + 4;
      }
    }
    if (count > parts.length + 2) {
      $length += 5;
      elision = "...";
    } else
      elision = null;
    while (true) {
      if (!($length > 80 && parts.length > 3))
        break;
      if (0 >= parts.length)
        return H.ioore(parts, 0);
      $length -= parts.pop().length + 2;
      if (elision == null) {
        $length += 5;
        elision = "...";
      }
    }
    if (elision != null)
      parts.push(elision);
    parts.push(penultimateString);
    parts.push(ultimateString);
  },
  LinkedHashMap_LinkedHashMap: function(equals, hashCode, isValidKey, $K, $V) {
    return H.setRuntimeTypeInfo(new P._LinkedHashMap(0, null, null, null, null, null, 0), [$K, $V]);
  },
  LinkedHashSet_LinkedHashSet: function(equals, hashCode, isValidKey, $E) {
    return H.setRuntimeTypeInfo(new P._LinkedHashSet(0, null, null, null, null, null, 0), [$E]);
  },
  Maps_mapToString: function(m) {
    var t1, result;
    t1 = {};
    if (P.IterableBase__isToStringVisiting(m))
      return "{...}";
    result = P.StringBuffer$("");
    try {
      $.get$IterableBase__toStringVisiting().push(m);
      result.write$1("{");
      t1.first_0 = true;
      J.forEach$1$ax(m, new P.Maps_mapToString_closure(t1, result));
      result.write$1("}");
    } finally {
      t1 = $.get$IterableBase__toStringVisiting();
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    }
    return result.get$_contents();
  },
  _HashMap: {
    "^": "Object;_collection$_length,_strings,_nums,_rest,_keys",
    get$length: function(_) {
      return this._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    get$isNotEmpty: function(_) {
      return this._collection$_length !== 0;
    },
    get$keys: function() {
      return H.setRuntimeTypeInfo(new P.HashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]);
    },
    get$values: function() {
      return H.MappedIterable_MappedIterable(H.setRuntimeTypeInfo(new P.HashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]), new P._HashMap_values_closure(this), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
    },
    containsKey$1: function(key) {
      var strings, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        return strings == null ? false : strings[key] != null;
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        return nums == null ? false : nums[key] != null;
      } else
        return this._containsKey$1(key);
    },
    _containsKey$1: function(key) {
      var rest = this._rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(rest[this._computeHashCode$1(key)], key) >= 0;
    },
    addAll$1: function(_, other) {
      J.forEach$1$ax(other, new P._HashMap_addAll_closure(this));
    },
    $index: function(_, key) {
      var strings, t1, entry, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          t1 = null;
        else {
          entry = strings[key];
          t1 = entry === strings ? null : entry;
        }
        return t1;
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null)
          t1 = null;
        else {
          entry = nums[key];
          t1 = entry === nums ? null : entry;
        }
        return t1;
      } else
        return this._get$1(key);
    },
    _get$1: function(key) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(key)];
      index = this._findBucketIndex$2(bucket, key);
      return index < 0 ? null : bucket[index + 1];
    },
    $indexSet: function(_, key, value) {
      var strings, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null) {
          strings = P._HashMap__newHashTable();
          this._strings = strings;
        }
        this._addHashTableEntry$3(strings, key, value);
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null) {
          nums = P._HashMap__newHashTable();
          this._nums = nums;
        }
        this._addHashTableEntry$3(nums, key, value);
      } else
        this._collection$_set$2(key, value);
    },
    _collection$_set$2: function(key, value) {
      var rest, hash, bucket, index;
      rest = this._rest;
      if (rest == null) {
        rest = P._HashMap__newHashTable();
        this._rest = rest;
      }
      hash = this._computeHashCode$1(key);
      bucket = rest[hash];
      if (bucket == null) {
        P._HashMap__setTableEntry(rest, hash, [key, value]);
        ++this._collection$_length;
        this._keys = null;
      } else {
        index = this._findBucketIndex$2(bucket, key);
        if (index >= 0)
          bucket[index + 1] = value;
        else {
          bucket.push(key, value);
          ++this._collection$_length;
          this._keys = null;
        }
      }
    },
    putIfAbsent$2: function(key, ifAbsent) {
      var value;
      if (this.containsKey$1(key))
        return this.$index(0, key);
      value = ifAbsent.call$0();
      this.$indexSet(0, key, value);
      return value;
    },
    remove$1: function(_, key) {
      if (typeof key === "string" && key !== "__proto__")
        return this._removeHashTableEntry$2(this._strings, key);
      else if (typeof key === "number" && (key & 0x3ffffff) === key)
        return this._removeHashTableEntry$2(this._nums, key);
      else
        return this._remove$1(key);
    },
    _remove$1: function(key) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(key)];
      index = this._findBucketIndex$2(bucket, key);
      if (index < 0)
        return;
      --this._collection$_length;
      this._keys = null;
      return bucket.splice(index, 2)[1];
    },
    forEach$1: function(_, action) {
      var keys, $length, i, key;
      keys = this._computeKeys$0();
      for ($length = keys.length, i = 0; i < $length; ++i) {
        key = keys[i];
        action.call$2(key, this.$index(0, key));
        if (keys !== this._keys)
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
    },
    _computeKeys$0: function() {
      var t1, result, strings, names, entries, index, i, nums, rest, bucket, $length, i0;
      t1 = this._keys;
      if (t1 != null)
        return t1;
      result = Array(this._collection$_length);
      result.fixed$length = init;
      strings = this._strings;
      if (strings != null) {
        names = Object.getOwnPropertyNames(strings);
        entries = names.length;
        for (index = 0, i = 0; i < entries; ++i) {
          result[index] = names[i];
          ++index;
        }
      } else
        index = 0;
      nums = this._nums;
      if (nums != null) {
        names = Object.getOwnPropertyNames(nums);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          result[index] = +names[i];
          ++index;
        }
      }
      rest = this._rest;
      if (rest != null) {
        names = Object.getOwnPropertyNames(rest);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          bucket = rest[names[i]];
          $length = bucket.length;
          for (i0 = 0; i0 < $length; i0 += 2) {
            result[index] = bucket[i0];
            ++index;
          }
        }
      }
      this._keys = result;
      return result;
    },
    _addHashTableEntry$3: function(table, key, value) {
      if (table[key] == null) {
        ++this._collection$_length;
        this._keys = null;
      }
      P._HashMap__setTableEntry(table, key, value);
    },
    _removeHashTableEntry$2: function(table, key) {
      var value;
      if (table != null && table[key] != null) {
        value = P._HashMap__getTableEntry(table, key);
        delete table[key];
        --this._collection$_length;
        this._keys = null;
        return value;
      } else
        return;
    },
    _computeHashCode$1: function(key) {
      return J.get$hashCode$(key) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, key) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; i += 2)
        if (J.$eq(bucket[i], key))
          return i;
      return -1;
    },
    $isMap: true,
    static: {_HashMap__getTableEntry: function(table, key) {
        var entry = table[key];
        return entry === table ? null : entry;
      }, _HashMap__setTableEntry: function(table, key, value) {
        if (value == null)
          table[key] = table;
        else
          table[key] = value;
      }, _HashMap__newHashTable: function() {
        var table = Object.create(null);
        P._HashMap__setTableEntry(table, "<non-identifier-key>", table);
        delete table["<non-identifier-key>"];
        return table;
      }}
  },
  _HashMap_values_closure: {
    "^": "Closure:58;this_0",
    call$1: [function(each) {
      return this.this_0.$index(0, each);
    }, "call$1", null, 2, 0, null, 81, "call"],
    $isFunction: true
  },
  _HashMap_addAll_closure: {
    "^": "Closure;this_0",
    call$2: [function(key, value) {
      this.this_0.$indexSet(0, key, value);
    }, "call$2", null, 4, 0, null, 82, 14, "call"],
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(K, V) {
        return {func: "dynamic__K_V", args: [K, V]};
      }, this.this_0, "_HashMap");
    }
  },
  HashMapKeyIterable: {
    "^": "IterableBase;_map",
    get$length: function(_) {
      return this._map._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._map._collection$_length === 0;
    },
    get$iterator: function(_) {
      var t1 = this._map;
      t1 = new P.HashMapKeyIterator(t1, t1._computeKeys$0(), 0, null);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    contains$1: function(_, element) {
      return this._map.containsKey$1(element);
    },
    forEach$1: function(_, f) {
      var t1, keys, $length, i;
      t1 = this._map;
      keys = t1._computeKeys$0();
      for ($length = keys.length, i = 0; i < $length; ++i) {
        f.call$1(keys[i]);
        if (keys !== t1._keys)
          throw H.wrapException(P.ConcurrentModificationError$(t1));
      }
    },
    $isEfficientLength: true
  },
  HashMapKeyIterator: {
    "^": "Object;_map,_keys,_offset,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var keys, offset, t1;
      keys = this._keys;
      offset = this._offset;
      t1 = this._map;
      if (keys !== t1._keys)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else if (offset >= keys.length) {
        this._collection$_current = null;
        return false;
      } else {
        this._collection$_current = keys[offset];
        this._offset = offset + 1;
        return true;
      }
    }
  },
  _LinkedHashMap: {
    "^": "Object;_collection$_length,_strings,_nums,_rest,_first,_last,_modifications",
    get$length: function(_) {
      return this._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    get$isNotEmpty: function(_) {
      return this._collection$_length !== 0;
    },
    get$keys: function() {
      return H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]);
    },
    get$values: function() {
      return H.MappedIterable_MappedIterable(H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]), new P._LinkedHashMap_values_closure(this), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
    },
    containsKey$1: function(key) {
      var strings, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          return false;
        return strings[key] != null;
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null)
          return false;
        return nums[key] != null;
      } else
        return this._containsKey$1(key);
    },
    _containsKey$1: function(key) {
      var rest = this._rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(rest[this._computeHashCode$1(key)], key) >= 0;
    },
    $index: function(_, key) {
      var strings, cell, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          return;
        cell = strings[key];
        return cell == null ? null : cell.get$_collection$_value();
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null)
          return;
        cell = nums[key];
        return cell == null ? null : cell.get$_collection$_value();
      } else
        return this._get$1(key);
    },
    _get$1: function(key) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(key)];
      index = this._findBucketIndex$2(bucket, key);
      if (index < 0)
        return;
      return bucket[index].get$_collection$_value();
    },
    $indexSet: function(_, key, value) {
      var strings, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null) {
          strings = P._LinkedHashMap__newHashTable();
          this._strings = strings;
        }
        this._addHashTableEntry$3(strings, key, value);
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null) {
          nums = P._LinkedHashMap__newHashTable();
          this._nums = nums;
        }
        this._addHashTableEntry$3(nums, key, value);
      } else
        this._collection$_set$2(key, value);
    },
    _collection$_set$2: function(key, value) {
      var rest, hash, bucket, index;
      rest = this._rest;
      if (rest == null) {
        rest = P._LinkedHashMap__newHashTable();
        this._rest = rest;
      }
      hash = this._computeHashCode$1(key);
      bucket = rest[hash];
      if (bucket == null)
        rest[hash] = [this._newLinkedCell$2(key, value)];
      else {
        index = this._findBucketIndex$2(bucket, key);
        if (index >= 0)
          bucket[index].set$_collection$_value(value);
        else
          bucket.push(this._newLinkedCell$2(key, value));
      }
    },
    remove$1: function(_, key) {
      if (typeof key === "string" && key !== "__proto__")
        return this._removeHashTableEntry$2(this._strings, key);
      else if (typeof key === "number" && (key & 0x3ffffff) === key)
        return this._removeHashTableEntry$2(this._nums, key);
      else
        return this._remove$1(key);
    },
    _remove$1: function(key) {
      var rest, bucket, index, cell;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(key)];
      index = this._findBucketIndex$2(bucket, key);
      if (index < 0)
        return;
      cell = bucket.splice(index, 1)[0];
      this._unlinkCell$1(cell);
      return cell.get$_collection$_value();
    },
    clear$0: function(_) {
      if (this._collection$_length > 0) {
        this._last = null;
        this._first = null;
        this._rest = null;
        this._nums = null;
        this._strings = null;
        this._collection$_length = 0;
        this._modifications = this._modifications + 1 & 67108863;
      }
    },
    forEach$1: function(_, action) {
      var cell, modifications;
      cell = this._first;
      modifications = this._modifications;
      for (; cell != null;) {
        action.call$2(cell.get$_key(), cell.get$_collection$_value());
        if (modifications !== this._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(this));
        cell = cell.get$_next();
      }
    },
    _addHashTableEntry$3: function(table, key, value) {
      var cell = table[key];
      if (cell == null)
        table[key] = this._newLinkedCell$2(key, value);
      else
        cell.set$_collection$_value(value);
    },
    _removeHashTableEntry$2: function(table, key) {
      var cell;
      if (table == null)
        return;
      cell = table[key];
      if (cell == null)
        return;
      this._unlinkCell$1(cell);
      delete table[key];
      return cell.get$_collection$_value();
    },
    _newLinkedCell$2: function(key, value) {
      var cell, last;
      cell = new P.LinkedHashMapCell(key, value, null, null);
      if (this._first == null) {
        this._last = cell;
        this._first = cell;
      } else {
        last = this._last;
        cell._previous = last;
        last.set$_next(cell);
        this._last = cell;
      }
      ++this._collection$_length;
      this._modifications = this._modifications + 1 & 67108863;
      return cell;
    },
    _unlinkCell$1: function(cell) {
      var previous, next;
      previous = cell.get$_previous();
      next = cell.get$_next();
      if (previous == null)
        this._first = next;
      else
        previous.set$_next(next);
      if (next == null)
        this._last = previous;
      else
        next.set$_previous(previous);
      --this._collection$_length;
      this._modifications = this._modifications + 1 & 67108863;
    },
    _computeHashCode$1: function(key) {
      return J.get$hashCode$(key) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, key) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq(bucket[i].get$_key(), key))
          return i;
      return -1;
    },
    toString$0: function(_) {
      return P.Maps_mapToString(this);
    },
    $isMap: true,
    static: {_LinkedHashMap__newHashTable: function() {
        var table = Object.create(null);
        table["<non-identifier-key>"] = table;
        delete table["<non-identifier-key>"];
        return table;
      }}
  },
  _LinkedHashMap_values_closure: {
    "^": "Closure:58;this_0",
    call$1: [function(each) {
      return this.this_0.$index(0, each);
    }, "call$1", null, 2, 0, null, 81, "call"],
    $isFunction: true
  },
  LinkedHashMapCell: {
    "^": "Object;_key<,_collection$_value@,_next@,_previous@"
  },
  LinkedHashMapKeyIterable: {
    "^": "IterableBase;_map",
    get$length: function(_) {
      return this._map._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._map._collection$_length === 0;
    },
    get$iterator: function(_) {
      var t1, t2;
      t1 = this._map;
      t2 = new P.LinkedHashMapKeyIterator(t1, t1._modifications, null, null);
      t2.$builtinTypeInfo = this.$builtinTypeInfo;
      t2._cell = t1._first;
      return t2;
    },
    contains$1: function(_, element) {
      return this._map.containsKey$1(element);
    },
    forEach$1: function(_, f) {
      var t1, cell, modifications;
      t1 = this._map;
      cell = t1._first;
      modifications = t1._modifications;
      for (; cell != null;) {
        f.call$1(cell.get$_key());
        if (modifications !== t1._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(t1));
        cell = cell.get$_next();
      }
    },
    $isEfficientLength: true
  },
  LinkedHashMapKeyIterator: {
    "^": "Object;_map,_modifications,_cell,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var t1 = this._map;
      if (this._modifications !== t1._modifications)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else {
        t1 = this._cell;
        if (t1 == null) {
          this._collection$_current = null;
          return false;
        } else {
          this._collection$_current = t1.get$_key();
          this._cell = this._cell.get$_next();
          return true;
        }
      }
    }
  },
  _HashSet: {
    "^": "_HashSetBase;_collection$_length,_strings,_nums,_rest,_elements",
    get$iterator: function(_) {
      var t1 = new P.HashSetIterator(this, this._computeElements$0(), 0, null);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    get$length: function(_) {
      return this._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    get$isNotEmpty: function(_) {
      return this._collection$_length !== 0;
    },
    contains$1: function(_, object) {
      var strings, nums;
      if (typeof object === "string" && object !== "__proto__") {
        strings = this._strings;
        return strings == null ? false : strings[object] != null;
      } else if (typeof object === "number" && (object & 0x3ffffff) === object) {
        nums = this._nums;
        return nums == null ? false : nums[object] != null;
      } else
        return this._contains$1(object);
    },
    _contains$1: function(object) {
      var rest = this._rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(rest[this._computeHashCode$1(object)], object) >= 0;
    },
    lookup$1: function(object) {
      var t1;
      if (!(typeof object === "string" && object !== "__proto__"))
        t1 = typeof object === "number" && (object & 0x3ffffff) === object;
      else
        t1 = true;
      if (t1)
        return this.contains$1(0, object) ? object : null;
      return this._lookup$1(object);
    },
    _lookup$1: function(object) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(object)];
      index = this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return;
      return J.$index$asx(bucket, index);
    },
    add$1: [function(_, element) {
      var strings, table, nums;
      if (typeof element === "string" && element !== "__proto__") {
        strings = this._strings;
        if (strings == null) {
          table = Object.create(null);
          table["<non-identifier-key>"] = table;
          delete table["<non-identifier-key>"];
          this._strings = table;
          strings = table;
        }
        return this._addHashTableEntry$2(strings, element);
      } else if (typeof element === "number" && (element & 0x3ffffff) === element) {
        nums = this._nums;
        if (nums == null) {
          table = Object.create(null);
          table["<non-identifier-key>"] = table;
          delete table["<non-identifier-key>"];
          this._nums = table;
          nums = table;
        }
        return this._addHashTableEntry$2(nums, element);
      } else
        return this._add$1(element);
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "bool__E", ret: P.bool, args: [E]};
      }, this.$receiver, "_HashSet");
    }],
    _add$1: function(element) {
      var rest, hash, bucket;
      rest = this._rest;
      if (rest == null) {
        rest = P._HashSet__newHashTable();
        this._rest = rest;
      }
      hash = this._computeHashCode$1(element);
      bucket = rest[hash];
      if (bucket == null)
        rest[hash] = [element];
      else {
        if (this._findBucketIndex$2(bucket, element) >= 0)
          return false;
        bucket.push(element);
      }
      ++this._collection$_length;
      this._elements = null;
      return true;
    },
    remove$1: function(_, object) {
      if (typeof object === "string" && object !== "__proto__")
        return this._removeHashTableEntry$2(this._strings, object);
      else if (typeof object === "number" && (object & 0x3ffffff) === object)
        return this._removeHashTableEntry$2(this._nums, object);
      else
        return this._remove$1(object);
    },
    _remove$1: function(object) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return false;
      bucket = rest[this._computeHashCode$1(object)];
      index = this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return false;
      --this._collection$_length;
      this._elements = null;
      bucket.splice(index, 1);
      return true;
    },
    _computeElements$0: function() {
      var t1, result, strings, names, entries, index, i, nums, rest, bucket, $length, i0;
      t1 = this._elements;
      if (t1 != null)
        return t1;
      result = Array(this._collection$_length);
      result.fixed$length = init;
      strings = this._strings;
      if (strings != null) {
        names = Object.getOwnPropertyNames(strings);
        entries = names.length;
        for (index = 0, i = 0; i < entries; ++i) {
          result[index] = names[i];
          ++index;
        }
      } else
        index = 0;
      nums = this._nums;
      if (nums != null) {
        names = Object.getOwnPropertyNames(nums);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          result[index] = +names[i];
          ++index;
        }
      }
      rest = this._rest;
      if (rest != null) {
        names = Object.getOwnPropertyNames(rest);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          bucket = rest[names[i]];
          $length = bucket.length;
          for (i0 = 0; i0 < $length; ++i0) {
            result[index] = bucket[i0];
            ++index;
          }
        }
      }
      this._elements = result;
      return result;
    },
    _addHashTableEntry$2: function(table, element) {
      if (table[element] != null)
        return false;
      table[element] = 0;
      ++this._collection$_length;
      this._elements = null;
      return true;
    },
    _removeHashTableEntry$2: function(table, element) {
      if (table != null && table[element] != null) {
        delete table[element];
        --this._collection$_length;
        this._elements = null;
        return true;
      } else
        return false;
    },
    _computeHashCode$1: function(element) {
      return J.get$hashCode$(element) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, element) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq(bucket[i], element))
          return i;
      return -1;
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: null,
    static: {_HashSet__newHashTable: function() {
        var table = Object.create(null);
        table["<non-identifier-key>"] = table;
        delete table["<non-identifier-key>"];
        return table;
      }}
  },
  HashSetIterator: {
    "^": "Object;_collection$_set,_elements,_offset,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var elements, offset, t1;
      elements = this._elements;
      offset = this._offset;
      t1 = this._collection$_set;
      if (elements !== t1._elements)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else if (offset >= elements.length) {
        this._collection$_current = null;
        return false;
      } else {
        this._collection$_current = elements[offset];
        this._offset = offset + 1;
        return true;
      }
    }
  },
  _LinkedHashSet: {
    "^": "_HashSetBase;_collection$_length,_strings,_nums,_rest,_first,_last,_modifications",
    get$iterator: function(_) {
      var t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(this, this._modifications, null, null), [null]);
      t1._cell = t1._collection$_set._first;
      return t1;
    },
    get$length: function(_) {
      return this._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    get$isNotEmpty: function(_) {
      return this._collection$_length !== 0;
    },
    contains$1: function(_, object) {
      var strings, nums;
      if (typeof object === "string" && object !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          return false;
        return strings[object] != null;
      } else if (typeof object === "number" && (object & 0x3ffffff) === object) {
        nums = this._nums;
        if (nums == null)
          return false;
        return nums[object] != null;
      } else
        return this._contains$1(object);
    },
    _contains$1: function(object) {
      var rest = this._rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(rest[this._computeHashCode$1(object)], object) >= 0;
    },
    lookup$1: function(object) {
      var t1;
      if (!(typeof object === "string" && object !== "__proto__"))
        t1 = typeof object === "number" && (object & 0x3ffffff) === object;
      else
        t1 = true;
      if (t1)
        return this.contains$1(0, object) ? object : null;
      else
        return this._lookup$1(object);
    },
    _lookup$1: function(object) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(object)];
      index = this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return;
      return J.$index$asx(bucket, index).get$_element();
    },
    forEach$1: function(_, action) {
      var cell, modifications;
      cell = this._first;
      modifications = this._modifications;
      for (; cell != null;) {
        action.call$1(cell.get$_element());
        if (modifications !== this._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(this));
        cell = cell.get$_next();
      }
    },
    get$first: function(_) {
      var t1 = this._first;
      if (t1 == null)
        throw H.wrapException(P.StateError$("No elements"));
      return t1.get$_element();
    },
    get$last: function(_) {
      var t1 = this._last;
      if (t1 == null)
        throw H.wrapException(P.StateError$("No elements"));
      return t1.get$_element();
    },
    add$1: [function(_, element) {
      var strings, table, nums;
      if (typeof element === "string" && element !== "__proto__") {
        strings = this._strings;
        if (strings == null) {
          table = Object.create(null);
          table["<non-identifier-key>"] = table;
          delete table["<non-identifier-key>"];
          this._strings = table;
          strings = table;
        }
        return this._addHashTableEntry$2(strings, element);
      } else if (typeof element === "number" && (element & 0x3ffffff) === element) {
        nums = this._nums;
        if (nums == null) {
          table = Object.create(null);
          table["<non-identifier-key>"] = table;
          delete table["<non-identifier-key>"];
          this._nums = table;
          nums = table;
        }
        return this._addHashTableEntry$2(nums, element);
      } else
        return this._add$1(element);
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "bool__E0", ret: P.bool, args: [E]};
      }, this.$receiver, "_LinkedHashSet");
    }],
    _add$1: function(element) {
      var rest, hash, bucket;
      rest = this._rest;
      if (rest == null) {
        rest = P._LinkedHashSet__newHashTable();
        this._rest = rest;
      }
      hash = this._computeHashCode$1(element);
      bucket = rest[hash];
      if (bucket == null)
        rest[hash] = [this._newLinkedCell$1(element)];
      else {
        if (this._findBucketIndex$2(bucket, element) >= 0)
          return false;
        bucket.push(this._newLinkedCell$1(element));
      }
      return true;
    },
    remove$1: function(_, object) {
      if (typeof object === "string" && object !== "__proto__")
        return this._removeHashTableEntry$2(this._strings, object);
      else if (typeof object === "number" && (object & 0x3ffffff) === object)
        return this._removeHashTableEntry$2(this._nums, object);
      else
        return this._remove$1(object);
    },
    _remove$1: function(object) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return false;
      bucket = rest[this._computeHashCode$1(object)];
      index = this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return false;
      this._unlinkCell$1(bucket.splice(index, 1)[0]);
      return true;
    },
    clear$0: function(_) {
      if (this._collection$_length > 0) {
        this._last = null;
        this._first = null;
        this._rest = null;
        this._nums = null;
        this._strings = null;
        this._collection$_length = 0;
        this._modifications = this._modifications + 1 & 67108863;
      }
    },
    _addHashTableEntry$2: function(table, element) {
      if (table[element] != null)
        return false;
      table[element] = this._newLinkedCell$1(element);
      return true;
    },
    _removeHashTableEntry$2: function(table, element) {
      var cell;
      if (table == null)
        return false;
      cell = table[element];
      if (cell == null)
        return false;
      this._unlinkCell$1(cell);
      delete table[element];
      return true;
    },
    _newLinkedCell$1: function(element) {
      var cell, last;
      cell = new P.LinkedHashSetCell(element, null, null);
      if (this._first == null) {
        this._last = cell;
        this._first = cell;
      } else {
        last = this._last;
        cell._previous = last;
        last.set$_next(cell);
        this._last = cell;
      }
      ++this._collection$_length;
      this._modifications = this._modifications + 1 & 67108863;
      return cell;
    },
    _unlinkCell$1: function(cell) {
      var previous, next;
      previous = cell.get$_previous();
      next = cell.get$_next();
      if (previous == null)
        this._first = next;
      else
        previous.set$_next(next);
      if (next == null)
        this._last = previous;
      else
        next.set$_previous(previous);
      --this._collection$_length;
      this._modifications = this._modifications + 1 & 67108863;
    },
    _computeHashCode$1: function(element) {
      return J.get$hashCode$(element) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, element) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq(bucket[i].get$_element(), element))
          return i;
      return -1;
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: null,
    static: {_LinkedHashSet__newHashTable: function() {
        var table = Object.create(null);
        table["<non-identifier-key>"] = table;
        delete table["<non-identifier-key>"];
        return table;
      }}
  },
  LinkedHashSetCell: {
    "^": "Object;_element<,_next@,_previous@"
  },
  LinkedHashSetIterator: {
    "^": "Object;_collection$_set,_modifications,_cell,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var t1 = this._collection$_set;
      if (this._modifications !== t1._modifications)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else {
        t1 = this._cell;
        if (t1 == null) {
          this._collection$_current = null;
          return false;
        } else {
          this._collection$_current = t1.get$_element();
          this._cell = this._cell.get$_next();
          return true;
        }
      }
    }
  },
  UnmodifiableListView: {
    "^": "UnmodifiableListBase;_collection$_source",
    get$length: function(_) {
      return this._collection$_source.length;
    },
    $index: function(_, index) {
      var t1 = this._collection$_source;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    }
  },
  _HashSetBase: {
    "^": "SetBase;"
  },
  IterableBase: {
    "^": "Object;",
    expand$1: function(_, f) {
      return H.setRuntimeTypeInfo(new H.ExpandIterable(this, f), [H.getRuntimeTypeArgument(this, "IterableBase", 0), null]);
    },
    contains$1: function(_, element) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        if (J.$eq(t1.get$current(), element))
          return true;
      return false;
    },
    forEach$1: function(_, f) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        f.call$1(t1.get$current());
    },
    any$1: function(_, f) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        if (f.call$1(t1.get$current()) === true)
          return true;
      return false;
    },
    toList$1$growable: function(_, growable) {
      return P.List_List$from(this, growable, H.getRuntimeTypeArgument(this, "IterableBase", 0));
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    get$length: function(_) {
      var it, count;
      it = this.get$iterator(this);
      for (count = 0; it.moveNext$0();)
        ++count;
      return count;
    },
    get$isEmpty: function(_) {
      return !this.get$iterator(this).moveNext$0();
    },
    get$isNotEmpty: function(_) {
      return !this.get$isEmpty(this);
    },
    skip$1: function(_, n) {
      return H.SkipIterable_SkipIterable(this, n, H.getRuntimeTypeArgument(this, "IterableBase", 0));
    },
    skipWhile$1: function(_, test) {
      return H.setRuntimeTypeInfo(new H.SkipWhileIterable(this, test), [H.getRuntimeTypeArgument(this, "IterableBase", 0)]);
    },
    get$first: function(_) {
      var it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      return it.get$current();
    },
    get$last: function(_) {
      var it, result;
      it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      do
        result = it.get$current();
      while (it.moveNext$0());
      return result;
    },
    elementAt$1: function(_, index) {
      var t1, remaining, element;
      if (typeof index !== "number" || Math.floor(index) !== index || index < 0)
        throw H.wrapException(P.RangeError$value(index));
      for (t1 = this.get$iterator(this), remaining = index; t1.moveNext$0();) {
        element = t1.get$current();
        if (remaining === 0)
          return element;
        --remaining;
      }
      throw H.wrapException(P.RangeError$value(index));
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToShortString(this, "(", ")");
    },
    $isIterable: true,
    $asIterable: null
  },
  LinkedList: {
    "^": "IterableBase;_modificationCount,_collection$_length,_next@,_previous@",
    add$1: [function(_, entry) {
      this._insertAfter$2(this._previous, entry);
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "void__E2", void: true, args: [E]};
      }, this.$receiver, "LinkedList");
    }],
    remove$1: function(_, entry) {
      if (entry._list !== this)
        return false;
      this._unlink$1(entry);
      return true;
    },
    get$iterator: function(_) {
      var t1 = new P._LinkedListIterator(this, this._modificationCount, null, this._next);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    get$length: function(_) {
      return this._collection$_length;
    },
    get$first: function(_) {
      var t1 = this._next;
      if (t1 === this)
        throw H.wrapException(P.StateError$("No such element"));
      return t1;
    },
    get$last: function(_) {
      var t1 = this._previous;
      if (t1 === this)
        throw H.wrapException(P.StateError$("No such element"));
      return t1;
    },
    forEach$1: function(_, action) {
      var modificationCount, current;
      modificationCount = this._modificationCount;
      current = this._next;
      for (; current !== this;) {
        action.call$1(current);
        if (modificationCount !== this._modificationCount)
          throw H.wrapException(P.ConcurrentModificationError$(this));
        current = current.get$_next();
      }
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    _insertAfter$2: function(entry, newEntry) {
      var successor;
      if (newEntry.get$list() != null)
        throw H.wrapException(P.StateError$("LinkedListEntry is already in a LinkedList"));
      ++this._modificationCount;
      newEntry.set$_list(this);
      successor = entry.get$_next();
      successor.set$_previous(newEntry);
      newEntry.set$_previous(entry);
      newEntry.set$_next(successor);
      entry.set$_next(newEntry);
      ++this._collection$_length;
    },
    _unlink$1: function(entry) {
      ++this._modificationCount;
      entry._next.set$_previous(entry._previous);
      entry._previous.set$_next(entry._next);
      --this._collection$_length;
      entry._previous = null;
      entry._next = null;
      entry._list = null;
    }
  },
  _LinkedListIterator: {
    "^": "Object;_list,_modificationCount,_collection$_current,_next@",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var t1, t2;
      t1 = this._next;
      t2 = this._list;
      if (t1 === t2) {
        this._collection$_current = null;
        return false;
      }
      if (this._modificationCount !== t2._modificationCount)
        throw H.wrapException(P.ConcurrentModificationError$(this));
      this._collection$_current = t1;
      this._next = t1.get$_next();
      return true;
    }
  },
  LinkedListEntry: {
    "^": "Object;_list?,_next@,_previous@",
    get$list: function() {
      return this._list;
    },
    get$next: function() {
      var t1, t2;
      t1 = this._next;
      t2 = this._list;
      if (t1 == null ? t2 == null : t1 === t2)
        return;
      return t1;
    }
  },
  ListBase: {
    "^": "Object_ListMixin;"
  },
  Object_ListMixin: {
    "^": "Object+ListMixin;",
    $isList: true,
    $asList: null,
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: null
  },
  ListMixin: {
    "^": "Object;",
    get$iterator: function(receiver) {
      return H.setRuntimeTypeInfo(new H.ListIterator(receiver, this.get$length(receiver), 0, null), [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    forEach$1: function(receiver, action) {
      var $length, i;
      $length = this.get$length(receiver);
      for (i = 0; i < $length; ++i) {
        action.call$1(this.$index(receiver, i));
        if ($length !== this.get$length(receiver))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
    },
    get$isEmpty: function(receiver) {
      return this.get$length(receiver) === 0;
    },
    get$isNotEmpty: function(receiver) {
      return this.get$length(receiver) !== 0;
    },
    get$first: function(receiver) {
      if (this.get$length(receiver) === 0)
        throw H.wrapException(P.StateError$("No elements"));
      return this.$index(receiver, 0);
    },
    get$last: function(receiver) {
      if (this.get$length(receiver) === 0)
        throw H.wrapException(P.StateError$("No elements"));
      return this.$index(receiver, this.get$length(receiver) - 1);
    },
    contains$1: function(receiver, element) {
      var $length, i;
      $length = this.get$length(receiver);
      for (i = 0; i < this.get$length(receiver); ++i) {
        if (J.$eq(this.$index(receiver, i), element))
          return true;
        if ($length !== this.get$length(receiver))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return false;
    },
    map$1: function(receiver, f) {
      return H.setRuntimeTypeInfo(new H.MappedListIterable(receiver, f), [null, null]);
    },
    expand$1: function(receiver, f) {
      return H.setRuntimeTypeInfo(new H.ExpandIterable(receiver, f), [H.getRuntimeTypeArgument(receiver, "ListMixin", 0), null]);
    },
    skip$1: function(receiver, count) {
      return H.SubListIterable$(receiver, count, null, null);
    },
    takeWhile$1: function(receiver, test) {
      return H.setRuntimeTypeInfo(new H.TakeWhileIterable(receiver, test), [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
    },
    toList$1$growable: function(receiver, growable) {
      var result, t1, i;
      if (growable) {
        result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
        C.JSArray_methods.set$length(result, this.get$length(receiver));
      } else {
        t1 = Array(this.get$length(receiver));
        t1.fixed$length = init;
        result = H.setRuntimeTypeInfo(t1, [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
      }
      for (i = 0; i < this.get$length(receiver); ++i) {
        t1 = this.$index(receiver, i);
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = t1;
      }
      return result;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    add$1: [function(receiver, element) {
      var t1 = this.get$length(receiver);
      this.set$length(receiver, t1 + 1);
      this.$indexSet(receiver, t1, element);
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "void__E3", void: true, args: [E]};
      }, this.$receiver, "ListMixin");
    }],
    _rangeCheck$2: function(receiver, start, end) {
      var t1;
      if (start < 0 || start > this.get$length(receiver))
        throw H.wrapException(P.RangeError$range(start, 0, this.get$length(receiver)));
      t1 = J.getInterceptor$n(end);
      if (t1.$lt(end, start) || t1.$gt(end, this.get$length(receiver)))
        throw H.wrapException(P.RangeError$range(end, start, this.get$length(receiver)));
    },
    sublist$2: function(receiver, start, end) {
      var $length, result, i, t1;
      this._rangeCheck$2(receiver, start, end);
      $length = J.$sub$n(end, start);
      result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
      C.JSArray_methods.set$length(result, $length);
      for (i = 0; i < $length; ++i) {
        t1 = this.$index(receiver, start + i);
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = t1;
      }
      return result;
    },
    removeRange$2: function(receiver, start, end) {
      var $length;
      this._rangeCheck$2(receiver, start, end);
      $length = end - start;
      this.setRange$4(receiver, start, this.get$length(receiver) - $length, receiver, end);
      this.set$length(receiver, this.get$length(receiver) - $length);
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      var $length, t1, otherStart, otherList, i;
      if (start < 0 || start > this.get$length(receiver))
        H.throwExpression(P.RangeError$range(start, 0, this.get$length(receiver)));
      if (end < start || end > this.get$length(receiver))
        H.throwExpression(P.RangeError$range(end, start, this.get$length(receiver)));
      $length = end - start;
      if ($length === 0)
        return;
      if (skipCount < 0)
        throw H.wrapException(P.ArgumentError$(skipCount));
      t1 = J.getInterceptor(iterable);
      if (!!t1.$isList) {
        otherStart = skipCount;
        otherList = iterable;
      } else {
        otherList = t1.skip$1(iterable, skipCount).toList$1$growable(0, false);
        otherStart = 0;
      }
      t1 = J.getInterceptor$asx(otherList);
      if (otherStart + $length > t1.get$length(otherList))
        throw H.wrapException(P.StateError$("Not enough elements"));
      if (otherStart < start)
        for (i = $length - 1; i >= 0; --i)
          this.$indexSet(receiver, start + i, t1.$index(otherList, otherStart + i));
      else
        for (i = 0; i < $length; ++i)
          this.$indexSet(receiver, start + i, t1.$index(otherList, otherStart + i));
    },
    indexOf$2: function(receiver, element, startIndex) {
      var i;
      if (startIndex >= this.get$length(receiver))
        return -1;
      if (startIndex < 0)
        startIndex = 0;
      for (i = startIndex; i < this.get$length(receiver); ++i)
        if (J.$eq(this.$index(receiver, i), element))
          return i;
      return -1;
    },
    indexOf$1: function($receiver, element) {
      return this.indexOf$2($receiver, element, 0);
    },
    get$reversed: function(receiver) {
      return H.setRuntimeTypeInfo(new H.ReversedListIterable(receiver), [null]);
    },
    toString$0: function(receiver) {
      return P.IterableBase_iterableToFullString(receiver, "[", "]");
    },
    $isList: true,
    $asList: null,
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: null
  },
  _UnmodifiableMapMixin: {
    "^": "Object;",
    $indexSet: function(_, key, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable map"));
    },
    $isMap: true
  },
  MapView: {
    "^": "Object;",
    $index: function(_, key) {
      return this._map.$index(0, key);
    },
    $indexSet: function(_, key, value) {
      this._map.$indexSet(0, key, value);
    },
    forEach$1: function(_, action) {
      this._map.forEach$1(0, action);
    },
    get$isEmpty: function(_) {
      var t1 = this._map;
      return t1.get$isEmpty(t1);
    },
    get$isNotEmpty: function(_) {
      var t1 = this._map;
      return t1.get$isNotEmpty(t1);
    },
    get$length: function(_) {
      var t1 = this._map;
      return t1.get$length(t1);
    },
    get$keys: function() {
      return this._map.get$keys();
    },
    toString$0: function(_) {
      return J.toString$0(this._map);
    },
    get$values: function() {
      return this._map.get$values();
    },
    $isMap: true
  },
  UnmodifiableMapView: {
    "^": "MapView+_UnmodifiableMapMixin;_map",
    $isMap: true
  },
  Maps_mapToString_closure: {
    "^": "Closure:56;box_0,result_1",
    call$2: function(k, v) {
      var t1 = this.box_0;
      if (!t1.first_0)
        this.result_1.write$1(", ");
      t1.first_0 = false;
      t1 = this.result_1;
      t1.write$1(k);
      t1.write$1(": ");
      t1.write$1(v);
    },
    $isFunction: true
  },
  ListQueue: {
    "^": "IterableBase;_table,_head,_tail,_modificationCount",
    get$iterator: function(_) {
      var t1 = new P._ListQueueIterator(this, this._tail, this._modificationCount, this._head, null);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    forEach$1: function(_, action) {
      var modificationCount, i, t1;
      modificationCount = this._modificationCount;
      for (i = this._head; i !== this._tail; i = (i + 1 & this._table.length - 1) >>> 0) {
        t1 = this._table;
        if (i < 0 || i >= t1.length)
          return H.ioore(t1, i);
        action.call$1(t1[i]);
        if (modificationCount !== this._modificationCount)
          H.throwExpression(P.ConcurrentModificationError$(this));
      }
    },
    get$isEmpty: function(_) {
      return this._head === this._tail;
    },
    get$length: function(_) {
      return (this._tail - this._head & this._table.length - 1) >>> 0;
    },
    get$first: function(_) {
      var t1, t2;
      t1 = this._head;
      if (t1 === this._tail)
        throw H.wrapException(H.IterableElementError_noElement());
      t2 = this._table;
      if (t1 >= t2.length)
        return H.ioore(t2, t1);
      return t2[t1];
    },
    get$last: function(_) {
      var t1, t2, t3;
      t1 = this._head;
      t2 = this._tail;
      if (t1 === t2)
        throw H.wrapException(H.IterableElementError_noElement());
      t1 = this._table;
      t3 = t1.length;
      t2 = (t2 - 1 & t3 - 1) >>> 0;
      if (t2 < 0 || t2 >= t3)
        return H.ioore(t1, t2);
      return t1[t2];
    },
    toList$1$growable: function(_, growable) {
      var list, t1;
      if (growable) {
        list = H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(this, 0)]);
        C.JSArray_methods.set$length(list, this.get$length(this));
      } else {
        t1 = Array(this.get$length(this));
        t1.fixed$length = init;
        list = H.setRuntimeTypeInfo(t1, [H.getTypeArgumentByIndex(this, 0)]);
      }
      this._writeToList$1(list);
      return list;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    add$1: [function(_, element) {
      this._add$1(element);
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "void__E4", void: true, args: [E]};
      }, this.$receiver, "ListQueue");
    }],
    clear$0: function(_) {
      var i, t1, t2, t3, t4;
      i = this._head;
      t1 = this._tail;
      if (i !== t1) {
        for (t2 = this._table, t3 = t2.length, t4 = t3 - 1; i !== t1; i = (i + 1 & t4) >>> 0) {
          if (i < 0 || i >= t3)
            return H.ioore(t2, i);
          t2[i] = null;
        }
        this._tail = 0;
        this._head = 0;
        ++this._modificationCount;
      }
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "{", "}");
    },
    removeFirst$0: function() {
      var t1, t2, t3, result;
      t1 = this._head;
      if (t1 === this._tail)
        throw H.wrapException(H.IterableElementError_noElement());
      ++this._modificationCount;
      t2 = this._table;
      t3 = t2.length;
      if (t1 >= t3)
        return H.ioore(t2, t1);
      result = t2[t1];
      t2[t1] = null;
      this._head = (t1 + 1 & t3 - 1) >>> 0;
      return result;
    },
    _add$1: function(element) {
      var t1, t2, t3;
      t1 = this._table;
      t2 = this._tail;
      t3 = t1.length;
      if (t2 < 0 || t2 >= t3)
        return H.ioore(t1, t2);
      t1[t2] = element;
      t3 = (t2 + 1 & t3 - 1) >>> 0;
      this._tail = t3;
      if (this._head === t3)
        this._grow$0();
      ++this._modificationCount;
    },
    _grow$0: function() {
      var t1, newTable, t2, split;
      t1 = Array(this._table.length * 2);
      t1.fixed$length = init;
      newTable = H.setRuntimeTypeInfo(t1, [H.getTypeArgumentByIndex(this, 0)]);
      t1 = this._table;
      t2 = this._head;
      split = t1.length - t2;
      H.IterableMixinWorkaround_setRangeList(newTable, 0, split, t1, t2);
      t1 = this._head;
      t2 = this._table;
      H.IterableMixinWorkaround_setRangeList(newTable, split, split + t1, t2, 0);
      this._head = 0;
      this._tail = this._table.length;
      this._table = newTable;
    },
    _writeToList$1: function(target) {
      var t1, t2, t3, $length, firstPartSize;
      t1 = this._head;
      t2 = this._tail;
      t3 = this._table;
      if (t1 <= t2) {
        $length = t2 - t1;
        H.IterableMixinWorkaround_setRangeList(target, 0, $length, t3, t1);
        return $length;
      } else {
        firstPartSize = t3.length - t1;
        H.IterableMixinWorkaround_setRangeList(target, 0, firstPartSize, t3, t1);
        t1 = this._tail;
        t2 = this._table;
        H.IterableMixinWorkaround_setRangeList(target, firstPartSize, firstPartSize + t1, t2, 0);
        return this._tail + firstPartSize;
      }
    },
    ListQueue$1: function(initialCapacity, $E) {
      var t1 = Array(8);
      t1.fixed$length = init;
      this._table = H.setRuntimeTypeInfo(t1, [$E]);
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: null,
    static: {"^": "ListQueue__INITIAL_CAPACITY", ListQueue$: function(initialCapacity, $E) {
        var t1 = H.setRuntimeTypeInfo(new P.ListQueue(null, 0, 0, 0), [$E]);
        t1.ListQueue$1(initialCapacity, $E);
        return t1;
      }}
  },
  _ListQueueIterator: {
    "^": "Object;_queue,_end,_modificationCount,_position,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var t1, t2, t3;
      t1 = this._queue;
      if (this._modificationCount !== t1._modificationCount)
        H.throwExpression(P.ConcurrentModificationError$(t1));
      t2 = this._position;
      if (t2 === this._end) {
        this._collection$_current = null;
        return false;
      }
      t1 = t1._table;
      t3 = t1.length;
      if (t2 >= t3)
        return H.ioore(t1, t2);
      this._collection$_current = t1[t2];
      this._position = (t2 + 1 & t3 - 1) >>> 0;
      return true;
    }
  },
  SetMixin: {
    "^": "Object;",
    get$isEmpty: function(_) {
      return this.get$length(this) === 0;
    },
    get$isNotEmpty: function(_) {
      return this.get$length(this) !== 0;
    },
    toList$1$growable: function(_, growable) {
      var result, t1, i, element, i0;
      if (growable) {
        result = H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(this, 0)]);
        C.JSArray_methods.set$length(result, this.get$length(this));
      } else {
        t1 = Array(this.get$length(this));
        t1.fixed$length = init;
        result = H.setRuntimeTypeInfo(t1, [H.getTypeArgumentByIndex(this, 0)]);
      }
      for (t1 = this.get$iterator(this), i = 0; t1.moveNext$0(); i = i0) {
        element = t1.get$current();
        i0 = i + 1;
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = element;
      }
      return result;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "{", "}");
    },
    expand$1: function(_, f) {
      return H.setRuntimeTypeInfo(new H.ExpandIterable(this, f), [H.getTypeArgumentByIndex(this, 0), null]);
    },
    forEach$1: function(_, f) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        f.call$1(t1.get$current());
    },
    skip$1: function(_, n) {
      return H.SkipIterable_SkipIterable(this, n, H.getTypeArgumentByIndex(this, 0));
    },
    get$first: function(_) {
      var it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      return it.get$current();
    },
    get$last: function(_) {
      var it, result;
      it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      do
        result = it.get$current();
      while (it.moveNext$0());
      return result;
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: null
  },
  SetBase: {
    "^": "SetMixin;"
  }
}],
["dart.convert", "dart:convert", , P, {
  "^": "",
  Encoding_getByName: function($name) {
    if ($name == null)
      return;
    $name = J.toLowerCase$0$s($name);
    return $.get$Encoding__nameToEncoding().$index(0, $name);
  },
  _defaultToEncodable: [function(object) {
    return object.toJson$0();
  }, "call$1", "_defaultToEncodable$closure", 2, 0, 46, 0],
  AsciiCodec: {
    "^": "Encoding;_allowInvalid",
    get$name: function() {
      return "us-ascii";
    },
    get$encoder: function() {
      return C.AsciiEncoder_127;
    }
  },
  _UnicodeSubsetEncoder: {
    "^": "Converter;",
    convert$1: function(string) {
      var t1, t2, result, t3, i, t4, codeUnit;
      t1 = J.getInterceptor$asx(string);
      t2 = t1.get$length(string);
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = Array(t2);
      t2.fixed$length = init;
      result = H.setRuntimeTypeInfo(t2, [P.$int]);
      t2 = result.length;
      t3 = ~this._subsetMask;
      i = 0;
      while (true) {
        t4 = t1.get$length(string);
        if (typeof t4 !== "number")
          return H.iae(t4);
        if (!(i < t4))
          break;
        codeUnit = t1.codeUnitAt$1(string, i);
        if ((codeUnit & t3) !== 0)
          throw H.wrapException(P.ArgumentError$("String contains invalid characters."));
        if (i >= t2)
          return H.ioore(result, i);
        result[i] = codeUnit;
        ++i;
      }
      return result;
    },
    startChunkedConversion$1: function(sink) {
      sink = new P._ByteAdapterSink(sink);
      return new P._UnicodeSubsetEncoderSink(sink, this._subsetMask);
    },
    $asConverter: function() {
      return [P.String, [P.List, P.$int]];
    }
  },
  AsciiEncoder: {
    "^": "_UnicodeSubsetEncoder;_subsetMask"
  },
  _UnicodeSubsetEncoderSink: {
    "^": "StringConversionSinkBase;_sink,_subsetMask",
    close$0: function() {
      this._sink._sink.close$0();
    },
    addSlice$4: function(source, start, end, isLast) {
      var t1, t2, i, codeUnit;
      t1 = J.get$length$asx(source);
      if (typeof t1 !== "number")
        return H.iae(t1);
      t1 = start > t1;
      if (t1)
        throw H.wrapException(P.RangeError$range(start, 0, J.get$length$asx(source)));
      t1 = J.getInterceptor$n(end);
      if (t1.$lt(end, start) || t1.$gt(end, J.get$length$asx(source)))
        throw H.wrapException(P.RangeError$range(end, start, J.get$length$asx(source)));
      if (typeof end !== "number")
        return H.iae(end);
      t1 = ~this._subsetMask;
      t2 = J.getInterceptor$s(source);
      i = start;
      for (; i < end; ++i) {
        codeUnit = t2.codeUnitAt$1(source, i);
        if ((codeUnit & t1) !== 0)
          throw H.wrapException(P.ArgumentError$("Source contains invalid character with code point: " + codeUnit + "."));
      }
      t1 = t2.get$codeUnits(source);
      t2 = this._sink._sink;
      t2.add$1(0, t1.sublist$2(t1, start, end));
      if (isLast)
        t2.close$0();
    }
  },
  ByteConversionSink: {
    "^": "ChunkedConversionSink;",
    $isByteConversionSink: true,
    $asChunkedConversionSink: function() {
      return [[P.List, P.$int]];
    }
  },
  ByteConversionSinkBase: {
    "^": "ByteConversionSink;"
  },
  _ByteAdapterSink: {
    "^": "ByteConversionSinkBase;_sink",
    add$1: [function(_, chunk) {
      return this._sink.add$1(0, chunk);
    }, "call$1", "get$add", 2, 0, 83],
    close$0: function() {
      return this._sink.close$0();
    }
  },
  ChunkedConversionSink: {
    "^": "Object;"
  },
  _ConverterStreamEventSink: {
    "^": "Object;_eventSink,_chunkedSink",
    add$1: [function(_, o) {
      return this._chunkedSink.add$1(0, o);
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(S, T) {
        return {func: "void__S1", void: true, args: [S]};
      }, this.$receiver, "_ConverterStreamEventSink");
    }],
    addError$2: function(error, stackTrace) {
      var t1 = this._eventSink._async$_sink;
      if ((t1._state & 2) !== 0)
        H.throwExpression(P.StateError$("Stream is already closed"));
      P._BufferingStreamSubscription.prototype._addError$2.call(t1, error, stackTrace);
    },
    close$0: function() {
      return this._chunkedSink.close$0();
    }
  },
  Codec: {
    "^": "Object;"
  },
  Converter: {
    "^": "Object;",
    startChunkedConversion$1: function(sink) {
      throw H.wrapException(P.UnsupportedError$("This converter does not support chunked conversions: " + this.toString$0(0)));
    },
    bind$1: function(source) {
      return H.setRuntimeTypeInfo(new P._BoundSinkStream(new P.Converter_bind_closure(this), source), [null, null]);
    }
  },
  Converter_bind_closure: {
    "^": "Closure:84;this_0",
    call$1: function(sink) {
      return H.setRuntimeTypeInfo(new P._ConverterStreamEventSink(sink, this.this_0.startChunkedConversion$1(sink)), [null, null]);
    },
    $isFunction: true
  },
  Encoding: {
    "^": "Codec;",
    $asCodec: function() {
      return [P.String, [P.List, P.$int]];
    }
  },
  JsonUnsupportedObjectError: {
    "^": "Error;unsupportedObject,cause",
    toString$0: function(_) {
      if (this.cause != null)
        return "Converting object to an encodable object failed.";
      else
        return "Converting object did not return an encodable object.";
    },
    static: {JsonUnsupportedObjectError$: function(unsupportedObject, cause) {
        return new P.JsonUnsupportedObjectError(unsupportedObject, cause);
      }}
  },
  JsonCyclicError: {
    "^": "JsonUnsupportedObjectError;unsupportedObject,cause",
    toString$0: function(_) {
      return "Cyclic error in JSON stringify";
    },
    static: {JsonCyclicError$: function(object) {
        return new P.JsonCyclicError(object, null);
      }}
  },
  JsonCodec: {
    "^": "Codec;_reviver,_toEncodable",
    encode$2$toEncodable: function(value, toEncodable) {
      var t1 = this.get$encoder();
      return P._JsonStringifier_stringify(value, t1._toEncodableFunction, t1.indent);
    },
    encode$1: function(value) {
      return this.encode$2$toEncodable(value, null);
    },
    get$encoder: function() {
      return C.JsonEncoder_null_null;
    },
    $asCodec: function() {
      return [P.Object, P.String];
    }
  },
  JsonEncoder: {
    "^": "Converter;indent,_toEncodableFunction",
    startChunkedConversion$1: function(sink) {
      sink = new P._StringAdapterSink(sink);
      return new P._JsonEncoderSink(this.indent, this._toEncodableFunction, sink, false);
    },
    $asConverter: function() {
      return [P.Object, P.String];
    }
  },
  _JsonEncoderSink: {
    "^": "ChunkedConversionSink;_indent,_toEncodableFunction,_sink,_isDone",
    add$1: [function(_, o) {
      var t1, t2, stringSink;
      if (this._isDone)
        throw H.wrapException(P.StateError$("Only one call to add allowed"));
      this._isDone = true;
      t1 = this._sink;
      t2 = P.StringBuffer$("");
      stringSink = new P._StringConversionSinkAsStringSinkAdapter(t2, t1);
      P._JsonStringifier__JsonStringifier(stringSink, this._toEncodableFunction, this._indent).stringifyValue$1(o);
      if (t2._contents.length !== 0)
        stringSink._flush$0();
      t1.close$0();
    }, "call$1", "get$add", 2, 0, 85],
    close$0: function() {
    },
    $asChunkedConversionSink: function() {
      return [P.Object];
    }
  },
  _JsonStringifier: {
    "^": "Object;_toEncodable,_sink,_seen",
    _toEncodable$1: function(arg0) {
      return this._toEncodable.call$1(arg0);
    },
    escape$1: function(s) {
      var t1, $length, t2, offset, i, charCode, t3;
      t1 = J.getInterceptor$asx(s);
      $length = t1.get$length(s);
      if (typeof $length !== "number")
        return H.iae($length);
      t2 = this._sink;
      offset = 0;
      i = 0;
      for (; i < $length; ++i) {
        charCode = t1.codeUnitAt$1(s, i);
        if (charCode > 92)
          continue;
        if (charCode < 32) {
          if (i > offset)
            t2.write$1(t1.substring$2(s, offset, i));
          offset = i + 1;
          t2.writeCharCode$1(92);
          switch (charCode) {
            case 8:
              t2.writeCharCode$1(98);
              break;
            case 9:
              t2.writeCharCode$1(116);
              break;
            case 10:
              t2.writeCharCode$1(110);
              break;
            case 12:
              t2.writeCharCode$1(102);
              break;
            case 13:
              t2.writeCharCode$1(114);
              break;
            default:
              t2.writeCharCode$1(117);
              t2.writeCharCode$1(48);
              t2.writeCharCode$1(48);
              t3 = charCode >>> 4 & 15;
              t2.writeCharCode$1(t3 < 10 ? 48 + t3 : 87 + t3);
              t3 = charCode & 15;
              t2.writeCharCode$1(t3 < 10 ? 48 + t3 : 87 + t3);
              break;
          }
        } else if (charCode === 34 || charCode === 92) {
          if (i > offset)
            t2.write$1(t1.substring$2(s, offset, i));
          offset = i + 1;
          t2.writeCharCode$1(92);
          t2.writeCharCode$1(charCode);
        }
      }
      if (offset === 0)
        t2.write$1(s);
      else if (offset < $length)
        t2.write$1(t1.substring$2(s, offset, $length));
    },
    checkCycle$1: function(object) {
      var t1, t2, i, t3;
      for (t1 = this._seen, t2 = t1.length, i = 0; i < t2; ++i) {
        t3 = t1[i];
        if (object == null ? t3 == null : object === t3)
          throw H.wrapException(P.JsonCyclicError$(object));
      }
      t1.push(object);
    },
    stringifyValue$1: function(object) {
      var customJson, e, t1, exception;
      if (!this.stringifyJsonValue$1(object)) {
        this.checkCycle$1(object);
        try {
          customJson = this._toEncodable$1(object);
          if (!this.stringifyJsonValue$1(customJson)) {
            t1 = P.JsonUnsupportedObjectError$(object, null);
            throw H.wrapException(t1);
          }
          t1 = this._seen;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          t1.pop();
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          throw H.wrapException(P.JsonUnsupportedObjectError$(object, e));
        }

      }
    },
    stringifyJsonValue$1: function(object) {
      var t1, t2, i, t3;
      t1 = {};
      if (typeof object === "number") {
        if (!C.JSNumber_methods.get$isFinite(object))
          return false;
        this._sink.write$1(C.JSNumber_methods.toString$0(object));
        return true;
      } else if (object === true) {
        this._sink.write$1("true");
        return true;
      } else if (object === false) {
        this._sink.write$1("false");
        return true;
      } else if (object == null) {
        this._sink.write$1("null");
        return true;
      } else if (typeof object === "string") {
        t1 = this._sink;
        t1.write$1("\"");
        this.escape$1(object);
        t1.write$1("\"");
        return true;
      } else {
        t2 = J.getInterceptor(object);
        if (!!t2.$isList) {
          this.checkCycle$1(object);
          t1 = this._sink;
          t1.write$1("[");
          if (t2.get$length(object) > 0) {
            this.stringifyValue$1(t2.$index(object, 0));
            for (i = 1; i < t2.get$length(object); ++i) {
              t1.write$1(",");
              this.stringifyValue$1(t2.$index(object, i));
            }
          }
          t1.write$1("]");
          this._removeSeen$1(object);
          return true;
        } else if (!!t2.$isMap) {
          this.checkCycle$1(object);
          t3 = this._sink;
          t3.write$1("{");
          t1.separator_0 = "\"";
          t2.forEach$1(object, new P._JsonStringifier_stringifyJsonValue_closure(t1, this));
          t3.write$1("}");
          this._removeSeen$1(object);
          return true;
        } else
          return false;
      }
    },
    _removeSeen$1: function(object) {
      var t1 = this._seen;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    },
    static: {"^": "_JsonStringifier_BACKSPACE,_JsonStringifier_TAB,_JsonStringifier_NEWLINE,_JsonStringifier_CARRIAGE_RETURN,_JsonStringifier_FORM_FEED,_JsonStringifier_QUOTE,_JsonStringifier_CHAR_0,_JsonStringifier_BACKSLASH,_JsonStringifier_CHAR_b,_JsonStringifier_CHAR_f,_JsonStringifier_CHAR_n,_JsonStringifier_CHAR_r,_JsonStringifier_CHAR_t,_JsonStringifier_CHAR_u", _JsonStringifier__JsonStringifier: function(sink, toEncodable, indent) {
        return new P._JsonStringifier(toEncodable, sink, []);
      }, _JsonStringifier_stringify: function(object, toEncodable, indent) {
        var output;
        toEncodable = P._defaultToEncodable$closure();
        output = P.StringBuffer$("");
        P._JsonStringifier__JsonStringifier(output, toEncodable, indent).stringifyValue$1(object);
        return output._contents;
      }}
  },
  _JsonStringifier_stringifyJsonValue_closure: {
    "^": "Closure:57;box_0,this_1",
    call$2: function(key, value) {
      var t1, t2, t3;
      t1 = this.this_1;
      t2 = t1._sink;
      t3 = this.box_0;
      t2.write$1(t3.separator_0);
      t3.separator_0 = ",\"";
      t1.escape$1(key);
      t2.write$1("\":");
      t1.stringifyValue$1(value);
    },
    $isFunction: true
  },
  Latin1Codec: {
    "^": "Encoding;_allowInvalid",
    get$name: function() {
      return "iso-8859-1";
    },
    get$encoder: function() {
      return C.Latin1Encoder_255;
    }
  },
  Latin1Encoder: {
    "^": "_UnicodeSubsetEncoder;_subsetMask"
  },
  _StringConversionSinkAsStringSinkAdapter: {
    "^": "Object;_convert$_buffer,_chunkedSink",
    close$0: function() {
      if (this._convert$_buffer._contents.length !== 0)
        this._flush$0();
      this._chunkedSink.close$0();
    },
    writeCharCode$1: function(charCode) {
      var t1 = this._convert$_buffer;
      t1.write$1(H.Primitives_stringFromCharCode(charCode));
      if (t1._contents.length > 16)
        this._flush$0();
    },
    write$1: function(o) {
      var t1, t2;
      t1 = this._convert$_buffer;
      t2 = t1._contents;
      if (t2.length !== 0) {
        t1._contents = "";
        this._chunkedSink.add$1(0, t2);
      }
      t1 = J.getInterceptor(o);
      t1.toString$0(o);
      this._chunkedSink.add$1(0, t1.toString$0(o));
    },
    writeAll$2: function(objects, separator) {
      if (this._convert$_buffer._contents.length !== 0)
        this._flush$0();
      objects.get$iterator(objects).moveNext$0();
      return;
    },
    _flush$0: function() {
      var t1, accumulated;
      t1 = this._convert$_buffer;
      accumulated = t1._contents;
      t1._contents = "";
      this._chunkedSink.add$1(0, accumulated);
    },
    static: {"^": "_StringConversionSinkAsStringSinkAdapter__MIN_STRING_SIZE"}
  },
  StringConversionSinkBase: {
    "^": "StringConversionSinkMixin;"
  },
  StringConversionSinkMixin: {
    "^": "Object;",
    add$1: [function(_, str) {
      return this.addSlice$4(str, 0, J.get$length$asx(str), false);
    }, "call$1", "get$add", 2, 0, 38]
  },
  _StringAdapterSink: {
    "^": "StringConversionSinkBase;_sink",
    add$1: [function(_, str) {
      var t1 = this._sink._async$_sink;
      if ((t1._state & 2) !== 0)
        H.throwExpression(P.StateError$("Stream is already closed"));
      P._BufferingStreamSubscription.prototype._async$_add$1.call(t1, str);
      return;
    }, "call$1", "get$add", 2, 0, 38],
    addSlice$4: function(str, start, end, isLast) {
      var t1, t2, t3;
      t1 = start === 0 && end === J.get$length$asx(str);
      t2 = this._sink;
      if (t1) {
        t1 = t2._async$_sink;
        if ((t1._state & 2) !== 0)
          H.throwExpression(P.StateError$("Stream is already closed"));
        P._BufferingStreamSubscription.prototype._async$_add$1.call(t1, str);
      } else {
        t1 = J.substring$2$s(str, start, end);
        t3 = t2._async$_sink;
        if ((t3._state & 2) !== 0)
          H.throwExpression(P.StateError$("Stream is already closed"));
        P._BufferingStreamSubscription.prototype._async$_add$1.call(t3, t1);
      }
      if (isLast) {
        t1 = t2._async$_sink;
        if ((t1._state & 2) !== 0)
          H.throwExpression(P.StateError$("Stream is already closed"));
        P._BufferingStreamSubscription.prototype._close$0.call(t1);
      }
    },
    close$0: function() {
      var t1 = this._sink._async$_sink;
      if ((t1._state & 2) !== 0)
        H.throwExpression(P.StateError$("Stream is already closed"));
      P._BufferingStreamSubscription.prototype._close$0.call(t1);
      return;
    }
  },
  _Utf8ConversionSink: {
    "^": "ByteConversionSink;_decoder,_chunkedSink,_convert$_buffer",
    close$0: function() {
      var t1, t2, t3, t4;
      this._decoder.flush$0();
      t1 = this._convert$_buffer;
      t2 = t1._contents;
      t3 = t2.length;
      t4 = this._chunkedSink;
      if (t3 !== 0) {
        t1._contents = "";
        t4.addSlice$4(t2, 0, t3, true);
      } else
        t4.close$0();
    },
    add$1: [function(_, chunk) {
      this.addSlice$4(chunk, 0, J.get$length$asx(chunk), false);
    }, "call$1", "get$add", 2, 0, 83],
    addSlice$4: function(chunk, startIndex, endIndex, isLast) {
      var t1, t2, t3;
      this._decoder.convert$3(chunk, startIndex, endIndex);
      t1 = this._convert$_buffer;
      t2 = t1._contents;
      t3 = t2.length;
      if (t3 !== 0) {
        this._chunkedSink.addSlice$4(t2, 0, t3, isLast);
        t1._contents = "";
        return;
      }
      if (isLast)
        this.close$0();
    }
  },
  Utf8Codec: {
    "^": "Encoding;_allowMalformed",
    get$name: function() {
      return "utf-8";
    },
    decode$2$allowMalformed: function(codeUnits, allowMalformed) {
      allowMalformed = this._allowMalformed;
      return new P.Utf8Decoder(allowMalformed).convert$1(codeUnits);
    },
    decode$1: function(codeUnits) {
      return this.decode$2$allowMalformed(codeUnits, null);
    },
    get$encoder: function() {
      return new P.Utf8Encoder();
    }
  },
  Utf8Encoder: {
    "^": "Converter;",
    convert$1: function(string) {
      var t1, t2, encoder;
      t1 = J.getInterceptor$asx(string);
      t2 = Array(J.$mul$ns(t1.get$length(string), 3));
      t2.fixed$length = init;
      t2 = H.setRuntimeTypeInfo(t2, [P.$int]);
      encoder = new P._Utf8Encoder(0, 0, t2);
      if (encoder._fillBuffer$3(string, 0, t1.get$length(string)) !== t1.get$length(string))
        encoder._writeSurrogate$2(t1.codeUnitAt$1(string, J.$sub$n(t1.get$length(string), 1)), 0);
      return C.JSArray_methods.sublist$2(t2, 0, encoder._bufferIndex);
    },
    startChunkedConversion$1: function(sink) {
      var t1;
      sink = new P._ByteAdapterSink(sink);
      t1 = Array(1024);
      t1.fixed$length = init;
      return new P._Utf8EncoderSink(sink, 0, 0, H.setRuntimeTypeInfo(t1, [P.$int]));
    },
    $asConverter: function() {
      return [P.String, [P.List, P.$int]];
    }
  },
  _Utf8Encoder: {
    "^": "Object;_carry,_bufferIndex,_convert$_buffer",
    _writeSurrogate$2: function(leadingSurrogate, nextCodeUnit) {
      var t1, t2, rune, t3, t4;
      t1 = this._convert$_buffer;
      t2 = this._bufferIndex;
      if ((nextCodeUnit & 64512) === 56320) {
        rune = 65536 + ((leadingSurrogate & 1023) << 10 >>> 0) | nextCodeUnit & 1023;
        t3 = t2 + 1;
        this._bufferIndex = t3;
        t4 = t1.length;
        if (t2 >= t4)
          return H.ioore(t1, t2);
        t1[t2] = (240 | rune >>> 18) >>> 0;
        t2 = t3 + 1;
        this._bufferIndex = t2;
        if (t3 >= t4)
          return H.ioore(t1, t3);
        t1[t3] = 128 | rune >>> 12 & 63;
        t3 = t2 + 1;
        this._bufferIndex = t3;
        if (t2 >= t4)
          return H.ioore(t1, t2);
        t1[t2] = 128 | rune >>> 6 & 63;
        this._bufferIndex = t3 + 1;
        if (t3 >= t4)
          return H.ioore(t1, t3);
        t1[t3] = 128 | rune & 63;
        return true;
      } else {
        t3 = t2 + 1;
        this._bufferIndex = t3;
        t4 = t1.length;
        if (t2 >= t4)
          return H.ioore(t1, t2);
        t1[t2] = 224 | leadingSurrogate >>> 12;
        t2 = t3 + 1;
        this._bufferIndex = t2;
        if (t3 >= t4)
          return H.ioore(t1, t3);
        t1[t3] = 128 | leadingSurrogate >>> 6 & 63;
        this._bufferIndex = t2 + 1;
        if (t2 >= t4)
          return H.ioore(t1, t2);
        t1[t2] = 128 | leadingSurrogate & 63;
        return false;
      }
    },
    _fillBuffer$3: function(str, start, end) {
      var t1, t2, t3, stringIndex, codeUnit, t4, stringIndex0, t5;
      if (start !== end && (J.codeUnitAt$1$s(str, J.$sub$n(end, 1)) & 64512) === 55296)
        end = J.$sub$n(end, 1);
      if (typeof end !== "number")
        return H.iae(end);
      t1 = this._convert$_buffer;
      t2 = t1.length;
      t3 = J.getInterceptor$s(str);
      stringIndex = start;
      for (; stringIndex < end; ++stringIndex) {
        codeUnit = t3.codeUnitAt$1(str, stringIndex);
        if (codeUnit <= 127) {
          t4 = this._bufferIndex;
          if (t4 >= t2)
            break;
          this._bufferIndex = t4 + 1;
          t1[t4] = codeUnit;
        } else if ((codeUnit & 64512) === 55296) {
          if (this._bufferIndex + 3 >= t2)
            break;
          stringIndex0 = stringIndex + 1;
          if (this._writeSurrogate$2(codeUnit, t3.codeUnitAt$1(str, stringIndex0)))
            stringIndex = stringIndex0;
        } else if (codeUnit <= 2047) {
          t4 = this._bufferIndex;
          t5 = t4 + 1;
          if (t5 >= t2)
            break;
          this._bufferIndex = t5;
          if (t4 >= t2)
            return H.ioore(t1, t4);
          t1[t4] = 192 | codeUnit >>> 6;
          this._bufferIndex = t5 + 1;
          t1[t5] = 128 | codeUnit & 63;
        } else {
          t4 = this._bufferIndex;
          if (t4 + 2 >= t2)
            break;
          t5 = t4 + 1;
          this._bufferIndex = t5;
          if (t4 >= t2)
            return H.ioore(t1, t4);
          t1[t4] = 224 | codeUnit >>> 12;
          t4 = t5 + 1;
          this._bufferIndex = t4;
          if (t5 >= t2)
            return H.ioore(t1, t5);
          t1[t5] = 128 | codeUnit >>> 6 & 63;
          this._bufferIndex = t4 + 1;
          if (t4 >= t2)
            return H.ioore(t1, t4);
          t1[t4] = 128 | codeUnit & 63;
        }
      }
      return stringIndex;
    },
    static: {"^": "_Utf8Encoder__DEFAULT_BYTE_BUFFER_SIZE"}
  },
  _Utf8EncoderSink: {
    "^": "_Utf8Encoder_StringConversionSinkMixin;_sink,_carry,_bufferIndex,_convert$_buffer",
    close$0: function() {
      if (this._carry !== 0) {
        this.addSlice$4("", 0, 0, true);
        return;
      }
      this._sink._sink.close$0();
    },
    addSlice$4: function(str, start, end, isLast) {
      var t1, nextCodeUnit, t2, t3, t4, t5, isLastSlice;
      this._bufferIndex = 0;
      t1 = start === end;
      if (t1 && !isLast)
        return;
      if (this._carry !== 0) {
        nextCodeUnit = !t1 ? J.codeUnitAt$1$s(str, start) : 0;
        if (this._writeSurrogate$2(this._carry, nextCodeUnit))
          ++start;
        this._carry = 0;
      }
      t1 = this._sink;
      t2 = this._convert$_buffer;
      t3 = J.getInterceptor$n(end);
      t4 = J.getInterceptor$s(str);
      t5 = t2.length - 3;
      do {
        start = this._fillBuffer$3(str, start, end);
        isLastSlice = isLast && start === end;
        if (start === t3.$sub(end, 1) && (t4.codeUnitAt$1(str, start) & 64512) === 55296) {
          if (isLast && this._bufferIndex < t5)
            this._writeSurrogate$2(t4.codeUnitAt$1(str, start), 0);
          else
            this._carry = t4.codeUnitAt$1(str, start);
          ++start;
        }
        t1.add$1(0, C.JSArray_methods.sublist$2(t2, 0, this._bufferIndex));
        if (isLastSlice)
          t1.close$0();
        this._bufferIndex = 0;
        if (typeof end !== "number")
          return H.iae(end);
      } while (start < end);
      if (isLast)
        this.close$0();
    }
  },
  _Utf8Encoder_StringConversionSinkMixin: {
    "^": "_Utf8Encoder+StringConversionSinkMixin;"
  },
  Utf8Decoder: {
    "^": "Converter;_allowMalformed",
    convert$1: function(codeUnits) {
      var buffer, decoder;
      buffer = P.StringBuffer$("");
      decoder = new P._Utf8Decoder(this._allowMalformed, buffer, true, 0, 0, 0);
      decoder.convert$3(codeUnits, 0, J.get$length$asx(codeUnits));
      decoder.flush$0();
      return buffer._contents;
    },
    startChunkedConversion$1: function(sink) {
      var stringSink, t1;
      stringSink = new P._StringAdapterSink(sink);
      t1 = P.StringBuffer$("");
      return new P._Utf8ConversionSink(new P._Utf8Decoder(this._allowMalformed, t1, true, 0, 0, 0), stringSink, t1);
    },
    $asConverter: function() {
      return [[P.List, P.$int], P.String];
    }
  },
  _Utf8Decoder: {
    "^": "Object;_allowMalformed,_stringSink,_isFirstCharacter,_convert$_value,_expectedUnits,_extraUnits",
    close$0: function() {
      this.flush$0();
    },
    flush$0: function() {
      if (this._expectedUnits > 0) {
        if (this._allowMalformed !== true)
          throw H.wrapException(P.FormatException$("Unfinished UTF-8 octet sequence", null, null));
        this._stringSink.write$1(H.Primitives_stringFromCharCode(65533));
        this._convert$_value = 0;
        this._expectedUnits = 0;
        this._extraUnits = 0;
      }
    },
    convert$3: function(codeUnits, startIndex, endIndex) {
      var value, expectedUnits, extraUnits, t1, t2, t3, t4, t5, i, unit, t6, oneBytes, i0;
      value = this._convert$_value;
      expectedUnits = this._expectedUnits;
      extraUnits = this._extraUnits;
      this._convert$_value = 0;
      this._expectedUnits = 0;
      this._extraUnits = 0;
      t1 = new P._Utf8Decoder_convert_scanOneByteCharacters(endIndex);
      t2 = new P._Utf8Decoder_convert_addSingleBytes(this, codeUnits, startIndex, endIndex);
      $loop$0:
        for (t3 = this._stringSink, t4 = this._allowMalformed !== true, t5 = J.getInterceptor$asx(codeUnits), i = startIndex; true; i = i0) {
          $multibyte$2: {
            if (expectedUnits > 0) {
              do {
                if (i === endIndex)
                  break $loop$0;
                unit = t5.$index(codeUnits, i);
                t6 = J.getInterceptor$n(unit);
                if (t6.$and(unit, 192) !== 128) {
                  if (t4)
                    throw H.wrapException(P.FormatException$("Bad UTF-8 encoding 0x" + t6.toRadixString$1(unit, 16), null, null));
                  this._isFirstCharacter = false;
                  t6 = H.Primitives_stringFromCharCode(65533);
                  t3._contents += t6;
                  expectedUnits = 0;
                  break $multibyte$2;
                } else {
                  value = (value << 6 | t6.$and(unit, 63)) >>> 0;
                  --expectedUnits;
                  ++i;
                }
              } while (expectedUnits > 0);
              t6 = extraUnits - 1;
              if (t6 < 0 || t6 >= 4)
                return H.ioore(C.List_127_2047_65535_1114111, t6);
              if (value <= C.List_127_2047_65535_1114111[t6]) {
                if (t4)
                  throw H.wrapException(P.FormatException$("Overlong encoding of 0x" + C.JSInt_methods.toRadixString$1(value, 16), null, null));
                value = 65533;
                expectedUnits = 0;
                extraUnits = 0;
              }
              if (value > 1114111) {
                if (t4)
                  throw H.wrapException(P.FormatException$("Character outside valid Unicode range: 0x" + C.JSInt_methods.toRadixString$1(value, 16), null, null));
                value = 65533;
              }
              if (!this._isFirstCharacter || value !== 65279) {
                t6 = H.Primitives_stringFromCharCode(value);
                t3._contents += t6;
              }
              this._isFirstCharacter = false;
            }
          }
          if (typeof endIndex !== "number")
            return H.iae(endIndex);
          for (; i < endIndex; i = i0) {
            oneBytes = t1.call$2(codeUnits, i);
            if (J.$gt$n(oneBytes, 0)) {
              this._isFirstCharacter = false;
              if (typeof oneBytes !== "number")
                return H.iae(oneBytes);
              i0 = i + oneBytes;
              t2.call$2(i, i0);
              if (i0 === endIndex)
                break;
              i = i0;
            }
            i0 = i + 1;
            unit = t5.$index(codeUnits, i);
            t6 = J.getInterceptor$n(unit);
            if (t6.$lt(unit, 0)) {
              if (t4)
                throw H.wrapException(P.FormatException$("Negative UTF-8 code unit: -0x" + J.toRadixString$1$n(t6.$negate(unit), 16), null, null));
              t6 = H.Primitives_stringFromCharCode(65533);
              t3._contents += t6;
            } else {
              if (t6.$and(unit, 224) === 192) {
                value = t6.$and(unit, 31);
                expectedUnits = 1;
                extraUnits = 1;
                continue $loop$0;
              }
              if (t6.$and(unit, 240) === 224) {
                value = t6.$and(unit, 15);
                expectedUnits = 2;
                extraUnits = 2;
                continue $loop$0;
              }
              if (t6.$and(unit, 248) === 240 && t6.$lt(unit, 245)) {
                value = t6.$and(unit, 7);
                expectedUnits = 3;
                extraUnits = 3;
                continue $loop$0;
              }
              if (t4)
                throw H.wrapException(P.FormatException$("Bad UTF-8 encoding 0x" + t6.toRadixString$1(unit, 16), null, null));
              this._isFirstCharacter = false;
              t6 = H.Primitives_stringFromCharCode(65533);
              t3._contents += t6;
              value = 65533;
              expectedUnits = 0;
              extraUnits = 0;
            }
          }
          break $loop$0;
        }
      if (expectedUnits > 0) {
        this._convert$_value = value;
        this._expectedUnits = expectedUnits;
        this._extraUnits = extraUnits;
      }
    },
    static: {"^": "_Utf8Decoder__LIMITS"}
  },
  _Utf8Decoder_convert_scanOneByteCharacters: {
    "^": "Closure:86;endIndex_0",
    call$2: function(units, from) {
      var to, t1, i, unit;
      to = this.endIndex_0;
      if (typeof to !== "number")
        return H.iae(to);
      t1 = J.getInterceptor$asx(units);
      i = from;
      for (; i < to; ++i) {
        unit = t1.$index(units, i);
        if (J.$and$n(unit, 127) !== unit)
          return i - from;
      }
      return to - from;
    },
    $isFunction: true
  },
  _Utf8Decoder_convert_addSingleBytes: {
    "^": "Closure:87;this_1,codeUnits_2,startIndex_3,endIndex_4",
    call$2: function(from, to) {
      var t1, t2, t3;
      t1 = from === 0 && to === J.get$length$asx(this.codeUnits_2);
      t2 = this.this_1;
      t3 = this.codeUnits_2;
      if (t1)
        t2._stringSink.write$1(P.String_String$fromCharCodes(t3));
      else
        t2._stringSink.write$1(P.String_String$fromCharCodes(J.sublist$2$ax(t3, from, to)));
    },
    $isFunction: true
  }
}],
["dart.core", "dart:core", , P, {
  "^": "",
  Function__toMangledNames: function(namedArguments) {
    return;
  },
  Comparable_compare: [function(a, b) {
    return J.compareTo$1$ns(a, b);
  }, "call$2", "Comparable_compare$closure", 4, 0, 47],
  Exception_Exception: function(message) {
    return new P._ExceptionImplementation(message);
  },
  identical: [function(a, b) {
    return a == null ? b == null : a === b;
  }, "call$2", "identical$closure", 4, 0, 48],
  identityHashCode: [function(object) {
    return H.objectHashCode(object);
  }, "call$1", "identityHashCode$closure", 2, 0, 49],
  List_List$filled: function($length, fill, $E) {
    var result, t1, i;
    result = J.JSArray_JSArray$fixed($length, $E);
    if ($length !== 0 && true)
      for (t1 = result.length, i = 0; i < t1; ++i)
        result[i] = fill;
    return result;
  },
  List_List$from: function(other, growable, $E) {
    var list, t1;
    list = H.setRuntimeTypeInfo([], [$E]);
    for (t1 = J.get$iterator$ax(other); t1.moveNext$0();)
      list.push(t1.get$current());
    if (growable)
      return list;
    list.fixed$length = init;
    return list;
  },
  List_List$generate: function($length, generator, growable, $E) {
    var result, t1, i;
    if (growable) {
      result = H.setRuntimeTypeInfo([], [$E]);
      C.JSArray_methods.set$length(result, $length);
    } else {
      t1 = Array($length);
      t1.fixed$length = init;
      result = H.setRuntimeTypeInfo(t1, [$E]);
    }
    for (i = 0; i < $length; ++i) {
      t1 = generator.call$1(i);
      if (i >= result.length)
        return H.ioore(result, i);
      result[i] = t1;
    }
    return result;
  },
  print: function(object) {
    var line, t1;
    line = H.S(object);
    t1 = $.printToZone;
    if (t1 == null)
      H.printString(line);
    else
      t1.call$1(line);
  },
  String_String$fromCharCodes: function(charCodes) {
    return H.Primitives_stringFromCharCodes(typeof charCodes !== "object" || charCodes === null || charCodes.constructor !== Array ? P.List_List$from(charCodes, true, null) : charCodes);
  },
  String_String$fromCharCode: function(charCode) {
    return H.Primitives_stringFromCharCode(charCode);
  },
  Function__toMangledNames_closure: {
    "^": "Closure:56;result_0",
    call$2: function(symbol, value) {
      this.result_0.$indexSet(0, symbol.get$_name(), value);
    },
    $isFunction: true
  },
  NoSuchMethodError_toString_closure: {
    "^": "Closure:88;box_0",
    call$2: function(key, value) {
      var t1 = this.box_0;
      if (t1.i_1 > 0)
        t1.sb_0.write$1(", ");
      t1.sb_0.write$1(key.get$_name());
      t1.sb_0.write$1(": ");
      t1.sb_0.write$1(P.Error_safeToString(value));
      ++t1.i_1;
    },
    $isFunction: true
  },
  bool: {
    "^": "Object;",
    $isbool: true
  },
  "+bool": 0,
  Comparable: {
    "^": "Object;"
  },
  DateTime: {
    "^": "Object;millisecondsSinceEpoch<,isUtc",
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isDateTime)
        return false;
      t1 = this.millisecondsSinceEpoch;
      t2 = other.millisecondsSinceEpoch;
      return (t1 == null ? t2 == null : t1 === t2) && J.$eq(this.isUtc, other.isUtc);
    },
    compareTo$1: function(_, other) {
      return J.compareTo$1$ns(this.millisecondsSinceEpoch, other.get$millisecondsSinceEpoch());
    },
    get$hashCode: function(_) {
      return this.millisecondsSinceEpoch;
    },
    toUtc$0: function() {
      if (this.isUtc === true)
        return this;
      return P.DateTime$fromMillisecondsSinceEpoch(this.millisecondsSinceEpoch, true);
    },
    toString$0: function(_) {
      var y, m, d, h, min, sec, ms;
      y = P.DateTime__fourDigits(H.Primitives_getYear(this));
      m = P.DateTime__twoDigits(H.Primitives_getMonth(this));
      d = P.DateTime__twoDigits(H.Primitives_getDay(this));
      h = P.DateTime__twoDigits(H.Primitives_getHours(this));
      min = P.DateTime__twoDigits(H.Primitives_getMinutes(this));
      sec = P.DateTime__twoDigits(H.Primitives_getSeconds(this));
      ms = P.DateTime__threeDigits(H.Primitives_getMilliseconds(this));
      if (this.isUtc === true)
        return y + "-" + m + "-" + d + " " + h + ":" + min + ":" + sec + "." + ms + "Z";
      else
        return y + "-" + m + "-" + d + " " + h + ":" + min + ":" + sec + "." + ms;
    },
    add$1: [function(_, duration) {
      var ms, t1;
      ms = this.millisecondsSinceEpoch;
      t1 = duration.get$inMilliseconds();
      if (typeof ms !== "number")
        return ms.$add();
      return P.DateTime$fromMillisecondsSinceEpoch(ms + t1, this.isUtc);
    }, "call$1", "get$add", 2, 0, 89],
    DateTime$fromMillisecondsSinceEpoch$2$isUtc: function(millisecondsSinceEpoch, isUtc) {
      millisecondsSinceEpoch.toString;
      if (Math.abs(millisecondsSinceEpoch) > 8640000000000000)
        throw H.wrapException(P.ArgumentError$(millisecondsSinceEpoch));
      if (isUtc == null)
        throw H.wrapException(P.ArgumentError$(isUtc));
    },
    DateTime$_now$0: function() {
      H.Primitives_lazyAsJsDate(this);
    },
    $isDateTime: true,
    static: {"^": "DateTime_MONDAY,DateTime_TUESDAY,DateTime_WEDNESDAY,DateTime_THURSDAY,DateTime_FRIDAY,DateTime_SATURDAY,DateTime_SUNDAY,DateTime_DAYS_PER_WEEK,DateTime_JANUARY,DateTime_FEBRUARY,DateTime_MARCH,DateTime_APRIL,DateTime_MAY,DateTime_JUNE,DateTime_JULY,DateTime_AUGUST,DateTime_SEPTEMBER,DateTime_OCTOBER,DateTime_NOVEMBER,DateTime_DECEMBER,DateTime_MONTHS_PER_YEAR,DateTime__MAX_MILLISECONDS_SINCE_EPOCH", DateTime$fromMillisecondsSinceEpoch: function(millisecondsSinceEpoch, isUtc) {
        var t1 = new P.DateTime(millisecondsSinceEpoch, isUtc);
        t1.DateTime$fromMillisecondsSinceEpoch$2$isUtc(millisecondsSinceEpoch, isUtc);
        return t1;
      }, DateTime__fourDigits: function(n) {
        var absN, sign;
        absN = Math.abs(n);
        sign = n < 0 ? "-" : "";
        if (absN >= 1000)
          return "" + n;
        if (absN >= 100)
          return sign + "0" + H.S(absN);
        if (absN >= 10)
          return sign + "00" + H.S(absN);
        return sign + "000" + H.S(absN);
      }, DateTime__threeDigits: function(n) {
        if (n >= 100)
          return "" + n;
        if (n >= 10)
          return "0" + n;
        return "00" + n;
      }, DateTime__twoDigits: function(n) {
        if (n >= 10)
          return "" + n;
        return "0" + n;
      }}
  },
  $double: {
    "^": "num;",
    $is$double: true
  },
  "+double": 0,
  Duration: {
    "^": "Object;_duration<",
    $add: function(_, other) {
      return P.Duration$(0, 0, this._duration + other.get$_duration(), 0, 0, 0);
    },
    $sub: function(_, other) {
      return P.Duration$(0, 0, C.JSNumber_methods.$sub(this._duration, other.get$_duration()), 0, 0, 0);
    },
    $mul: function(_, factor) {
      return P.Duration$(0, 0, C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(this._duration * factor)), 0, 0, 0);
    },
    $tdiv: function(_, quotient) {
      if (quotient === 0)
        throw H.wrapException(P.IntegerDivisionByZeroException$());
      return P.Duration$(0, 0, C.JSNumber_methods.$tdiv(this._duration, quotient), 0, 0, 0);
    },
    $lt: function(_, other) {
      return C.JSNumber_methods.$lt(this._duration, other.get$_duration());
    },
    $gt: function(_, other) {
      return C.JSNumber_methods.$gt(this._duration, other.get$_duration());
    },
    $ge: function(_, other) {
      return C.JSNumber_methods.$ge(this._duration, other.get$_duration());
    },
    get$inMilliseconds: function() {
      return C.JSNumber_methods._tdivFast$1(this._duration, 1000);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isDuration)
        return false;
      return this._duration === other._duration;
    },
    get$hashCode: function(_) {
      return this._duration & 0x1FFFFFFF;
    },
    compareTo$1: function(_, other) {
      return C.JSNumber_methods.compareTo$1(this._duration, other.get$_duration());
    },
    toString$0: function(_) {
      var t1, t2, twoDigitMinutes, twoDigitSeconds, sixDigitUs;
      t1 = new P.Duration_toString_twoDigits();
      t2 = this._duration;
      if (t2 < 0)
        return "-" + P.Duration$(0, 0, -t2, 0, 0, 0).toString$0(0);
      twoDigitMinutes = t1.call$1(C.JSNumber_methods.remainder$1(C.JSNumber_methods._tdivFast$1(t2, 60000000), 60));
      twoDigitSeconds = t1.call$1(C.JSNumber_methods.remainder$1(C.JSNumber_methods._tdivFast$1(t2, 1000000), 60));
      sixDigitUs = new P.Duration_toString_sixDigits().call$1(C.JSNumber_methods.remainder$1(t2, 1000000));
      return H.S(C.JSNumber_methods._tdivFast$1(t2, 3600000000)) + ":" + H.S(twoDigitMinutes) + ":" + H.S(twoDigitSeconds) + "." + H.S(sixDigitUs);
    },
    $negate: function(_) {
      return P.Duration$(0, 0, -this._duration, 0, 0, 0);
    },
    $isDuration: true,
    static: {"^": "Duration_MICROSECONDS_PER_MILLISECOND,Duration_MILLISECONDS_PER_SECOND,Duration_SECONDS_PER_MINUTE,Duration_MINUTES_PER_HOUR,Duration_HOURS_PER_DAY,Duration_MICROSECONDS_PER_SECOND,Duration_MICROSECONDS_PER_MINUTE,Duration_MICROSECONDS_PER_HOUR,Duration_MICROSECONDS_PER_DAY,Duration_MILLISECONDS_PER_MINUTE,Duration_MILLISECONDS_PER_HOUR,Duration_MILLISECONDS_PER_DAY,Duration_SECONDS_PER_HOUR,Duration_SECONDS_PER_DAY,Duration_MINUTES_PER_DAY,Duration_ZERO", Duration$: function(days, hours, microseconds, milliseconds, minutes, seconds) {
        return new P.Duration(days * 86400000000 + hours * 3600000000 + minutes * 60000000 + seconds * 1000000 + milliseconds * 1000 + microseconds);
      }}
  },
  Duration_toString_sixDigits: {
    "^": "Closure:90;",
    call$1: function(n) {
      if (n >= 100000)
        return H.S(n);
      if (n >= 10000)
        return "0" + H.S(n);
      if (n >= 1000)
        return "00" + H.S(n);
      if (n >= 100)
        return "000" + H.S(n);
      if (n >= 10)
        return "0000" + H.S(n);
      return "00000" + H.S(n);
    },
    $isFunction: true
  },
  Duration_toString_twoDigits: {
    "^": "Closure:90;",
    call$1: function(n) {
      if (n >= 10)
        return H.S(n);
      return "0" + H.S(n);
    },
    $isFunction: true
  },
  Error: {
    "^": "Object;",
    get$stackTrace: function() {
      return new H._StackTrace(this.$thrownJsError, null);
    },
    $isError: true,
    static: {Error$: function() {
        return new P.Error();
      }, Error_safeToString: function(object) {
        var buffer, t1, i, t2, codeUnit;
        if (typeof object === "number" || typeof object === "boolean" || null == object)
          return J.toString$0(object);
        if (typeof object === "string") {
          buffer = new P.StringBuffer("");
          buffer._contents = "\"";
          for (t1 = object.length, i = 0, t2 = "\""; i < t1; ++i) {
            codeUnit = C.JSString_methods.codeUnitAt$1(object, i);
            if (codeUnit <= 31)
              if (codeUnit === 10)
                t2 = buffer._contents += "\\n";
              else if (codeUnit === 13)
                t2 = buffer._contents += "\\r";
              else if (codeUnit === 9)
                t2 = buffer._contents += "\\t";
              else {
                t2 = buffer._contents += "\\x";
                if (codeUnit < 16)
                  buffer._contents = t2 + "0";
                else {
                  buffer._contents = t2 + "1";
                  codeUnit -= 16;
                }
                t2 = H.Primitives_stringFromCharCode(codeUnit < 10 ? 48 + codeUnit : 87 + codeUnit);
                t2 = buffer._contents += t2;
              }
            else if (codeUnit === 92)
              t2 = buffer._contents += "\\\\";
            else if (codeUnit === 34)
              t2 = buffer._contents += "\\\"";
            else {
              t2 = H.Primitives_stringFromCharCode(codeUnit);
              t2 = buffer._contents += t2;
            }
          }
          t1 = t2 + "\"";
          buffer._contents = t1;
          return t1;
        }
        return "Instance of '" + H.Primitives_objectTypeName(object) + "'";
      }}
  },
  NullThrownError: {
    "^": "Error;",
    toString$0: function(_) {
      return "Throw of null.";
    }
  },
  ArgumentError: {
    "^": "Error;message<",
    toString$0: function(_) {
      var t1 = this.message;
      if (t1 != null)
        return "Illegal argument(s): " + H.S(t1);
      return "Illegal argument(s)";
    },
    static: {ArgumentError$: function(message) {
        return new P.ArgumentError(message);
      }}
  },
  RangeError: {
    "^": "ArgumentError;message",
    toString$0: function(_) {
      return "RangeError: " + H.S(this.message);
    },
    static: {RangeError$: function(message) {
        return new P.RangeError(message);
      }, RangeError$value: function(value) {
        return new P.RangeError("value " + H.S(value));
      }, RangeError$range: function(value, start, end) {
        return new P.RangeError("value " + H.S(value) + " not in range " + H.S(start) + ".." + H.S(end));
      }}
  },
  UnsupportedError: {
    "^": "Error;message<",
    toString$0: function(_) {
      return "Unsupported operation: " + this.message;
    },
    $isUnsupportedError: true,
    static: {UnsupportedError$: function(message) {
        return new P.UnsupportedError(message);
      }}
  },
  UnimplementedError: {
    "^": "Error;message<",
    toString$0: function(_) {
      var t1 = this.message;
      return t1 != null ? "UnimplementedError: " + H.S(t1) : "UnimplementedError";
    },
    $isUnsupportedError: true,
    $isError: true,
    static: {UnimplementedError$: function(message) {
        return new P.UnimplementedError(message);
      }}
  },
  StateError: {
    "^": "Error;message<",
    toString$0: function(_) {
      return "Bad state: " + this.message;
    },
    $isStateError: true,
    static: {StateError$: function(message) {
        return new P.StateError(message);
      }}
  },
  ConcurrentModificationError: {
    "^": "Error;modifiedObject",
    toString$0: function(_) {
      var t1 = this.modifiedObject;
      if (t1 == null)
        return "Concurrent modification during iteration.";
      return "Concurrent modification during iteration: " + H.S(P.Error_safeToString(t1)) + ".";
    },
    static: {ConcurrentModificationError$: function(modifiedObject) {
        return new P.ConcurrentModificationError(modifiedObject);
      }}
  },
  OutOfMemoryError: {
    "^": "Object;",
    toString$0: function(_) {
      return "Out of Memory";
    },
    get$stackTrace: function() {
      return;
    },
    $isError: true
  },
  StackOverflowError: {
    "^": "Object;",
    toString$0: function(_) {
      return "Stack Overflow";
    },
    get$stackTrace: function() {
      return;
    },
    $isError: true
  },
  CyclicInitializationError: {
    "^": "Error;variableName",
    toString$0: function(_) {
      return "Reading static variable '" + this.variableName + "' during its initialization";
    },
    static: {CyclicInitializationError$: function(variableName) {
        return new P.CyclicInitializationError(variableName);
      }}
  },
  _ExceptionImplementation: {
    "^": "Object;message<",
    toString$0: function(_) {
      var t1 = this.message;
      if (t1 == null)
        return "Exception";
      return "Exception: " + H.S(t1);
    }
  },
  FormatException: {
    "^": "Object;message<,source,offset",
    toString$0: function(_) {
      var t1, report, offset, source, lineNum, lineStart, lastWasCR, i, $char, lineEnd, t2, end, start, prefix, postfix, slice;
      t1 = this.message;
      report = t1 != null && "" !== t1 ? "FormatException: " + H.S(t1) : "FormatException";
      offset = this.offset;
      source = this.source;
      if (typeof source !== "string")
        return offset != null ? report + (" (at offset " + H.S(offset) + ")") : report;
      if (offset != null) {
        t1 = J.getInterceptor$n(offset);
        t1 = t1.$lt(offset, 0) || t1.$gt(offset, J.get$length$asx(source));
      } else
        t1 = false;
      if (t1)
        offset = null;
      if (offset == null) {
        t1 = J.getInterceptor$asx(source);
        if (J.$gt$n(t1.get$length(source), 78))
          source = t1.substring$2(source, 0, 75) + "...";
        return report + "\n" + H.S(source);
      }
      if (typeof offset !== "number")
        return H.iae(offset);
      t1 = J.getInterceptor$asx(source);
      lineNum = 1;
      lineStart = 0;
      lastWasCR = null;
      i = 0;
      for (; i < offset; ++i) {
        $char = t1.codeUnitAt$1(source, i);
        if ($char === 10) {
          if (lineStart !== i || lastWasCR !== true)
            ++lineNum;
          lineStart = i + 1;
          lastWasCR = false;
        } else if ($char === 13) {
          ++lineNum;
          lineStart = i + 1;
          lastWasCR = true;
        }
      }
      report = lineNum > 1 ? report + (" (at line " + lineNum + ", character " + H.S(offset - lineStart + 1) + ")\n") : report + (" (at character " + H.S(offset + 1) + ")\n");
      lineEnd = t1.get$length(source);
      i = offset;
      while (true) {
        t2 = t1.get$length(source);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        $char = t1.codeUnitAt$1(source, i);
        if ($char === 10 || $char === 13) {
          lineEnd = i;
          break;
        }
        ++i;
      }
      t2 = J.getInterceptor$n(lineEnd);
      if (t2.$sub(lineEnd, lineStart) > 78)
        if (offset - lineStart < 75) {
          end = lineStart + 75;
          start = lineStart;
          prefix = "";
          postfix = "...";
        } else {
          if (t2.$sub(lineEnd, offset) < 75) {
            start = t2.$sub(lineEnd, 75);
            end = lineEnd;
            postfix = "";
          } else {
            start = offset - 36;
            end = offset + 36;
            postfix = "...";
          }
          prefix = "...";
        }
      else {
        end = lineEnd;
        start = lineStart;
        prefix = "";
        postfix = "";
      }
      slice = t1.substring$2(source, start, end);
      return report + prefix + slice + postfix + "\n" + C.JSString_methods.$mul(" ", offset - start + prefix.length) + "^\n";
    },
    $isFormatException: true,
    static: {FormatException$: function(message, source, offset) {
        return new P.FormatException(message, source, offset);
      }}
  },
  IntegerDivisionByZeroException: {
    "^": "Object;",
    toString$0: function(_) {
      return "IntegerDivisionByZeroException";
    },
    static: {IntegerDivisionByZeroException$: function() {
        return new P.IntegerDivisionByZeroException();
      }}
  },
  Expando: {
    "^": "Object;name<",
    toString$0: function(_) {
      return "Expando:" + H.S(this.name);
    },
    $index: function(_, object) {
      var values = H.Primitives_getProperty(object, "expando$values");
      return values == null ? null : H.Primitives_getProperty(values, this._getKey$0());
    },
    $indexSet: function(_, object, value) {
      var values = H.Primitives_getProperty(object, "expando$values");
      if (values == null) {
        values = new P.Object();
        H.Primitives_setProperty(object, "expando$values", values);
      }
      H.Primitives_setProperty(values, this._getKey$0(), value);
    },
    _getKey$0: function() {
      var key, t1;
      key = H.Primitives_getProperty(this, "expando$key");
      if (key == null) {
        t1 = $.Expando__keyCount;
        $.Expando__keyCount = t1 + 1;
        key = "expando$key$" + t1;
        H.Primitives_setProperty(this, "expando$key", key);
      }
      return key;
    },
    static: {"^": "Expando__KEY_PROPERTY_NAME,Expando__EXPANDO_PROPERTY_NAME,Expando__keyCount"}
  },
  Function: {
    "^": "Object;",
    $isFunction: true
  },
  $int: {
    "^": "num;",
    $is$int: true
  },
  "+int": 0,
  Iterator: {
    "^": "Object;"
  },
  List: {
    "^": "Object;",
    $isList: true,
    $asList: null,
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: null
  },
  "+List": 0,
  Map: {
    "^": "Object;",
    $isMap: true
  },
  Null: {
    "^": "Object;",
    toString$0: function(_) {
      return "null";
    }
  },
  "+Null": 0,
  num: {
    "^": "Object;",
    $isnum: true
  },
  "+num": 0,
  Object: {
    "^": ";",
    $eq: function(_, other) {
      return this === other;
    },
    get$hashCode: function(_) {
      return H.Primitives_objectHashCode(this);
    },
    toString$0: function(_) {
      return H.Primitives_objectToString(this);
    },
    get$runtimeType: function(_) {
      return new H.TypeImpl(H.getRuntimeTypeString(this), null);
    }
  },
  Match: {
    "^": "Object;"
  },
  StackTrace: {
    "^": "Object;",
    $isStackTrace: true
  },
  String: {
    "^": "Object;",
    $isString: true
  },
  "+String": 0,
  StringBuffer: {
    "^": "Object;_contents<",
    get$length: function(_) {
      return this._contents.length;
    },
    get$isEmpty: function(_) {
      return this._contents.length === 0;
    },
    get$isNotEmpty: function(_) {
      return this._contents.length !== 0;
    },
    write$1: function(obj) {
      this._contents += typeof obj === "string" ? obj : H.S(obj);
    },
    writeCharCode$1: function(charCode) {
      this.write$1(H.Primitives_stringFromCharCode(charCode));
    },
    writeAll$2: function(objects, separator) {
      var iterator, str;
      iterator = J.get$iterator$ax(objects);
      if (!iterator.moveNext$0())
        return;
      if (separator.length === 0) {
        do {
          str = iterator.get$current();
          this._contents += typeof str === "string" ? str : H.S(str);
        } while (iterator.moveNext$0());
      } else {
        this.write$1(iterator.get$current());
        for (; iterator.moveNext$0();) {
          this._contents += separator;
          str = iterator.get$current();
          this._contents += typeof str === "string" ? str : H.S(str);
        }
      }
    },
    toString$0: function(_) {
      return this._contents;
    },
    StringBuffer$1: function($content) {
      this._contents = $content;
    },
    static: {StringBuffer$: function($content) {
        var t1 = new P.StringBuffer("");
        t1.StringBuffer$1($content);
        return t1;
      }}
  },
  Symbol0: {
    "^": "Object;"
  },
  Uri: {
    "^": "Object;_host,_port,_path,scheme<,_userInfo,_query,_fragment,_pathSegments,_queryParameters",
    get$host: function() {
      var t1 = this._host;
      if (t1 == null)
        return "";
      if (J.getInterceptor$s(t1).startsWith$1(t1, "["))
        return C.JSString_methods.substring$2(t1, 1, t1.length - 1);
      return t1;
    },
    get$port: function() {
      var t1 = this._port;
      if (t1 == null)
        return P.Uri__defaultPort(this.scheme);
      return t1;
    },
    get$path: function() {
      return this._path;
    },
    get$query: function() {
      var t1 = this._query;
      return t1 == null ? "" : t1;
    },
    get$pathSegments: function() {
      var t1, pathToSplit;
      t1 = this._pathSegments;
      if (t1 == null) {
        pathToSplit = this._path;
        if (pathToSplit.length !== 0 && C.JSString_methods.codeUnitAt$1(pathToSplit, 0) === 47)
          pathToSplit = C.JSString_methods.substring$1(pathToSplit, 1);
        t1 = pathToSplit === "" ? C.List_empty0 : H.setRuntimeTypeInfo(new H.MappedListIterable(pathToSplit.split("/"), P.Uri_decodeComponent$closure()), [null, null]).toList$1$growable(0, false);
        t1 = H.setRuntimeTypeInfo(new P.UnmodifiableListView(t1), [null]);
        this._pathSegments = t1;
      }
      return t1;
    },
    _merge$2: function(base, reference) {
      if (base === "")
        return "/" + reference;
      return C.JSString_methods.substring$2(base, 0, C.JSString_methods.lastIndexOf$1(base, "/") + 1) + reference;
    },
    _hasDotSegments$1: function(path) {
      if (path.length > 0 && C.JSString_methods.codeUnitAt$1(path, 0) === 58)
        return true;
      return C.JSString_methods.indexOf$1(path, "/.") !== -1;
    },
    _removeDotSegments$1: function(path) {
      var output, t1, appendSlash, segment, t2;
      if (!this._hasDotSegments$1(path))
        return path;
      output = [];
      for (t1 = path.split("/"), t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]), appendSlash = false; t1.moveNext$0();) {
        segment = t1._current;
        if (J.$eq(segment, "..")) {
          t2 = output.length;
          if (t2 !== 0)
            if (t2 === 1) {
              if (0 >= t2)
                return H.ioore(output, 0);
              t2 = !J.$eq(output[0], "");
            } else
              t2 = true;
          else
            t2 = false;
          if (t2) {
            if (0 >= output.length)
              return H.ioore(output, 0);
            output.pop();
          }
          appendSlash = true;
        } else if ("." === segment)
          appendSlash = true;
        else {
          output.push(segment);
          appendSlash = false;
        }
      }
      if (appendSlash)
        output.push("");
      return C.JSArray_methods.join$1(output, "/");
    },
    resolveUri$1: function(reference) {
      var targetScheme, targetUserInfo, targetHost, targetPort, targetPath, targetQuery, t1, fragment;
      targetScheme = reference.scheme;
      if (targetScheme.length !== 0) {
        if (reference._host != null) {
          targetUserInfo = reference._userInfo;
          targetHost = reference.get$host();
          targetPort = reference._port != null ? reference.get$port() : null;
        } else {
          targetUserInfo = "";
          targetHost = null;
          targetPort = null;
        }
        targetPath = this._removeDotSegments$1(reference._path);
        targetQuery = reference._query;
        if (targetQuery != null)
          ;
        else
          targetQuery = null;
      } else {
        targetScheme = this.scheme;
        if (reference._host != null) {
          targetUserInfo = reference._userInfo;
          targetHost = reference.get$host();
          targetPort = P.Uri__makePort(reference._port != null ? reference.get$port() : null, targetScheme);
          targetPath = this._removeDotSegments$1(reference._path);
          targetQuery = reference._query;
          if (targetQuery != null)
            ;
          else
            targetQuery = null;
        } else {
          t1 = reference._path;
          if (t1 === "") {
            targetPath = this._path;
            targetQuery = reference._query;
            if (targetQuery != null)
              ;
            else
              targetQuery = this._query;
          } else {
            targetPath = C.JSString_methods.startsWith$1(t1, "/") ? this._removeDotSegments$1(t1) : this._removeDotSegments$1(this._merge$2(this._path, t1));
            targetQuery = reference._query;
            if (targetQuery != null)
              ;
            else
              targetQuery = null;
          }
          targetUserInfo = this._userInfo;
          targetHost = this._host;
          targetPort = this._port;
        }
      }
      fragment = reference._fragment;
      if (fragment != null)
        ;
      else
        fragment = null;
      return new P.Uri(targetHost, targetPort, targetPath, targetScheme, targetUserInfo, targetQuery, fragment, null, null);
    },
    toFilePath$1$windows: function(windows) {
      var t1, result;
      t1 = this.scheme;
      if (t1 !== "" && t1 !== "file")
        throw H.wrapException(P.UnsupportedError$("Cannot extract a file path from a " + t1 + " URI"));
      t1 = this._query;
      if ((t1 == null ? "" : t1) !== "")
        throw H.wrapException(P.UnsupportedError$("Cannot extract a file path from a URI with a query component"));
      t1 = this._fragment;
      if ((t1 == null ? "" : t1) !== "")
        throw H.wrapException(P.UnsupportedError$("Cannot extract a file path from a URI with a fragment component"));
      if (this.get$host() !== "")
        H.throwExpression(P.UnsupportedError$("Cannot extract a non-Windows file path from a file URI with an authority"));
      P.Uri__checkNonWindowsPathReservedCharacters(this.get$pathSegments(), false);
      result = P.StringBuffer$("");
      if (this.get$_isPathAbsolute())
        result.write$1("/");
      result.writeAll$2(this.get$pathSegments(), "/");
      t1 = result._contents;
      return t1;
    },
    toFilePath$0: function() {
      return this.toFilePath$1$windows(null);
    },
    get$_isPathAbsolute: function() {
      if (this._path.length === 0)
        return false;
      return C.JSString_methods.startsWith$1(this._path, "/");
    },
    toString$0: function(_) {
      var sb, t1, t2, t3;
      sb = P.StringBuffer$("");
      t1 = this.scheme;
      if ("" !== t1) {
        sb.write$1(t1);
        sb.write$1(":");
      }
      t2 = this._host;
      t3 = t2 == null;
      if (!t3 || C.JSString_methods.startsWith$1(this._path, "//") || t1 === "file") {
        sb.write$1("//");
        t1 = this._userInfo;
        if (t1.length !== 0) {
          sb.write$1(t1);
          sb.write$1("@");
        }
        if (!t3)
          sb.write$1(t2);
        t1 = this._port;
        if (t1 != null) {
          sb.write$1(":");
          sb.write$1(t1);
        }
      }
      sb.write$1(this._path);
      t1 = this._query;
      if (t1 != null) {
        sb.write$1("?");
        sb.write$1(t1);
      }
      t1 = this._fragment;
      if (t1 != null) {
        sb.write$1("#");
        sb.write$1(t1);
      }
      return sb._contents;
    },
    $eq: function(_, other) {
      var t1, t2, t3, t4;
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isUri)
        return false;
      if (this.scheme === other.scheme)
        if (this._host != null === (other._host != null))
          if (this._userInfo === other._userInfo) {
            t1 = this.get$host();
            t2 = other.get$host();
            if (t1 == null ? t2 == null : t1 === t2) {
              t1 = this.get$port();
              t2 = other.get$port();
              if (t1 == null ? t2 == null : t1 === t2)
                if (this._path === other._path) {
                  t1 = this._query;
                  t2 = t1 == null;
                  t3 = other._query;
                  t4 = t3 == null;
                  if (!t2 === !t4) {
                    if (t2)
                      t1 = "";
                    if (t1 == null ? (t4 ? "" : t3) == null : t1 === (t4 ? "" : t3)) {
                      t1 = this._fragment;
                      t2 = t1 == null;
                      t3 = other._fragment;
                      t4 = t3 == null;
                      if (!t2 === !t4) {
                        if (t2)
                          t1 = "";
                        t1 = t1 == null ? (t4 ? "" : t3) == null : t1 === (t4 ? "" : t3);
                      } else
                        t1 = false;
                    } else
                      t1 = false;
                  } else
                    t1 = false;
                } else
                  t1 = false;
              else
                t1 = false;
            } else
              t1 = false;
          } else
            t1 = false;
        else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      var t1, t2, t3, t4, t5;
      t1 = new P.Uri_hashCode_combine();
      t2 = this.get$host();
      t3 = this.get$port();
      t4 = this._query;
      if (t4 == null)
        t4 = "";
      t5 = this._fragment;
      return t1.call$2(this.scheme, t1.call$2(this._userInfo, t1.call$2(t2, t1.call$2(t3, t1.call$2(this._path, t1.call$2(t4, t1.call$2(t5 == null ? "" : t5, 1)))))));
    },
    $isUri: true,
    static: {"^": "Uri__SPACE,Uri__DOUBLE_QUOTE,Uri__NUMBER_SIGN,Uri__PERCENT,Uri__ASTERISK,Uri__PLUS,Uri__SLASH,Uri__ZERO,Uri__NINE,Uri__COLON,Uri__LESS,Uri__GREATER,Uri__QUESTION,Uri__AT_SIGN,Uri__UPPER_CASE_A,Uri__UPPER_CASE_F,Uri__UPPER_CASE_Z,Uri__LEFT_BRACKET,Uri__BACKSLASH,Uri__RIGHT_BRACKET,Uri__LOWER_CASE_A,Uri__LOWER_CASE_F,Uri__LOWER_CASE_Z,Uri__BAR,Uri__unreservedTable,Uri__unreserved2396Table,Uri__encodeFullTable,Uri__schemeTable,Uri__schemeLowerTable,Uri__subDelimitersTable,Uri__genDelimitersTable,Uri__userinfoTable,Uri__regNameTable,Uri__pathCharTable,Uri__pathCharOrSlashTable,Uri__queryCharTable", Uri__defaultPort: function(scheme) {
        if (scheme === "http")
          return 80;
        if (scheme === "https")
          return 443;
        return 0;
      }, Uri_parse: function(uri) {
        var t1, pathStart, state, t2, i, t3, $char, index, t4, path, numberSignIndex, query, fragment;
        t1 = {};
        t1.scheme_0 = "";
        t1.userinfo_1 = "";
        t1.host_2 = null;
        t1.port_3 = null;
        t1.index_4 = 0;
        t1.char_5 = -1;
        t2 = J.getInterceptor$asx(uri);
        i = 0;
        while (true) {
          t3 = t2.get$length(uri);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(i < t3)) {
            pathStart = 0;
            state = 0;
            break;
          }
          $char = t2.codeUnitAt$1(uri, i);
          t1.char_5 = $char;
          if ($char === 63 || $char === 35) {
            pathStart = 0;
            state = 0;
            break;
          }
          if ($char === 47) {
            state = i === 0 ? 2 : 1;
            pathStart = 0;
            break;
          }
          if ($char === 58) {
            if (i === 0)
              P.Uri__fail(uri, 0, "Invalid empty scheme");
            t1.scheme_0 = P.Uri__makeScheme(uri, i);
            ++i;
            if (i === t2.get$length(uri)) {
              t1.char_5 = -1;
              state = 0;
            } else {
              $char = t2.codeUnitAt$1(uri, i);
              t1.char_5 = $char;
              if ($char === 63 || $char === 35)
                state = 0;
              else
                state = $char === 47 ? 2 : 1;
            }
            pathStart = i;
            break;
          }
          ++i;
          t1.char_5 = -1;
        }
        t1.index_4 = i;
        if (state === 2) {
          index = i + 1;
          t1.index_4 = index;
          if (index === t2.get$length(uri)) {
            t1.char_5 = -1;
            state = 0;
          } else {
            $char = t2.codeUnitAt$1(uri, t1.index_4);
            t1.char_5 = $char;
            if ($char === 47) {
              t1.index_4 = J.$add$ns(t1.index_4, 1);
              new P.Uri_parse_parseAuth(t1, uri, -1).call$0();
              pathStart = t1.index_4;
            }
            t3 = t1.char_5;
            state = t3 === 63 || t3 === 35 || t3 === -1 ? 0 : 1;
          }
        }
        if (state === 1)
          while (true) {
            index = J.$add$ns(t1.index_4, 1);
            t1.index_4 = index;
            t3 = t2.get$length(uri);
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (!(index < t3))
              break;
            $char = t2.codeUnitAt$1(uri, t1.index_4);
            t1.char_5 = $char;
            if ($char === 63 || $char === 35)
              break;
            t1.char_5 = -1;
          }
        t3 = t1.scheme_0;
        t4 = t1.host_2;
        path = P.Uri__makePath(uri, pathStart, t1.index_4, null, t4 != null, t3 === "file");
        t3 = t1.char_5;
        if (t3 === 63) {
          numberSignIndex = t2.indexOf$2(uri, "#", J.$add$ns(t1.index_4, 1));
          t3 = t1.index_4;
          if (numberSignIndex < 0) {
            query = P.Uri__makeQuery(uri, J.$add$ns(t3, 1), t2.get$length(uri), null);
            fragment = null;
          } else {
            query = P.Uri__makeQuery(uri, J.$add$ns(t3, 1), numberSignIndex, null);
            fragment = P.Uri__makeFragment(uri, numberSignIndex + 1, t2.get$length(uri));
          }
        } else {
          fragment = t3 === 35 ? P.Uri__makeFragment(uri, J.$add$ns(t1.index_4, 1), t2.get$length(uri)) : null;
          query = null;
        }
        t2 = t1.scheme_0;
        t3 = t1.userinfo_1;
        return new P.Uri(t1.host_2, t1.port_3, path, t2, t3, query, fragment, null, null);
      }, Uri__fail: function(uri, index, message) {
        throw H.wrapException(P.FormatException$(message, uri, index));
      }, Uri_Uri: function(fragment, host, path, pathSegments, port, query, queryParameters, scheme, userInfo) {
        var isFile, t1;
        scheme = P.Uri__makeScheme(scheme, scheme.length);
        userInfo = P.Uri__makeUserInfo(userInfo, 0, userInfo.length);
        host = P.Uri__makeHost(host, 0, host == null ? 0 : J.get$length$asx(host), false);
        query = P.Uri__makeQuery(query, 0, 0, queryParameters);
        fragment = P.Uri__makeFragment(fragment, 0, 0);
        port = P.Uri__makePort(port, scheme);
        isFile = scheme === "file";
        if (host == null)
          t1 = userInfo.length !== 0 || port != null || isFile;
        else
          t1 = false;
        if (t1)
          host = "";
        t1 = path == null ? 0 : path.length;
        return new P.Uri(host, port, P.Uri__makePath(path, 0, t1, pathSegments, host != null, isFile), scheme, userInfo, query, fragment, null, null);
      }, Uri_Uri$file: function(path, windows) {
        return windows ? P.Uri__makeWindowsFileUrl(path) : P.Uri__makeFileUri(path);
      }, Uri_base: function() {
        var uri = H.Primitives_currentUri();
        if (uri != null)
          return P.Uri_parse(uri);
        throw H.wrapException(P.UnsupportedError$("'Uri.base' is not supported"));
      }, Uri__checkNonWindowsPathReservedCharacters: function(segments, argumentError) {
        segments.forEach$1(segments, new P.Uri__checkNonWindowsPathReservedCharacters_closure(argumentError));
      }, Uri__checkWindowsPathReservedCharacters: function(segments, argumentError, firstSegment) {
        J.skip$1$ax(segments, firstSegment).forEach$1(0, new P.Uri__checkWindowsPathReservedCharacters_closure(argumentError));
      }, Uri__checkWindowsDriveLetter: function(charCode, argumentError) {
        var t1;
        if (!(65 <= charCode && charCode <= 90))
          t1 = 97 <= charCode && charCode <= 122;
        else
          t1 = true;
        if (t1)
          return;
        if (argumentError)
          throw H.wrapException(P.ArgumentError$("Illegal drive letter " + P.String_String$fromCharCode(charCode)));
        else
          throw H.wrapException(P.UnsupportedError$("Illegal drive letter " + P.String_String$fromCharCode(charCode)));
      }, Uri__makeFileUri: function(path) {
        var t1 = J.getInterceptor$s(path);
        if (t1.startsWith$1(path, "/"))
          return P.Uri_Uri(null, null, null, t1.split$1(path, "/"), null, null, null, "file", "");
        else
          return P.Uri_Uri(null, null, null, t1.split$1(path, "/"), null, null, null, "", "");
      }, Uri__makeWindowsFileUrl: function(path) {
        var t1, t2, pathSegments, pathStart, hostPart;
        t1 = J.getInterceptor$s(path);
        if (t1.startsWith$1(path, "\\\\?\\"))
          if (t1.startsWith$1(path, "\\\\?\\UNC\\"))
            path = "\\" + t1.substring$1(path, 7);
          else {
            path = t1.substring$1(path, 4);
            if (path.length < 3 || C.JSString_methods.codeUnitAt$1(path, 1) !== 58 || C.JSString_methods.codeUnitAt$1(path, 2) !== 92)
              throw H.wrapException(P.ArgumentError$("Windows paths with \\\\?\\ prefix must be absolute"));
          }
        else
          path = t1.replaceAll$2(path, "/", "\\");
        t1 = path.length;
        t2 = t1 > 1;
        if (t2 && path[1] === ":") {
          P.Uri__checkWindowsDriveLetter(C.JSString_methods.codeUnitAt$1(path, 0), true);
          if (t1 === 2 || C.JSString_methods.codeUnitAt$1(path, 2) !== 92)
            throw H.wrapException(P.ArgumentError$("Windows paths with drive letter must be absolute"));
          pathSegments = path.split("\\");
          P.Uri__checkWindowsPathReservedCharacters(pathSegments, true, 1);
          return P.Uri_Uri(null, null, null, pathSegments, null, null, null, "file", "");
        }
        if (t1 > 0 && path[0] === "\\")
          if (t2 && path[1] === "\\") {
            pathStart = C.JSString_methods.indexOf$2(path, "\\", 2);
            t1 = pathStart === -1;
            hostPart = t1 ? C.JSString_methods.substring$1(path, 2) : C.JSString_methods.substring$2(path, 2, pathStart);
            pathSegments = (t1 ? "" : C.JSString_methods.substring$1(path, pathStart + 1)).split("\\");
            P.Uri__checkWindowsPathReservedCharacters(pathSegments, true, 0);
            return P.Uri_Uri(null, hostPart, null, pathSegments, null, null, null, "file", "");
          } else {
            pathSegments = path.split("\\");
            P.Uri__checkWindowsPathReservedCharacters(pathSegments, true, 0);
            return P.Uri_Uri(null, null, null, pathSegments, null, null, null, "file", "");
          }
        else {
          pathSegments = path.split("\\");
          P.Uri__checkWindowsPathReservedCharacters(pathSegments, true, 0);
          return P.Uri_Uri(null, null, null, pathSegments, null, null, null, "", "");
        }
      }, Uri__makePort: function(port, scheme) {
        if (port != null && port === P.Uri__defaultPort(scheme))
          return;
        return port;
      }, Uri__makeHost: function(host, start, end, strictIPv6) {
        var t1, t2, i;
        if (host == null)
          return;
        if (start === end)
          return "";
        t1 = J.getInterceptor$s(host);
        if (t1.codeUnitAt$1(host, start) === 91) {
          t2 = J.getInterceptor$n(end);
          if (t1.codeUnitAt$1(host, t2.$sub(end, 1)) !== 93)
            P.Uri__fail(host, start, "Missing end `]` to match `[` in host");
          P.Uri_parseIPv6Address(host, J.$add$ns(start, 1), t2.$sub(end, 1));
          return t1.substring$2(host, start, end).toLowerCase();
        }
        if (!strictIPv6)
          for (i = start; t2 = J.getInterceptor$n(i), t2.$lt(i, end); i = t2.$add(i, 1))
            if (t1.codeUnitAt$1(host, i) === 58) {
              P.Uri_parseIPv6Address(host, start, end);
              return "[" + H.S(host) + "]";
            }
        return P.Uri__normalizeRegName(host, start, end);
      }, Uri__normalizeRegName: function(host, start, end) {
        var t1, index, sectionStart, buffer, isNormalized, t2, $char, replacement, t3, slice, sourceLength, tail;
        for (t1 = J.getInterceptor$s(host), index = start, sectionStart = index, buffer = null, isNormalized = true; t2 = J.getInterceptor$n(index), t2.$lt(index, end);) {
          $char = t1.codeUnitAt$1(host, index);
          if ($char === 37) {
            replacement = P.Uri__normalizeEscape(host, index, true);
            t3 = replacement == null;
            if (t3 && isNormalized) {
              index = t2.$add(index, 3);
              continue;
            }
            if (buffer == null) {
              buffer = new P.StringBuffer("");
              buffer._contents = "";
            }
            slice = t1.substring$2(host, sectionStart, index);
            if (!isNormalized)
              slice = slice.toLowerCase();
            buffer.toString;
            buffer._contents = buffer._contents + slice;
            if (t3) {
              replacement = t1.substring$2(host, index, t2.$add(index, 3));
              sourceLength = 3;
            } else if (replacement === "%") {
              replacement = "%25";
              sourceLength = 1;
            } else
              sourceLength = 3;
            buffer._contents += replacement;
            index = t2.$add(index, sourceLength);
            sectionStart = index;
            isNormalized = true;
          } else {
            if ($char < 127) {
              t3 = $char >>> 4;
              if (t3 >= 8)
                return H.ioore(C.List_qNA, t3);
              t3 = (C.List_qNA[t3] & C.JSInt_methods._shlPositive$1(1, $char & 15)) !== 0;
            } else
              t3 = false;
            if (t3) {
              if (isNormalized && 65 <= $char && 90 >= $char) {
                if (buffer == null) {
                  buffer = new P.StringBuffer("");
                  buffer._contents = "";
                }
                if (J.$lt$n(sectionStart, index)) {
                  t3 = t1.substring$2(host, sectionStart, index);
                  buffer.toString;
                  buffer._contents = buffer._contents + t3;
                  sectionStart = index;
                }
                isNormalized = false;
              }
              index = t2.$add(index, 1);
            } else {
              if ($char <= 93) {
                t3 = $char >>> 4;
                if (t3 >= 8)
                  return H.ioore(C.List_2Vk0, t3);
                t3 = (C.List_2Vk0[t3] & C.JSInt_methods._shlPositive$1(1, $char & 15)) !== 0;
              } else
                t3 = false;
              if (t3)
                P.Uri__fail(host, index, "Invalid character");
              else {
                if (($char & 64512) === 55296) {
                  t3 = t2.$add(index, 1);
                  if (typeof end !== "number")
                    return H.iae(end);
                  t3 = t3 < end;
                } else
                  t3 = false;
                if (t3) {
                  tail = t1.codeUnitAt$1(host, t2.$add(index, 1));
                  if ((tail & 64512) === 56320) {
                    $char = (65536 | ($char & 1023) << 10 | tail & 1023) >>> 0;
                    sourceLength = 2;
                  } else
                    sourceLength = 1;
                } else
                  sourceLength = 1;
                if (buffer == null) {
                  buffer = new P.StringBuffer("");
                  buffer._contents = "";
                }
                slice = t1.substring$2(host, sectionStart, index);
                if (!isNormalized)
                  slice = slice.toLowerCase();
                buffer.toString;
                buffer._contents = buffer._contents + slice;
                t3 = P.Uri__escapeChar($char);
                buffer._contents += t3;
                index = t2.$add(index, sourceLength);
                sectionStart = index;
              }
            }
          }
        }
        if (buffer == null)
          return t1.substring$2(host, start, end);
        if (J.$lt$n(sectionStart, end)) {
          slice = t1.substring$2(host, sectionStart, end);
          buffer.write$1(!isNormalized ? slice.toLowerCase() : slice);
        }
        return buffer.toString$0(0);
      }, Uri__makeScheme: function(scheme, end) {
        var t1, $char, allLowercase, t2, t3, i, codeUnit, t4;
        if (end === 0)
          return "";
        t1 = J.getInterceptor$s(scheme);
        $char = t1.codeUnitAt$1(scheme, 0);
        allLowercase = $char >= 97;
        if (!(allLowercase && $char <= 122))
          t2 = $char >= 65 && $char <= 90;
        else
          t2 = true;
        if (!t2)
          P.Uri__fail(scheme, 0, "Scheme not starting with alphabetic character");
        if (typeof end !== "number")
          return H.iae(end);
        t2 = 97 <= $char;
        t3 = 122 >= $char;
        i = 0;
        for (; i < end; ++i) {
          codeUnit = t1.codeUnitAt$1(scheme, i);
          if (codeUnit < 128) {
            t4 = codeUnit >>> 4;
            if (t4 >= 8)
              return H.ioore(C.List_JYB, t4);
            t4 = (C.List_JYB[t4] & C.JSInt_methods._shlPositive$1(1, codeUnit & 15)) !== 0;
          } else
            t4 = false;
          if (!t4)
            P.Uri__fail(scheme, i, "Illegal scheme character");
          if (t2 && t3)
            allLowercase = false;
        }
        scheme = t1.substring$2(scheme, 0, end);
        return !allLowercase ? scheme.toLowerCase() : scheme;
      }, Uri__makeUserInfo: function(userInfo, start, end) {
        if (userInfo == null)
          return "";
        return P.Uri__normalize(userInfo, start, end, C.List_gRj);
      }, Uri__makePath: function(path, start, end, pathSegments, ensureLeadingSlash, isFile) {
        var t1, result;
        t1 = path == null;
        if (t1 && pathSegments == null)
          return isFile ? "/" : "";
        t1 = !t1;
        if (t1 && pathSegments != null)
          throw H.wrapException(P.ArgumentError$("Both path and pathSegments specified"));
        if (t1)
          result = P.Uri__normalize(path, start, end, C.List_qg4);
        else {
          pathSegments.toString;
          result = H.setRuntimeTypeInfo(new H.MappedListIterable(pathSegments, new P.Uri__makePath_closure()), [null, null]).join$1(0, "/");
        }
        if (result.length === 0) {
          if (isFile)
            return "/";
        } else if ((isFile || ensureLeadingSlash) && C.JSString_methods.codeUnitAt$1(result, 0) !== 47)
          return "/" + result;
        return result;
      }, Uri__makeQuery: function(query, start, end, queryParameters) {
        var t1, t2, result;
        t1 = {};
        t2 = query == null;
        if (t2 && true)
          return;
        t2 = !t2;
        if (t2)
          ;
        if (t2)
          return P.Uri__normalize(query, start, end, C.List_CVk);
        result = P.StringBuffer$("");
        t1.first_0 = true;
        C.JSNull_methods.forEach$1(queryParameters, new P.Uri__makeQuery_closure(t1, result));
        return result._contents;
      }, Uri__makeFragment: function(fragment, start, end) {
        if (fragment == null)
          return;
        return P.Uri__normalize(fragment, start, end, C.List_CVk);
      }, Uri__isHexDigit: function($char) {
        if (57 >= $char)
          return 48 <= $char;
        $char |= 32;
        return 97 <= $char && 102 >= $char;
      }, Uri__hexValue: function($char) {
        if (57 >= $char)
          return $char - 48;
        return ($char | 32) - 87;
      }, Uri__normalizeEscape: function(source, index, lowerCase) {
        var t1, t2, t3, t4, firstDigit, secondDigit, value;
        t1 = J.getInterceptor$ns(index);
        t2 = t1.$add(index, 2);
        t3 = J.getInterceptor$asx(source);
        t4 = t3.get$length(source);
        if (typeof t4 !== "number")
          return H.iae(t4);
        if (t2 >= t4)
          return "%";
        firstDigit = t3.codeUnitAt$1(source, t1.$add(index, 1));
        secondDigit = t3.codeUnitAt$1(source, t1.$add(index, 2));
        if (!P.Uri__isHexDigit(firstDigit) || !P.Uri__isHexDigit(secondDigit))
          return "%";
        value = P.Uri__hexValue(firstDigit) * 16 + P.Uri__hexValue(secondDigit);
        if (value < 127) {
          t2 = C.JSInt_methods._shrOtherPositive$1(value, 4);
          if (t2 >= 8)
            return H.ioore(C.List_nxB, t2);
          t2 = (C.List_nxB[t2] & C.JSInt_methods._shlPositive$1(1, value & 15)) !== 0;
        } else
          t2 = false;
        if (t2)
          return H.Primitives_stringFromCharCode(lowerCase && 65 <= value && 90 >= value ? (value | 32) >>> 0 : value);
        if (firstDigit >= 97 || secondDigit >= 97)
          return t3.substring$2(source, index, t1.$add(index, 3)).toUpperCase();
        return;
      }, Uri__escapeChar: function($char) {
        var codeUnits, t1, flag, encodedBytes, index, $byte, t2, t3;
        if ($char < 128) {
          codeUnits = Array(3);
          codeUnits.fixed$length = init;
          codeUnits[0] = 37;
          t1 = $char >>> 4;
          if (t1 >= 16)
            H.throwExpression(P.RangeError$value(t1));
          codeUnits[1] = "0123456789ABCDEF".charCodeAt(t1);
          codeUnits[2] = "0123456789ABCDEF".charCodeAt($char & 15);
        } else {
          if ($char > 2047)
            if ($char > 65535) {
              flag = 240;
              encodedBytes = 4;
            } else {
              flag = 224;
              encodedBytes = 3;
            }
          else {
            flag = 192;
            encodedBytes = 2;
          }
          t1 = 3 * encodedBytes;
          codeUnits = Array(t1);
          codeUnits.fixed$length = init;
          for (index = 0; --encodedBytes, encodedBytes >= 0; flag = 128) {
            $byte = C.JSInt_methods._shrReceiverPositive$1($char, 6 * encodedBytes) & 63 | flag;
            if (index >= t1)
              return H.ioore(codeUnits, index);
            codeUnits[index] = 37;
            t2 = index + 1;
            t3 = $byte >>> 4;
            if (t3 >= 16)
              H.throwExpression(P.RangeError$value(t3));
            t3 = "0123456789ABCDEF".charCodeAt(t3);
            if (t2 >= t1)
              return H.ioore(codeUnits, t2);
            codeUnits[t2] = t3;
            t3 = index + 2;
            t2 = "0123456789ABCDEF".charCodeAt($byte & 15);
            if (t3 >= t1)
              return H.ioore(codeUnits, t3);
            codeUnits[t3] = t2;
            index += 3;
          }
        }
        return H.Primitives_stringFromCharCodes(codeUnits);
      }, Uri__normalize: function(component, start, end, charTable) {
        var t1, index, sectionStart, buffer, t2, $char, t3, replacement, sourceLength, tail;
        for (t1 = J.getInterceptor$s(component), index = start, sectionStart = index, buffer = null; t2 = J.getInterceptor$n(index), t2.$lt(index, end);) {
          $char = t1.codeUnitAt$1(component, index);
          if ($char < 127) {
            t3 = $char >>> 4;
            if (t3 >= 8)
              return H.ioore(charTable, t3);
            t3 = (charTable[t3] & C.JSInt_methods._shlPositive$1(1, $char & 15)) !== 0;
          } else
            t3 = false;
          if (t3)
            index = t2.$add(index, 1);
          else {
            if ($char === 37) {
              replacement = P.Uri__normalizeEscape(component, index, false);
              if (replacement == null) {
                index = t2.$add(index, 3);
                continue;
              }
              if ("%" === replacement) {
                replacement = "%25";
                sourceLength = 1;
              } else
                sourceLength = 3;
            } else {
              if ($char <= 93) {
                t3 = $char >>> 4;
                if (t3 >= 8)
                  return H.ioore(C.List_2Vk0, t3);
                t3 = (C.List_2Vk0[t3] & C.JSInt_methods._shlPositive$1(1, $char & 15)) !== 0;
              } else
                t3 = false;
              if (t3) {
                P.Uri__fail(component, index, "Invalid character");
                replacement = null;
                sourceLength = null;
              } else {
                if (($char & 64512) === 55296) {
                  t3 = t2.$add(index, 1);
                  if (typeof end !== "number")
                    return H.iae(end);
                  if (t3 < end) {
                    tail = t1.codeUnitAt$1(component, t2.$add(index, 1));
                    if ((tail & 64512) === 56320) {
                      $char = (65536 | ($char & 1023) << 10 | tail & 1023) >>> 0;
                      sourceLength = 2;
                    } else
                      sourceLength = 1;
                  } else
                    sourceLength = 1;
                } else
                  sourceLength = 1;
                replacement = P.Uri__escapeChar($char);
              }
            }
            if (buffer == null) {
              buffer = new P.StringBuffer("");
              buffer._contents = "";
            }
            t3 = t1.substring$2(component, sectionStart, index);
            buffer.toString;
            buffer._contents = buffer._contents + t3;
            buffer._contents += typeof replacement === "string" ? replacement : H.S(replacement);
            index = t2.$add(index, sourceLength);
            sectionStart = index;
          }
        }
        if (buffer == null)
          return t1.substring$2(component, start, end);
        if (J.$lt$n(sectionStart, end))
          buffer.write$1(t1.substring$2(component, sectionStart, end));
        return buffer.toString$0(0);
      }, Uri_decodeComponent: [function(encodedComponent) {
        return P.Uri__uriDecode(encodedComponent, C.Utf8Codec_false, false);
      }, "call$1", "Uri_decodeComponent$closure", 2, 0, 50, 51], Uri_parseIPv4Address: function(host) {
        var t1, bytes;
        t1 = new P.Uri_parseIPv4Address_error();
        bytes = host.split(".");
        if (bytes.length !== 4)
          t1.call$1("IPv4 address should contain exactly 4 parts");
        return H.setRuntimeTypeInfo(new H.MappedListIterable(bytes, new P.Uri_parseIPv4Address_closure(t1)), [null, null]).toList$0(0);
      }, Uri_parseIPv6Address: function(host, start, end) {
        var error, parseHex, parts, partStart, last, i, wildcardSeen, t1, atEnd, isLastWildcard, exception, t2, bytes, index, value, wildCardLength, j;
        if (end == null)
          end = J.get$length$asx(host);
        error = new P.Uri_parseIPv6Address_error(host);
        parseHex = new P.Uri_parseIPv6Address_parseHex(host, error);
        if (J.$lt$n(J.get$length$asx(host), 2))
          error.call$1("address is too short");
        parts = [];
        partStart = start;
        for (i = start, wildcardSeen = false; t1 = J.getInterceptor$n(i), t1.$lt(i, end); i = J.$add$ns(i, 1))
          if (J.codeUnitAt$1$s(host, i) === 58) {
            if (i === start) {
              i = t1.$add(i, 1);
              if (J.codeUnitAt$1$s(host, i) !== 58)
                error.call$2("invalid start colon.", i);
              partStart = i;
            }
            if (i === partStart) {
              if (wildcardSeen)
                error.call$2("only one wildcard `::` is allowed", i);
              J.add$1$ax(parts, -1);
              wildcardSeen = true;
            } else
              J.add$1$ax(parts, parseHex.call$2(partStart, i));
            partStart = J.$add$ns(i, 1);
          }
        if (J.get$length$asx(parts) === 0)
          error.call$1("too few parts");
        atEnd = J.$eq(partStart, end);
        isLastWildcard = J.$eq(J.get$last$ax(parts), -1);
        if (atEnd && !isLastWildcard)
          error.call$2("expected a part after last `:`", end);
        if (!atEnd)
          try {
            J.add$1$ax(parts, parseHex.call$2(partStart, end));
          } catch (exception) {
            H.unwrapException(exception);
            try {
              last = P.Uri_parseIPv4Address(J.substring$2$s(host, partStart, end));
              t1 = J.$shl$n(J.$index$asx(last, 0), 8);
              t2 = J.$index$asx(last, 1);
              if (typeof t2 !== "number")
                return H.iae(t2);
              J.add$1$ax(parts, (t1 | t2) >>> 0);
              t2 = J.$shl$n(J.$index$asx(last, 2), 8);
              t1 = J.$index$asx(last, 3);
              if (typeof t1 !== "number")
                return H.iae(t1);
              J.add$1$ax(parts, (t2 | t1) >>> 0);
            } catch (exception) {
              H.unwrapException(exception);
              error.call$2("invalid end of IPv6 address.", partStart);
            }

          }

        if (wildcardSeen) {
          if (J.get$length$asx(parts) > 7)
            error.call$1("an address with a wildcard must have less than 7 parts");
        } else if (J.get$length$asx(parts) !== 8)
          error.call$1("an address without a wildcard must contain exactly 8 parts");
        bytes = Array(16);
        bytes.$builtinTypeInfo = [P.$int];
        i = 0;
        index = 0;
        while (true) {
          t1 = J.get$length$asx(parts);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          value = J.$index$asx(parts, i);
          t1 = J.getInterceptor(value);
          if (t1.$eq(value, -1)) {
            wildCardLength = 9 - J.get$length$asx(parts);
            for (j = 0; j < wildCardLength; ++j) {
              if (index < 0 || index >= 16)
                return H.ioore(bytes, index);
              bytes[index] = 0;
              t1 = index + 1;
              if (t1 >= 16)
                return H.ioore(bytes, t1);
              bytes[t1] = 0;
              index += 2;
            }
          } else {
            t2 = t1.$shr(value, 8);
            if (index < 0 || index >= 16)
              return H.ioore(bytes, index);
            bytes[index] = t2;
            t2 = index + 1;
            t1 = t1.$and(value, 255);
            if (t2 >= 16)
              return H.ioore(bytes, t2);
            bytes[t2] = t1;
            index += 2;
          }
          ++i;
        }
        return bytes;
      }, Uri__uriEncode: function(canonicalTable, text, encoding, spaceToPlus) {
        var t1, result, bytes, i, $byte, t2, t3;
        t1 = new P.Uri__uriEncode_byteToHex();
        result = P.StringBuffer$("");
        bytes = encoding.get$encoder().convert$1(text);
        for (i = 0; i < bytes.length; ++i) {
          $byte = bytes[i];
          t2 = J.getInterceptor$n($byte);
          if (t2.$lt($byte, 128)) {
            t3 = t2.$shr($byte, 4);
            if (t3 >= 8)
              return H.ioore(canonicalTable, t3);
            t3 = (canonicalTable[t3] & C.JSInt_methods._shlPositive$1(1, t2.$and($byte, 15))) !== 0;
          } else
            t3 = false;
          if (t3) {
            t2 = H.Primitives_stringFromCharCode($byte);
            result._contents += t2;
          } else if (spaceToPlus && t2.$eq($byte, 32)) {
            t2 = H.Primitives_stringFromCharCode(43);
            result._contents += t2;
          } else {
            t2 = H.Primitives_stringFromCharCode(37);
            result._contents += t2;
            t1.call$2($byte, result);
          }
        }
        return result._contents;
      }, Uri__hexCharPairToByte: function(s, pos) {
        var t1, $byte, i, charCode;
        for (t1 = J.getInterceptor$s(s), $byte = 0, i = 0; i < 2; ++i) {
          charCode = t1.codeUnitAt$1(s, pos + i);
          if (48 <= charCode && charCode <= 57)
            $byte = $byte * 16 + charCode - 48;
          else {
            charCode |= 32;
            if (97 <= charCode && charCode <= 102)
              $byte = $byte * 16 + charCode - 87;
            else
              throw H.wrapException(P.ArgumentError$("Invalid URL encoding"));
          }
        }
        return $byte;
      }, Uri__uriDecode: function(text, encoding, plusToSpace) {
        var t1, simple, i, t2, codeUnit, bytes;
        t1 = J.getInterceptor$asx(text);
        simple = true;
        i = 0;
        while (true) {
          t2 = t1.get$length(text);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2 && simple))
            break;
          codeUnit = t1.codeUnitAt$1(text, i);
          simple = codeUnit !== 37 && codeUnit !== 43;
          ++i;
        }
        if (simple)
          if (encoding === C.Utf8Codec_false || false)
            return text;
          else
            bytes = t1.get$codeUnits(text);
        else {
          bytes = [];
          i = 0;
          while (true) {
            t2 = t1.get$length(text);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            codeUnit = t1.codeUnitAt$1(text, i);
            if (codeUnit > 127)
              throw H.wrapException(P.ArgumentError$("Illegal percent encoding in URI"));
            if (codeUnit === 37) {
              t2 = t1.get$length(text);
              if (typeof t2 !== "number")
                return H.iae(t2);
              if (i + 3 > t2)
                throw H.wrapException(P.ArgumentError$("Truncated URI"));
              bytes.push(P.Uri__hexCharPairToByte(text, i + 1));
              i += 2;
            } else if (plusToSpace && codeUnit === 43)
              bytes.push(32);
            else
              bytes.push(codeUnit);
            ++i;
          }
        }
        return encoding.decode$1(bytes);
      }}
  },
  Uri_parse_isRegName: {
    "^": "Closure:91;",
    call$1: function(ch) {
      ch.$lt(0, 128);
      return false;
    },
    $isFunction: true
  },
  Uri_parse_parseAuth: {
    "^": "Closure:12;box_0,uri_1,EOI_2",
    call$0: function() {
      var t1, t2, t3, authStart, $char, lastColon, lastAt, char0, endBracket, hostEnd, t4, hostStart, t5, t6, i, portNumber, digit;
      t1 = this.box_0;
      t2 = this.uri_1;
      t3 = J.getInterceptor$asx(t2);
      if (t1.index_4 === t3.get$length(t2)) {
        t1.char_5 = this.EOI_2;
        return;
      }
      authStart = t1.index_4;
      t1.char_5 = t3.codeUnitAt$1(t2, authStart);
      for ($char = this.EOI_2, lastColon = -1, lastAt = -1; J.$lt$n(t1.index_4, t3.get$length(t2));) {
        char0 = t3.codeUnitAt$1(t2, t1.index_4);
        t1.char_5 = char0;
        if (char0 === 47 || char0 === 63 || char0 === 35)
          break;
        if (char0 === 64) {
          lastAt = t1.index_4;
          lastColon = -1;
        } else if (char0 === 58)
          lastColon = t1.index_4;
        else if (char0 === 91) {
          endBracket = t3.indexOf$2(t2, "]", J.$add$ns(t1.index_4, 1));
          if (endBracket === -1) {
            t1.index_4 = t3.get$length(t2);
            t1.char_5 = $char;
            lastColon = -1;
            break;
          } else
            t1.index_4 = endBracket;
          lastColon = -1;
        }
        t1.index_4 = J.$add$ns(t1.index_4, 1);
        t1.char_5 = $char;
      }
      hostEnd = t1.index_4;
      t4 = J.getInterceptor$n(lastAt);
      if (t4.$ge(lastAt, 0)) {
        t1.userinfo_1 = P.Uri__makeUserInfo(t2, authStart, lastAt);
        hostStart = t4.$add(lastAt, 1);
      } else
        hostStart = authStart;
      t4 = J.getInterceptor$n(lastColon);
      if (t4.$ge(lastColon, 0)) {
        t5 = t4.$add(lastColon, 1);
        t6 = t1.index_4;
        if (typeof t6 !== "number")
          return H.iae(t6);
        if (t5 < t6) {
          i = t4.$add(lastColon, 1);
          portNumber = 0;
          while (true) {
            t4 = t1.index_4;
            if (typeof t4 !== "number")
              return H.iae(t4);
            if (!(i < t4))
              break;
            digit = t3.codeUnitAt$1(t2, i);
            if (48 > digit || 57 < digit)
              P.Uri__fail(t2, i, "Invalid port number");
            portNumber = portNumber * 10 + (digit - 48);
            ++i;
          }
        } else
          portNumber = null;
        t1.port_3 = P.Uri__makePort(portNumber, t1.scheme_0);
        hostEnd = lastColon;
      }
      t1.host_2 = P.Uri__makeHost(t2, hostStart, hostEnd, true);
      if (J.$lt$n(t1.index_4, t3.get$length(t2)))
        t1.char_5 = t3.codeUnitAt$1(t2, t1.index_4);
    },
    $isFunction: true
  },
  Uri__checkNonWindowsPathReservedCharacters_closure: {
    "^": "Closure:58;argumentError_0",
    call$1: function(segment) {
      if (J.contains$1$asx(segment, "/") === true)
        if (this.argumentError_0)
          throw H.wrapException(P.ArgumentError$("Illegal path character " + H.S(segment)));
        else
          throw H.wrapException(P.UnsupportedError$("Illegal path character " + H.S(segment)));
    },
    $isFunction: true
  },
  Uri__checkWindowsPathReservedCharacters_closure: {
    "^": "Closure:58;argumentError_0",
    call$1: function(segment) {
      if (J.contains$1$asx(segment, new H.JSSyntaxRegExp("[\"*/:<>?\\\\|]", H.JSSyntaxRegExp_makeNative("[\"*/:<>?\\\\|]", false, true, false), null, null)) === true)
        if (this.argumentError_0)
          throw H.wrapException(P.ArgumentError$("Illegal character in path"));
        else
          throw H.wrapException(P.UnsupportedError$("Illegal character in path"));
    },
    $isFunction: true
  },
  Uri__makePath_closure: {
    "^": "Closure:58;",
    call$1: [function(s) {
      return P.Uri__uriEncode(C.List_qg40, s, C.Utf8Codec_false, false);
    }, "call$1", null, 2, 0, null, 75, "call"],
    $isFunction: true
  },
  Uri__makeQuery_closure: {
    "^": "Closure:56;box_0,result_1",
    call$2: function(key, value) {
      var t1 = this.box_0;
      if (!t1.first_0)
        this.result_1.write$1("&");
      t1.first_0 = false;
      t1 = this.result_1;
      t1.write$1(P.Uri__uriEncode(C.List_nxB, key, C.Utf8Codec_false, true));
      value.get$isEmpty(value);
      t1.write$1("=");
      t1.write$1(P.Uri__uriEncode(C.List_nxB, value, C.Utf8Codec_false, true));
    },
    $isFunction: true
  },
  Uri_hashCode_combine: {
    "^": "Closure:92;",
    call$2: function(part, current) {
      return current * 31 + J.get$hashCode$(part) & 1073741823;
    },
    $isFunction: true
  },
  Uri_parseIPv4Address_error: {
    "^": "Closure:38;",
    call$1: function(msg) {
      throw H.wrapException(P.FormatException$("Illegal IPv4 address, " + msg, null, null));
    },
    $isFunction: true
  },
  Uri_parseIPv4Address_closure: {
    "^": "Closure:58;error_0",
    call$1: [function(byteString) {
      var $byte, t1;
      $byte = H.Primitives_parseInt(byteString, null, null);
      t1 = J.getInterceptor$n($byte);
      if (t1.$lt($byte, 0) || t1.$gt($byte, 255))
        this.error_0.call$1("each part must be in the range of `0..255`");
      return $byte;
    }, "call$1", null, 2, 0, null, 93, "call"],
    $isFunction: true
  },
  Uri_parseIPv6Address_error: {
    "^": "Closure:94;host_0",
    call$2: function(msg, position) {
      throw H.wrapException(P.FormatException$("Illegal IPv6 address, " + msg, this.host_0, position));
    },
    call$1: function(msg) {
      return this.call$2(msg, null);
    },
    $isFunction: true
  },
  Uri_parseIPv6Address_parseHex: {
    "^": "Closure:95;host_1,error_2",
    call$2: function(start, end) {
      var value, t1;
      if (J.$sub$n(end, start) > 4)
        this.error_2.call$2("an IPv6 part can only contain a maximum of 4 hex digits", start);
      value = H.Primitives_parseInt(J.substring$2$s(this.host_1, start, end), 16, null);
      t1 = J.getInterceptor$n(value);
      if (t1.$lt(value, 0) || t1.$gt(value, 65535))
        this.error_2.call$2("each part must be in the range of `0x0..0xFFFF`", start);
      return value;
    },
    $isFunction: true
  },
  Uri__uriEncode_byteToHex: {
    "^": "Closure:56;",
    call$2: function($byte, buffer) {
      var t1 = J.getInterceptor$n($byte);
      buffer.write$1(H.Primitives_stringFromCharCode(C.JSString_methods.codeUnitAt$1("0123456789ABCDEF", t1.$shr($byte, 4))));
      buffer.write$1(H.Primitives_stringFromCharCode(C.JSString_methods.codeUnitAt$1("0123456789ABCDEF", t1.$and($byte, 15))));
    },
    $isFunction: true
  }
}],
["dart.io", "dart:io", , P, {
  "^": "",
  _CryptoUtils_bytesToBase64: function(bytes, urlSafe, addLineSeparator) {
    var t1, len, lookup, t2, remainderLength, chunkLength, t3, outputLen, out, t4, j, i, c, i0, t5, t6, t7, x, j0, y;
    t1 = J.getInterceptor$asx(bytes);
    len = t1.get$length(bytes);
    if (len === 0)
      return "";
    lookup = urlSafe ? "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_" : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    t2 = J.getInterceptor$n(len);
    remainderLength = t2.remainder$1(len, 3);
    chunkLength = t2.$sub(len, remainderLength);
    t2 = t2.$tdiv(len, 3);
    t3 = remainderLength > 0 ? 4 : 0;
    outputLen = t2 * 4 + t3;
    if (addLineSeparator)
      outputLen += C.JSNumber_methods._tdivFast$1(outputLen - 1, 76) << 1 >>> 0;
    t2 = Array(outputLen);
    t2.fixed$length = init;
    out = H.setRuntimeTypeInfo(t2, [P.$int]);
    for (t2 = out.length, t3 = lookup.length, t4 = outputLen - 2, j = 0, i = 0, c = 0; i < chunkLength; i = i0) {
      i0 = i + 1;
      t5 = J.$shl$n(t1.$index(bytes, i), 16);
      i = i0 + 1;
      t6 = J.$shl$n(t1.$index(bytes, i0), 8);
      i0 = i + 1;
      t7 = t1.$index(bytes, i);
      if (typeof t7 !== "number")
        return H.iae(t7);
      x = t5 & 16777215 | t6 & 16777215 | t7;
      j0 = j + 1;
      t7 = x >>> 18;
      if (t7 >= t3)
        H.throwExpression(P.RangeError$value(t7));
      t5 = lookup.charCodeAt(t7);
      if (j >= t2)
        return H.ioore(out, j);
      out[j] = t5;
      j = j0 + 1;
      t5 = x >>> 12 & 63;
      if (t5 >= t3)
        H.throwExpression(P.RangeError$value(t5));
      t5 = lookup.charCodeAt(t5);
      if (j0 >= t2)
        return H.ioore(out, j0);
      out[j0] = t5;
      j0 = j + 1;
      t5 = x >>> 6 & 63;
      if (t5 >= t3)
        H.throwExpression(P.RangeError$value(t5));
      t5 = lookup.charCodeAt(t5);
      if (j >= t2)
        return H.ioore(out, j);
      out[j] = t5;
      j = j0 + 1;
      t5 = x & 63;
      if (t5 >= t3)
        H.throwExpression(P.RangeError$value(t5));
      t5 = lookup.charCodeAt(t5);
      if (j0 >= t2)
        return H.ioore(out, j0);
      out[j0] = t5;
      if (addLineSeparator) {
        ++c;
        t5 = c === 19 && j < t4;
      } else
        t5 = false;
      if (t5) {
        j0 = j + 1;
        if (j >= t2)
          return H.ioore(out, j);
        out[j] = 13;
        j = j0 + 1;
        if (j0 >= t2)
          return H.ioore(out, j0);
        out[j0] = 10;
        c = 0;
      }
    }
    if (remainderLength === 1) {
      x = t1.$index(bytes, i);
      j0 = j + 1;
      t1 = J.getInterceptor$n(x);
      t3 = C.JSString_methods.codeUnitAt$1(lookup, t1.$shr(x, 2));
      if (j >= t2)
        return H.ioore(out, j);
      out[j] = t3;
      j = j0 + 1;
      t1 = C.JSString_methods.codeUnitAt$1(lookup, t1.$shl(x, 4) & 63);
      if (j0 >= t2)
        return H.ioore(out, j0);
      out[j0] = t1;
      j0 = j + 1;
      if (j >= t2)
        return H.ioore(out, j);
      out[j] = 61;
      if (j0 >= t2)
        return H.ioore(out, j0);
      out[j0] = 61;
    } else if (remainderLength === 2) {
      x = t1.$index(bytes, i);
      y = t1.$index(bytes, i + 1);
      j0 = j + 1;
      t1 = J.getInterceptor$n(x);
      t3 = C.JSString_methods.codeUnitAt$1(lookup, t1.$shr(x, 2));
      if (j >= t2)
        return H.ioore(out, j);
      out[j] = t3;
      j = j0 + 1;
      t3 = J.getInterceptor$n(y);
      t1 = C.JSString_methods.codeUnitAt$1(lookup, (t1.$shl(x, 4) | t3.$shr(y, 4)) & 63);
      if (j0 >= t2)
        return H.ioore(out, j0);
      out[j0] = t1;
      j0 = j + 1;
      t3 = C.JSString_methods.codeUnitAt$1(lookup, t3.$shl(y, 2) & 63);
      if (j >= t2)
        return H.ioore(out, j);
      out[j] = t3;
      if (j0 >= t2)
        return H.ioore(out, j0);
      out[j0] = 61;
    }
    return P.String_String$fromCharCodes(out);
  },
  _Filter_newZLibDeflateFilter: function(gzip, level, windowBits, memLevel, strategy, dictionary, raw) {
    throw H.wrapException(P.UnsupportedError$("newZLibDeflateFilter"));
  },
  _Filter_newZLibInflateFilter: function(windowBits, dictionary, raw) {
    throw H.wrapException(P.UnsupportedError$("newZLibInflateFilter"));
  },
  _validateZLibWindowBits: function(windowBits) {
    if (8 > windowBits || 15 < windowBits)
      throw H.wrapException(P.RangeError$range(windowBits, 8, 15));
  },
  _validateZLibeLevel: function(level) {
    if (9 < level)
      throw H.wrapException(P.RangeError$range(level, -1, 9));
  },
  _validateZLibMemLevel: function(memLevel) {
    if (1 > memLevel || 9 < memLevel)
      throw H.wrapException(P.RangeError$range(memLevel, 1, 9));
  },
  _validateZLibStrategy: function(strategy) {
    if (H.Lists_indexOf(C.List_yTu0, strategy, 0, 5) === -1)
      throw H.wrapException(P.ArgumentError$("Unsupported 'strategy'"));
  },
  HttpServer_bind: function(address, port, backlog) {
    return P._HttpServer_bind(address, port, backlog);
  },
  HttpClient_findProxyFromEnvironment: [function(url, environment) {
    return P._HttpClient__findProxyFromEnvironment(url, environment);
  }, function(url) {
    return P.HttpClient_findProxyFromEnvironment(url, null);
  }, null, "call$2$environment", "call$1", "HttpClient_findProxyFromEnvironment$closure", 2, 3, 52, 16],
  HttpDate_format: function(date) {
    var d, sb, t1;
    d = date.toUtc$0();
    sb = P.StringBuffer$("");
    sb.write$1(C.List_ECn[C.JSInt_methods.$mod((d.isUtc === true ? H.Primitives_lazyAsJsDate(d).getUTCDay() + 0 : H.Primitives_lazyAsJsDate(d).getDay() + 0) + 6, 7) + 1 - 1]);
    sb.write$1(", ");
    sb.write$1(H.Primitives_getDay(d) <= 9 ? "0" : "");
    sb.write$1(C.JSInt_methods.toString$0(H.Primitives_getDay(d)));
    sb.write$1(" ");
    t1 = H.Primitives_getMonth(d) - 1;
    if (t1 < 0 || t1 >= 12)
      return H.ioore(C.List_h8w, t1);
    sb.write$1(C.List_h8w[t1]);
    sb.write$1(" ");
    sb.write$1(C.JSInt_methods.toString$0(H.Primitives_getYear(d)));
    sb.write$1(H.Primitives_getHours(d) <= 9 ? " 0" : " ");
    sb.write$1(C.JSInt_methods.toString$0(H.Primitives_getHours(d)));
    sb.write$1(H.Primitives_getMinutes(d) <= 9 ? ":0" : ":");
    sb.write$1(C.JSInt_methods.toString$0(H.Primitives_getMinutes(d)));
    sb.write$1(H.Primitives_getSeconds(d) <= 9 ? ":0" : ":");
    sb.write$1(C.JSInt_methods.toString$0(H.Primitives_getSeconds(d)));
    sb.write$1(" GMT");
    return sb._contents;
  },
  _IOService_dispatch: function(request, data) {
    throw H.wrapException(P.UnsupportedError$("_IOService.dispatch"));
  },
  _Platform__environment: function() {
    throw H.wrapException(P.UnsupportedError$("Platform._environment"));
  },
  _Platform__version: function() {
    throw H.wrapException(P.UnsupportedError$("Platform._version"));
  },
  _Platform_environment: function() {
    var t1 = $._Platform__environmentCache;
    if (t1 == null)
      P._Platform__environment();
    return t1;
  },
  _Platform_version: function() {
    return P._Platform__version();
  },
  SecureSocket_SecureSocket$_: function(rawSocket) {
    throw H.wrapException(P.UnsupportedError$("SecureSocket constructor"));
  },
  SecureSocket_connect: function(host, port, certificateName, onBadCertificate, sendClientCertificate) {
    return P.RawSecureSocket_connect(host, port, certificateName, onBadCertificate, sendClientCertificate).then$1(new P.SecureSocket_connect_closure());
  },
  SecureSocket_secure: function(socket, certificateName, host, onBadCertificate, sendClientCertificate) {
    var completer = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(null)), [null]);
    socket._detachRaw$0().then$1(new P.SecureSocket_secure_closure(host, sendClientCertificate, onBadCertificate)).then$1(new P.SecureSocket_secure_closure0(completer));
    return completer.future;
  },
  RawSecureSocket_connect: function(host, port, certificateName, onBadCertificate, sendClientCertificate) {
    P._RawSecureSocket__verifyFields(host, port, certificateName, false, false, false, sendClientCertificate, onBadCertificate);
    return P.RawSocket_connect(host, port).then$1(new P.RawSecureSocket_connect_closure(sendClientCertificate, certificateName, onBadCertificate));
  },
  RawSecureSocket_secure: function(socket, certificateName, host, onBadCertificate, sendClientCertificate, subscription) {
    var t1, t2, address;
    socket.set$readEventsEnabled(false);
    socket.set$writeEventsEnabled(false);
    t1 = host != null ? host : socket.get$address().get$host();
    t2 = socket.get$port();
    P._RawSecureSocket__verifyFields(t1, t2, certificateName, false, false, false, sendClientCertificate, onBadCertificate);
    address = socket.get$address();
    return P._RawSecureSocket$(t1 != null ? address._cloneWithNewHost$1(t1) : address, t2, certificateName, false, socket, subscription, null, false, false, sendClientCertificate, onBadCertificate)._handshakeComplete.future;
  },
  _SecureFilter__SecureFilter: function() {
    throw H.wrapException(P.UnsupportedError$("_SecureFilter._SecureFilter"));
  },
  ServerSocket_bind: function(address, port, backlog, v6Only) {
    throw H.wrapException(P.UnsupportedError$("ServerSocket.bind"));
  },
  RawSocket_connect: function(host, port) {
    throw H.wrapException(P.UnsupportedError$("RawSocket constructor"));
  },
  Socket_connect: function(host, port) {
    throw H.wrapException(P.UnsupportedError$("Socket constructor"));
  },
  GZipCodec: {
    "^": "Codec;gzip,level,memLevel,strategy,windowBits,dictionary,raw",
    $asCodec: function() {
      return [[P.List, P.$int], [P.List, P.$int]];
    }
  },
  ZLibEncoder: {
    "^": "Converter;gzip,level,memLevel,strategy,windowBits,dictionary,raw",
    startChunkedConversion$1: function(sink) {
      if (!sink.$isByteConversionSink)
        sink = new P._ByteAdapterSink(sink);
      return new P._ZLibEncoderSink(P._Filter_newZLibDeflateFilter(this.gzip, this.level, this.windowBits, this.memLevel, this.strategy, this.dictionary, this.raw), sink, false, true);
    },
    $asConverter: function() {
      return [[P.List, P.$int], [P.List, P.$int]];
    }
  },
  ZLibDecoder: {
    "^": "Converter;windowBits,dictionary,raw",
    startChunkedConversion$1: function(sink) {
      if (!sink.$isByteConversionSink)
        sink = new P._ByteAdapterSink(sink);
      return new P._ZLibDecoderSink(P._Filter_newZLibInflateFilter(this.windowBits, this.dictionary, this.raw), sink, false, true);
    },
    $asConverter: function() {
      return [[P.List, P.$int], [P.List, P.$int]];
    }
  },
  _ZLibEncoderSink: {
    "^": "_FilterSink;_filter,_io$_sink,_closed,_empty"
  },
  _ZLibDecoderSink: {
    "^": "_FilterSink;_filter,_io$_sink,_closed,_empty"
  },
  _FilterSink: {
    "^": "ByteConversionSink;",
    add$1: [function(_, data) {
      this.addSlice$4(data, 0, J.get$length$asx(data), false);
    }, "call$1", "get$add", 2, 0, 83],
    addSlice$4: function(data, start, end, isLast) {
      var out, e, t1, t2, exception;
      if (this._closed)
        return;
      if (J.$lt$n(start, 0) || J.$gt$n(start, J.get$length$asx(data)))
        throw H.wrapException(P.ArgumentError$("Invalid start position"));
      if (J.$lt$n(end, 0) || J.$gt$n(end, J.get$length$asx(data)) || J.$lt$n(end, start))
        throw H.wrapException(P.ArgumentError$("Invalid end position"));
      try {
        this._empty = false;
        t1 = this._filter;
        t1.process$3(data, start, end);
        out = null;
        for (t2 = this._io$_sink; out = t1.processed$1$flush(false), true;)
          t2.add$1(0, out);
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        this._closed = true;
        throw H.wrapException(e);
      }

      if (isLast)
        this.close$0();
    },
    close$0: function() {
      var out, e, t1, t2, exception;
      if (this._closed)
        return;
      if (this._empty)
        this._filter.process$3(C.List_empty, 0, 0);
      try {
        out = null;
        for (t1 = this._filter, t2 = this._io$_sink; out = t1.processed$1$end(true), true;)
          t2.add$1(0, out);
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        this._closed = true;
        throw H.wrapException(e);
      }

      if (!this._closed)
        this._filter.end$0();
      this._closed = true;
      this._io$_sink.close$0();
    }
  },
  HttpServer: {
    "^": "Object;"
  },
  Cookie: {
    "^": "Object;"
  },
  HttpRequest: {
    "^": "Object;"
  },
  HttpResponse: {
    "^": "Object;",
    $isHttpResponse: true
  },
  HttpClientRequest: {
    "^": "Object;"
  },
  HttpClientResponse: {
    "^": "Object;"
  },
  HttpException: {
    "^": "Object;message<,uri<",
    toString$0: function(_) {
      var b, t1;
      b = P.StringBuffer$("");
      b.write$1("HttpException: ");
      b.write$1(this.message);
      t1 = this.uri;
      if (t1 != null)
        b.write$1(", uri = " + H.S(t1));
      return b._contents;
    },
    static: {HttpException$: function(message, uri) {
        return new P.HttpException(message, uri);
      }}
  },
  RedirectException: {
    "^": "Object;message<,redirects<",
    toString$0: function(_) {
      return "RedirectException: " + this.message;
    },
    get$uri: function() {
      return C.JSArray_methods.get$last(this.redirects).get$location();
    }
  },
  _HttpHeaders: {
    "^": "Object;_headers,protocolVersion,_mutable,_noFoldingHeaders,_contentLength,_persistentConnection,_chunkedTransferEncoding,_io$_host,_io$_port,_defaultPortForScheme",
    $index: function(_, $name) {
      return this._headers.$index(0, J.toLowerCase$0$s($name));
    },
    value$1: [function($name) {
      var values, t1;
      $name = J.toLowerCase$0$s($name);
      values = this._headers.$index(0, $name);
      if (values == null)
        return;
      t1 = J.getInterceptor$asx(values);
      if (J.$gt$n(t1.get$length(values), 1))
        throw H.wrapException(P.HttpException$("More than one value for header " + $name, null));
      return t1.$index(values, 0);
    }, "call$1", "get$value", 2, 0, 50, 96],
    add$2: [function(_, $name, value) {
      if (!this._mutable)
        H.throwExpression(P.HttpException$("HTTP headers are not mutable", null));
      this._addAll$2(P._HttpHeaders__validateField($name), value);
    }, "call$2", "get$add", 4, 0, 97],
    _addAll$2: function($name, value) {
      var t1 = J.getInterceptor(value);
      if (!!t1.$isIterable)
        for (t1 = t1.get$iterator(value); t1.moveNext$0();)
          this._io$_add$2($name, P._HttpHeaders__validateValue(t1.get$current()));
      else
        this._io$_add$2($name, P._HttpHeaders__validateValue(value));
    },
    set$2: function($name, value) {
      if (!this._mutable)
        H.throwExpression(P.HttpException$("HTTP headers are not mutable", null));
      $name = P._HttpHeaders__validateField($name);
      this._headers.remove$1(0, $name);
      if ($name === "transfer-encoding")
        this._chunkedTransferEncoding = false;
      this._addAll$2($name, value);
    },
    remove$2: function(_, $name, value) {
      var t1, values, t2, index;
      if (!this._mutable)
        H.throwExpression(P.HttpException$("HTTP headers are not mutable", null));
      $name = P._HttpHeaders__validateField($name);
      value = P._HttpHeaders__validateValue(value);
      t1 = this._headers;
      values = t1.$index(0, $name);
      if (values != null) {
        t2 = J.getInterceptor$asx(values);
        index = t2.indexOf$1(values, value);
        if (index !== -1)
          t2.removeRange$2(values, index, index + 1);
        if (t2.get$length(values) === 0)
          t1.remove$1(0, $name);
      }
      if ($name === "transfer-encoding" && J.$eq(value, "chunked"))
        this._chunkedTransferEncoding = false;
    },
    forEach$1: function(_, f) {
      this._headers.forEach$1(0, f);
    },
    set$persistentConnection: function(persistentConnection) {
      var t1 = !this._mutable;
      if (t1)
        H.throwExpression(P.HttpException$("HTTP headers are not mutable", null));
      if (persistentConnection === this._persistentConnection)
        return;
      if (persistentConnection)
        if (this.protocolVersion === "1.1")
          this.remove$2(0, "connection", "close");
        else {
          if (J.$eq(this._contentLength, -1))
            throw H.wrapException(P.HttpException$("Trying to set 'Connection: Keep-Alive' on HTTP 1.0 headers with no ContentLength", null));
          if (!this._mutable)
            H.throwExpression(P.HttpException$("HTTP headers are not mutable", null));
          this._addAll$2(P._HttpHeaders__validateField("connection"), "keep-alive");
        }
      else if (this.protocolVersion === "1.1") {
        if (t1)
          H.throwExpression(P.HttpException$("HTTP headers are not mutable", null));
        this._addAll$2(P._HttpHeaders__validateField("connection"), "close");
      } else
        this.remove$2(0, "connection", "keep-alive");
      this._persistentConnection = persistentConnection;
    },
    set$contentLength: function(contentLength) {
      var t1;
      if (!this._mutable)
        H.throwExpression(P.HttpException$("HTTP headers are not mutable", null));
      t1 = this.protocolVersion;
      if (t1 === "1.0" && this._persistentConnection && J.$eq(contentLength, -1))
        throw H.wrapException(P.HttpException$("Trying to clear ContentLength on HTTP 1.0 headers with 'Connection: Keep-Alive' set", null));
      if (J.$eq(this._contentLength, contentLength))
        return;
      this._contentLength = contentLength;
      if (J.$ge$n(contentLength, 0)) {
        if (this._chunkedTransferEncoding)
          this.set$chunkedTransferEncoding(false);
        this._set$2("content-length", J.toString$0(contentLength));
      } else {
        if (!this._mutable)
          H.throwExpression(P.HttpException$("HTTP headers are not mutable", null));
        this._headers.remove$1(0, P._HttpHeaders__validateField("content-length"));
        if (t1 === "1.1")
          this.set$chunkedTransferEncoding(true);
      }
    },
    set$chunkedTransferEncoding: function(chunkedTransferEncoding) {
      var values;
      if (!this._mutable)
        H.throwExpression(P.HttpException$("HTTP headers are not mutable", null));
      if (chunkedTransferEncoding && this.protocolVersion === "1.0")
        throw H.wrapException(P.HttpException$("Trying to set 'Transfer-Encoding: Chunked' on HTTP 1.0 headers", null));
      if (chunkedTransferEncoding === this._chunkedTransferEncoding)
        return;
      if (chunkedTransferEncoding) {
        values = this._headers.$index(0, "transfer-encoding");
        if (values == null || !J.$eq(J.get$last$ax(values), "chunked"))
          this._addValue$2("transfer-encoding", "chunked");
        this.set$contentLength(-1);
      } else
        this.remove$2(0, "transfer-encoding", "chunked");
      this._chunkedTransferEncoding = chunkedTransferEncoding;
    },
    get$host: function() {
      return this._io$_host;
    },
    get$port: function() {
      return this._io$_port;
    },
    get$contentType: function() {
      var values, t1, result, index, t2;
      values = this._headers.$index(0, "content-type");
      if (values != null) {
        t1 = J.$index$asx(values, 0);
        result = new P._ContentType("", "", "", null, null);
        result._HeaderValue$2("", null);
        result._parse$3(t1, ";", false);
        index = C.JSString_methods.indexOf$1(result._io$_value, "/");
        t1 = index === -1 || index === result._io$_value.length - 1;
        t2 = result._io$_value;
        if (t1) {
          result._primaryType = C.JSString_methods.trim$0(t2).toLowerCase();
          result._subType = "";
        } else {
          result._primaryType = C.JSString_methods.trim$0(C.JSString_methods.substring$2(t2, 0, index)).toLowerCase();
          result._subType = C.JSString_methods.trim$0(C.JSString_methods.substring$1(result._io$_value, index + 1)).toLowerCase();
        }
        return result;
      } else
        return;
    },
    _io$_add$2: function($name, value) {
      var lowerCaseValue;
      switch ($name.length) {
        case 4:
          if ("date" === $name) {
            if (!!J.getInterceptor(value).$isDateTime) {
              if (!this._mutable)
                H.throwExpression(P.HttpException$("HTTP headers are not mutable", null));
              this._set$2("date", P.HttpDate_format(value.toUtc$0()));
            } else if (typeof value === "string")
              this._set$2("date", value);
            else
              H.throwExpression(P.HttpException$("Unexpected type for header named " + $name, null));
            return;
          }
          if ("host" === $name) {
            this._addHost$2($name, value);
            return;
          }
          break;
        case 7:
          if ("expires" === $name) {
            if (!!J.getInterceptor(value).$isDateTime) {
              if (!this._mutable)
                H.throwExpression(P.HttpException$("HTTP headers are not mutable", null));
              this._set$2("expires", P.HttpDate_format(value.toUtc$0()));
            } else if (typeof value === "string")
              this._set$2("expires", value);
            else
              H.throwExpression(P.HttpException$("Unexpected type for header named " + $name, null));
            return;
          }
          break;
        case 10:
          if ("connection" === $name) {
            lowerCaseValue = J.toLowerCase$0$s(value);
            if (lowerCaseValue === "close")
              this._persistentConnection = false;
            else if (lowerCaseValue === "keep-alive")
              this._persistentConnection = true;
            this._addValue$2($name, value);
            return;
          }
          break;
        case 12:
          if ("content-type" === $name) {
            this._set$2("content-type", value);
            return;
          }
          break;
        case 14:
          if ("content-length" === $name) {
            if (typeof value === "number" && Math.floor(value) === value)
              this.set$contentLength(value);
            else if (typeof value === "string")
              this.set$contentLength(H.Primitives_parseInt(value, null, null));
            else
              H.throwExpression(P.HttpException$("Unexpected type for header named " + $name, null));
            return;
          }
          break;
        case 17:
          if ("transfer-encoding" === $name) {
            if (J.$eq(value, "chunked"))
              this.set$chunkedTransferEncoding(true);
            else
              this._addValue$2("transfer-encoding", value);
            return;
          }
          if ("if-modified-since" === $name) {
            if (!!J.getInterceptor(value).$isDateTime) {
              if (!this._mutable)
                H.throwExpression(P.HttpException$("HTTP headers are not mutable", null));
              this._set$2("if-modified-since", P.HttpDate_format(value.toUtc$0()));
            } else if (typeof value === "string")
              this._set$2("if-modified-since", value);
            else
              H.throwExpression(P.HttpException$("Unexpected type for header named " + $name, null));
            return;
          }
          break;
      }
      this._addValue$2($name, value);
    },
    _addHost$2: function($name, value) {
      var pos, t1, exception;
      t1 = value;
      if (typeof t1 === "string") {
        pos = J.indexOf$1$asx(value, ":");
        if (J.$eq(pos, -1)) {
          this._io$_host = value;
          this._io$_port = 80;
        } else {
          if (J.$gt$n(pos, 0))
            this._io$_host = J.substring$2$s(value, 0, pos);
          else
            this._io$_host = null;
          if (J.$add$ns(pos, 1) === J.get$length$asx(value))
            this._io$_port = 80;
          else
            try {
              this._io$_port = H.Primitives_parseInt(J.substring$1$s(value, J.$add$ns(pos, 1)), null, null);
            } catch (exception) {
              if (!!J.getInterceptor(H.unwrapException(exception)).$isFormatException)
                this._io$_port = null;
              else
                throw exception;
            }

        }
        this._set$2("host", value);
      } else
        throw H.wrapException(P.HttpException$("Unexpected type for header named " + $name, null));
    },
    _addValue$2: function($name, value) {
      var t1, values, t2;
      t1 = this._headers;
      values = t1.$index(0, $name);
      if (values == null) {
        values = H.setRuntimeTypeInfo([], [P.String]);
        t1.$indexSet(0, $name, values);
      }
      t1 = J.getInterceptor(value);
      if (!!t1.$isDateTime)
        J.add$1$ax(values, P.HttpDate_format(value));
      else {
        t2 = J.getInterceptor$ax(values);
        if (typeof value === "string")
          t2.add$1(values, value);
        else
          t2.add$1(values, P._HttpHeaders__validateValue(t1.toString$0(value)));
      }
    },
    _set$2: function($name, value) {
      var values = H.setRuntimeTypeInfo([], [P.String]);
      this._headers.$indexSet(0, $name, values);
      values.push(value);
    },
    _updateHostHeader$0: function() {
      var t1, portPart;
      t1 = this._io$_port;
      portPart = t1 == null || J.$eq(t1, this._defaultPortForScheme) ? "" : ":" + H.S(this._io$_port);
      this._set$2("host", H.S(this._io$_host) + portPart);
    },
    _foldHeader$1: function($name) {
      var t1;
      if (!J.$eq($name, "set-cookie"))
        t1 = false;
      else
        t1 = true;
      if (t1)
        return false;
      return true;
    },
    _write$2: function(buffer, offset) {
      var t1, t2, t3, t4, t5, $name, values, fold, nameData, i, t6;
      t1 = {};
      t1.offset_0 = offset;
      t2 = new P._HttpHeaders__write_write(t1, buffer);
      for (t3 = this._headers, t4 = H.setRuntimeTypeInfo(new P.HashMapKeyIterable(t3), [H.getTypeArgumentByIndex(t3, 0)]), t5 = t4._map, t4 = H.setRuntimeTypeInfo(new P.HashMapKeyIterator(t5, t5._computeKeys$0(), 0, null), [H.getTypeArgumentByIndex(t4, 0)]); t4.moveNext$0();) {
        $name = t4._collection$_current;
        values = t3.$index(0, $name);
        fold = this._foldHeader$1($name);
        nameData = J.get$codeUnits$s($name);
        t2.call$1(nameData);
        t5 = t1.offset_0;
        offset = t5 + 1;
        t1.offset_0 = offset;
        if (t5 < 0 || t5 >= 8192)
          return H.ioore(buffer, t5);
        buffer[t5] = 58;
        t1.offset_0 = offset + 1;
        if (offset < 0 || offset >= 8192)
          return H.ioore(buffer, offset);
        buffer[offset] = 32;
        t5 = J.getInterceptor$asx(values);
        i = 0;
        while (true) {
          t6 = t5.get$length(values);
          if (typeof t6 !== "number")
            return H.iae(t6);
          if (!(i < t6))
            break;
          if (i > 0) {
            t6 = t1.offset_0;
            if (fold) {
              offset = t6 + 1;
              t1.offset_0 = offset;
              if (t6 < 0 || t6 >= 8192)
                return H.ioore(buffer, t6);
              buffer[t6] = 44;
              t1.offset_0 = offset + 1;
              if (offset < 0 || offset >= 8192)
                return H.ioore(buffer, offset);
              buffer[offset] = 32;
            } else {
              offset = t6 + 1;
              t1.offset_0 = offset;
              if (t6 < 0 || t6 >= 8192)
                return H.ioore(buffer, t6);
              buffer[t6] = 13;
              t1.offset_0 = offset + 1;
              if (offset < 0 || offset >= 8192)
                return H.ioore(buffer, offset);
              buffer[offset] = 10;
              t2.call$1(nameData);
              t6 = t1.offset_0;
              offset = t6 + 1;
              t1.offset_0 = offset;
              if (t6 < 0 || t6 >= 8192)
                return H.ioore(buffer, t6);
              buffer[t6] = 58;
              t1.offset_0 = offset + 1;
              if (offset < 0 || offset >= 8192)
                return H.ioore(buffer, offset);
              buffer[offset] = 32;
            }
          }
          t2.call$1(J.get$codeUnits$s(t5.$index(values, i)));
          ++i;
        }
        t5 = t1.offset_0;
        offset = t5 + 1;
        t1.offset_0 = offset;
        if (t5 < 0 || t5 >= 8192)
          return H.ioore(buffer, t5);
        buffer[t5] = 13;
        t1.offset_0 = offset + 1;
        if (offset < 0 || offset >= 8192)
          return H.ioore(buffer, offset);
        buffer[offset] = 10;
      }
      return t1.offset_0;
    },
    toString$0: function(_) {
      var sb = P.StringBuffer$("");
      this._headers.forEach$1(0, new P._HttpHeaders_toString_closure(this, sb));
      return sb._contents;
    },
    _parseCookies$0: function() {
      var cookies, values;
      cookies = H.setRuntimeTypeInfo([], [P.Cookie]);
      values = this._headers.$index(0, "cookie");
      if (values != null)
        J.forEach$1$ax(values, new P._HttpHeaders__parseCookies_closure(new P._HttpHeaders__parseCookies_parseCookieString(cookies)));
      return cookies;
    },
    _HttpHeaders$3$defaultPortForScheme$initialHeaders: function(protocolVersion, defaultPortForScheme, initialHeaders) {
      if (initialHeaders != null) {
        initialHeaders._headers.forEach$1(0, new P._HttpHeaders_closure(this));
        this._contentLength = initialHeaders._contentLength;
        this._persistentConnection = initialHeaders._persistentConnection;
        this._chunkedTransferEncoding = initialHeaders._chunkedTransferEncoding;
        this._io$_host = initialHeaders._io$_host;
        this._io$_port = initialHeaders._io$_port;
      }
      if (this.protocolVersion === "1.0") {
        this._persistentConnection = false;
        this._chunkedTransferEncoding = false;
      }
    },
    static: {_HttpHeaders$: function(protocolVersion, defaultPortForScheme, initialHeaders) {
        var t1 = new P._HttpHeaders(P.HashMap_HashMap(null, null, null, P.String, [P.List, P.String]), protocolVersion, true, null, -1, true, false, null, null, defaultPortForScheme);
        t1._HttpHeaders$3$defaultPortForScheme$initialHeaders(protocolVersion, defaultPortForScheme, initialHeaders);
        return t1;
      }, _HttpHeaders__validateField: function(field) {
        var t1, i, t2;
        t1 = J.getInterceptor$asx(field);
        i = 0;
        while (true) {
          t2 = t1.get$length(field);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          t2 = t1.codeUnitAt$1(field, i);
          if (!(t2 > 31 && t2 < 128 && !C.List_NUU[t2]))
            throw H.wrapException(P.FormatException$("Invalid HTTP header field name: " + C.JsonCodec_null_null.encode$1(field), null, null));
          ++i;
        }
        return t1.toLowerCase$0(field);
      }, _HttpHeaders__validateValue: function(value) {
        var t1, i, t2;
        if (typeof value !== "string")
          return value;
        for (t1 = value.length, i = 0; i < t1; ++i) {
          t2 = C.JSString_methods.codeUnitAt$1(value, i);
          if (!(t2 > 31 && t2 < 128 || t2 === 32 || t2 === 9))
            throw H.wrapException(P.FormatException$("Invalid HTTP header field value: " + C.JsonCodec_null_null.encode$1(value), null, null));
        }
        return value;
      }}
  },
  _HttpHeaders_closure: {
    "^": "Closure:56;this_0",
    call$2: function($name, value) {
      this.this_0._headers.$indexSet(0, $name, value);
      return value;
    },
    $isFunction: true
  },
  _HttpHeaders__write_write: {
    "^": "Closure:83;box_0,buffer_1",
    call$1: function(bytes) {
      var t1, len, t2, t3, i, t4, t5;
      t1 = bytes._string;
      len = t1.length;
      for (t2 = this.buffer_1, t3 = this.box_0, i = 0; i < len; ++i) {
        t4 = t3.offset_0 + i;
        if (i >= len)
          H.throwExpression(P.RangeError$value(i));
        t5 = t1.charCodeAt(i);
        if (t4 < 0 || t4 >= 8192)
          return H.ioore(t2, t4);
        t2[t4] = t5;
      }
      t3.offset_0 += len;
    },
    $isFunction: true
  },
  _HttpHeaders_toString_closure: {
    "^": "Closure:98;this_0,sb_1",
    call$2: function($name, values) {
      var t1, fold, t2, t3, i, t4, str;
      t1 = this.sb_1;
      t1.write$1($name);
      t1.write$1(": ");
      fold = this.this_0._foldHeader$1($name);
      t2 = J.getInterceptor$asx(values);
      t3 = typeof $name === "string";
      i = 0;
      while (true) {
        t4 = t2.get$length(values);
        if (typeof t4 !== "number")
          return H.iae(t4);
        if (!(i < t4))
          break;
        if (i > 0)
          if (fold)
            t1._contents += ", ";
          else {
            t1._contents += "\n";
            t4 = t1._contents += t3 ? $name : H.S($name);
            t1._contents = t4 + ": ";
          }
        str = t2.$index(values, i);
        t1._contents += typeof str === "string" ? str : H.S(str);
        ++i;
      }
      t1.write$1("\n");
    },
    $isFunction: true
  },
  _HttpHeaders__parseCookies_parseCookieString: {
    "^": "Closure:38;cookies_1",
    call$1: function(s) {
      var t1, $name, value, t2, t3, t4, t5, t6, t7, t8, t9, exception;
      t1 = {};
      t1.index_0 = 0;
      t2 = new P._HttpHeaders__parseCookies_parseCookieString_done(t1, s);
      t3 = new P._HttpHeaders__parseCookies_parseCookieString_skipWS(t1, s, t2);
      t4 = new P._HttpHeaders__parseCookies_parseCookieString_parseName(t1, s, t2);
      t5 = new P._HttpHeaders__parseCookies_parseCookieString_parseValue(t1, s, t2);
      t6 = new P._HttpHeaders__parseCookies_parseCookieString_expect(t1, s, t2);
      for (t7 = this.cookies_1, t8 = J.getInterceptor$asx(s); t2.call$0() !== true;) {
        t3.call$0();
        if (t2.call$0() === true)
          return;
        $name = t4.call$0();
        t3.call$0();
        if (t6.call$1("=") !== true) {
          t1.index_0 = t8.indexOf$2(s, ";", t1.index_0);
          continue;
        }
        t3.call$0();
        value = t5.call$0();
        try {
          t9 = new P._Cookie($name, value, null, null, null, null, false, false);
          t9.httpOnly = true;
          t9._validate$0();
          t7.push(t9);
        } catch (exception) {
          H.unwrapException(exception);
        }

        t3.call$0();
        if (t2.call$0() === true)
          return;
        if (t6.call$1(";") !== true) {
          t1.index_0 = t8.indexOf$2(s, ";", t1.index_0);
          continue;
        }
      }
    },
    $isFunction: true
  },
  _HttpHeaders__parseCookies_parseCookieString_done: {
    "^": "Closure:68;box_0,s_2",
    call$0: function() {
      var t1 = this.box_0.index_0;
      return t1 === -1 || t1 === J.get$length$asx(this.s_2);
    },
    $isFunction: true
  },
  _HttpHeaders__parseCookies_parseCookieString_skipWS: {
    "^": "Closure:12;box_0,s_3,done_4",
    call$0: function() {
      var t1, t2, t3, t4;
      for (t1 = this.done_4, t2 = this.box_0, t3 = this.s_3, t4 = J.getInterceptor$asx(t3); t1.call$0() !== true;) {
        if (!J.$eq(t4.$index(t3, t2.index_0), " ") && !J.$eq(t4.$index(t3, t2.index_0), "\t"))
          return;
        ++t2.index_0;
      }
    },
    $isFunction: true
  },
  _HttpHeaders__parseCookies_parseCookieString_parseName: {
    "^": "Closure:99;box_0,s_5,done_6",
    call$0: function() {
      var t1, start, t2, t3, t4;
      t1 = this.box_0;
      start = t1.index_0;
      for (t2 = this.done_6, t3 = this.s_5, t4 = J.getInterceptor$asx(t3); t2.call$0() !== true;) {
        if (J.$eq(t4.$index(t3, t1.index_0), " ") || J.$eq(t4.$index(t3, t1.index_0), "\t") || J.$eq(t4.$index(t3, t1.index_0), "="))
          break;
        ++t1.index_0;
      }
      return t4.substring$2(t3, start, t1.index_0);
    },
    $isFunction: true
  },
  _HttpHeaders__parseCookies_parseCookieString_parseValue: {
    "^": "Closure:99;box_0,s_7,done_8",
    call$0: function() {
      var t1, start, t2, t3, t4;
      t1 = this.box_0;
      start = t1.index_0;
      for (t2 = this.done_8, t3 = this.s_7, t4 = J.getInterceptor$asx(t3); t2.call$0() !== true;) {
        if (J.$eq(t4.$index(t3, t1.index_0), " ") || J.$eq(t4.$index(t3, t1.index_0), "\t") || J.$eq(t4.$index(t3, t1.index_0), ";"))
          break;
        ++t1.index_0;
      }
      return t4.substring$2(t3, start, t1.index_0);
    },
    $isFunction: true
  },
  _HttpHeaders__parseCookies_parseCookieString_expect: {
    "^": "Closure:100;box_0,s_9,done_10",
    call$1: function(expected) {
      var t1;
      if (this.done_10.call$0() === true)
        return false;
      t1 = this.box_0;
      if (!J.$eq(J.$index$asx(this.s_9, t1.index_0), expected))
        return false;
      ++t1.index_0;
      return true;
    },
    $isFunction: true
  },
  _HttpHeaders__parseCookies_closure: {
    "^": "Closure:58;parseCookieString_11",
    call$1: [function(headerValue) {
      return this.parseCookieString_11.call$1(headerValue);
    }, "call$1", null, 2, 0, null, 101, "call"],
    $isFunction: true
  },
  _HeaderValue: {
    "^": "Object;_io$_value,_parameters,_unmodifiableParameters",
    get$value: function() {
      return this._io$_value;
    },
    _ensureParameters$0: function() {
      if (this._parameters == null)
        this._parameters = P.HashMap_HashMap(null, null, null, P.String, P.String);
    },
    get$parameters: function() {
      this._ensureParameters$0();
      var t1 = this._unmodifiableParameters;
      if (t1 == null) {
        t1 = H.setRuntimeTypeInfo(new P.UnmodifiableMapView(this._parameters), [null, null]);
        this._unmodifiableParameters = t1;
      }
      return t1;
    },
    toString$0: function(_) {
      var sb, t1;
      sb = P.StringBuffer$("");
      sb.write$1(this._io$_value);
      if (this.get$parameters() != null) {
        t1 = this.get$parameters()._map;
        t1 = t1.get$length(t1) > 0;
      } else
        t1 = false;
      if (t1)
        this._parameters.forEach$1(0, new P._HeaderValue_toString_closure(sb));
      return sb._contents;
    },
    _parse$3: function(s, parameterSeparator, preserveBackslash) {
      var t1, t2, t3, t4;
      t1 = {};
      t1.index_0 = 0;
      t2 = new P._HeaderValue__parse_done(t1, s);
      t3 = new P._HeaderValue__parse_skipWS(t1, s, t2);
      t4 = new P._HeaderValue__parse_parseValue(t1, s, parameterSeparator, t2);
      t3.call$0();
      this._io$_value = t4.call$0();
      t3.call$0();
      if (t2.call$0() === true)
        return;
      new P._HeaderValue__parse_maybeExpect(t1, s).call$1(parameterSeparator);
      new P._HeaderValue__parse_parseParameters(t1, this, s, parameterSeparator, preserveBackslash, t2, t3, t4, new P._HeaderValue__parse_expect(t1, s, t2)).call$0();
    },
    _HeaderValue$2: function(_value, parameters) {
    },
    static: {_HeaderValue$: function(_value, parameters) {
        var t1 = new P._HeaderValue(_value, null, null);
        t1._HeaderValue$2(_value, parameters);
        return t1;
      }}
  },
  _HeaderValue_toString_closure: {
    "^": "Closure:102;sb_0",
    call$2: function($name, value) {
      var t1 = this.sb_0;
      t1.write$1("; ");
      t1.write$1($name);
      t1.write$1("=");
      t1.write$1(value);
    },
    $isFunction: true
  },
  _HeaderValue__parse_done: {
    "^": "Closure:68;box_0,s_1",
    call$0: function() {
      return this.box_0.index_0 === J.get$length$asx(this.s_1);
    },
    $isFunction: true
  },
  _HeaderValue__parse_skipWS: {
    "^": "Closure:12;box_0,s_2,done_3",
    call$0: function() {
      var t1, t2, t3, t4;
      for (t1 = this.done_3, t2 = this.box_0, t3 = this.s_2, t4 = J.getInterceptor$asx(t3); t1.call$0() !== true;) {
        if (!J.$eq(t4.$index(t3, t2.index_0), " ") && !J.$eq(t4.$index(t3, t2.index_0), "\t"))
          return;
        ++t2.index_0;
      }
    },
    $isFunction: true
  },
  _HeaderValue__parse_parseValue: {
    "^": "Closure:99;box_0,s_4,parameterSeparator_5,done_6",
    call$0: function() {
      var t1, start, t2, t3, t4, t5;
      t1 = this.box_0;
      start = t1.index_0;
      for (t2 = this.done_6, t3 = this.s_4, t4 = J.getInterceptor$asx(t3), t5 = this.parameterSeparator_5; t2.call$0() !== true;) {
        if (J.$eq(t4.$index(t3, t1.index_0), " ") || J.$eq(t4.$index(t3, t1.index_0), "\t") || J.$eq(t4.$index(t3, t1.index_0), t5))
          break;
        ++t1.index_0;
      }
      return t4.substring$2(t3, start, t1.index_0);
    },
    $isFunction: true
  },
  _HeaderValue__parse_expect: {
    "^": "Closure:38;box_0,s_7,done_8",
    call$1: function(expected) {
      if (this.done_8.call$0() === true || !J.$eq(J.$index$asx(this.s_7, this.box_0.index_0), expected))
        throw H.wrapException(P.HttpException$("Failed to parse header value", null));
      ++this.box_0.index_0;
    },
    $isFunction: true
  },
  _HeaderValue__parse_maybeExpect: {
    "^": "Closure:38;box_0,s_9",
    call$1: function(expected) {
      var t1 = this.box_0;
      if (J.$eq(J.$index$asx(this.s_9, t1.index_0), expected))
        ++t1.index_0;
    },
    $isFunction: true
  },
  _HeaderValue__parse_parseParameters: {
    "^": "Closure:12;box_0,this_10,s_11,parameterSeparator_12,preserveBackslash_13,done_14,skipWS_15,parseValue_16,expect_17",
    call$0: function() {
      var parameters, t1, t2, t3, t4, t5, t6, $name;
      parameters = P.HashMap_HashMap(null, null, null, P.String, P.String);
      this.this_10._parameters = H.setRuntimeTypeInfo(new P.UnmodifiableMapView(parameters), [null, null]);
      t1 = this.box_0;
      t2 = this.s_11;
      t3 = this.done_14;
      t4 = new P._HeaderValue__parse_parseParameters_parseParameterName(t1, t2, t3);
      t2 = new P._HeaderValue__parse_parseParameters_parseParameterValue(t1, t2, this.preserveBackslash_13, t3, this.parseValue_16);
      for (t1 = this.expect_17, t5 = this.parameterSeparator_12, t6 = this.skipWS_15; t3.call$0() !== true;) {
        t6.call$0();
        if (t3.call$0() === true)
          return;
        $name = t4.call$0();
        t6.call$0();
        t1.call$1("=");
        t6.call$0();
        parameters.$indexSet(0, $name, t2.call$0());
        t6.call$0();
        if (t3.call$0() === true)
          return;
        t1.call$1(t5);
      }
    },
    $isFunction: true
  },
  _HeaderValue__parse_parseParameters_parseParameterName: {
    "^": "Closure:99;box_0,s_18,done_19",
    call$0: function() {
      var t1, start, t2, t3, t4;
      t1 = this.box_0;
      start = t1.index_0;
      for (t2 = this.done_19, t3 = this.s_18, t4 = J.getInterceptor$asx(t3); t2.call$0() !== true;) {
        if (J.$eq(t4.$index(t3, t1.index_0), " ") || J.$eq(t4.$index(t3, t1.index_0), "\t") || J.$eq(t4.$index(t3, t1.index_0), "="))
          break;
        ++t1.index_0;
      }
      return t4.substring$2(t3, start, t1.index_0).toLowerCase();
    },
    $isFunction: true
  },
  _HeaderValue__parse_parseParameters_parseParameterValue: {
    "^": "Closure:99;box_0,s_20,preserveBackslash_21,done_22,parseValue_23",
    call$0: function() {
      var t1, t2, t3, sb, t4, t5, str;
      t1 = this.s_20;
      t2 = this.box_0;
      t3 = J.getInterceptor$asx(t1);
      if (J.$eq(t3.$index(t1, t2.index_0), "\"")) {
        sb = P.StringBuffer$("");
        ++t2.index_0;
        for (t4 = this.done_22, t5 = this.preserveBackslash_21; t4.call$0() !== true;) {
          if (J.$eq(t3.$index(t1, t2.index_0), "\\")) {
            if (t2.index_0 + 1 === t3.get$length(t1))
              throw H.wrapException(P.HttpException$("Failed to parse header value", null));
            if (t5 && !J.$eq(t3.$index(t1, t2.index_0 + 1), "\"")) {
              str = t3.$index(t1, t2.index_0);
              sb._contents += typeof str === "string" ? str : H.S(str);
            }
            ++t2.index_0;
          } else if (J.$eq(t3.$index(t1, t2.index_0), "\"")) {
            ++t2.index_0;
            break;
          }
          str = t3.$index(t1, t2.index_0);
          sb._contents += typeof str === "string" ? str : H.S(str);
          ++t2.index_0;
        }
        return sb._contents;
      } else
        return this.parseValue_23.call$0();
    },
    $isFunction: true
  },
  _ContentType: {
    "^": "_HeaderValue;_primaryType,_subType,_io$_value,_parameters,_unmodifiableParameters",
    _ContentType$4: function(primaryType, subType, charset, parameters) {
      this._io$_value = this._primaryType + "/" + this._subType;
      this._ensureParameters$0();
      this._parameters.$indexSet(0, "charset", charset.toLowerCase());
    },
    static: {_ContentType$: function(primaryType, subType, charset, parameters) {
        var t1 = new P._ContentType(primaryType, subType, "", null, null);
        t1._HeaderValue$2("", null);
        t1._ContentType$4(primaryType, subType, charset, parameters);
        return t1;
      }}
  },
  _ContentType_closure: {
    "^": "Closure:102;this_0",
    call$2: function(key, value) {
      this.this_0._parameters.$indexSet(0, key.toLowerCase$0(0), value.toLowerCase$0(0));
    },
    $isFunction: true
  },
  _Cookie: {
    "^": "Object;name<,value<,expires,maxAge,domain,path,httpOnly,secure",
    toString$0: function(_) {
      var sb = P.StringBuffer$("");
      sb.write$1(this.name);
      sb.write$1("=");
      sb.write$1(this.value);
      if (this.expires != null) {
        sb.write$1("; Expires=");
        sb.write$1(P.HttpDate_format(this.expires));
      }
      if (this.maxAge != null) {
        sb.write$1("; Max-Age=");
        sb.write$1(this.maxAge);
      }
      if (this.domain != null) {
        sb.write$1("; Domain=");
        sb.write$1(this.domain);
      }
      if (this.path != null) {
        sb.write$1("; Path=");
        sb.write$1(this.path);
      }
      if (this.secure)
        sb.write$1("; Secure");
      if (this.httpOnly)
        sb.write$1("; HttpOnly");
      return sb._contents;
    },
    _validate$0: function() {
      var i, t1, t2, codeUnit;
      for (i = 0; t1 = this.name, t2 = t1.length, i < t2; ++i) {
        t1.toString;
        if (i >= t2)
          H.throwExpression(P.RangeError$value(i));
        codeUnit = t1.charCodeAt(i);
        if (codeUnit > 32)
          if (codeUnit < 127) {
            t1 = this.name;
            if (i >= t1.length)
              return H.ioore(t1, i);
            t1 = H.Lists_indexOf(C.List_A8J, t1[i], 0, 17) >= 0;
          } else
            t1 = true;
        else
          t1 = true;
        if (t1)
          throw H.wrapException(P.FormatException$("Invalid character in cookie name, code unit: '" + codeUnit + "'", null, null));
      }
      for (i = 0; t1 = this.value, t2 = t1.length, i < t2; ++i) {
        t1.toString;
        if (i >= t2)
          H.throwExpression(P.RangeError$value(i));
        codeUnit = t1.charCodeAt(i);
        if (codeUnit !== 33)
          if (!(codeUnit >= 35 && codeUnit <= 43))
            if (!(codeUnit >= 45 && codeUnit <= 58))
              if (!(codeUnit >= 60 && codeUnit <= 91))
                t1 = codeUnit >= 93 && codeUnit <= 126;
              else
                t1 = true;
            else
              t1 = true;
          else
            t1 = true;
        else
          t1 = true;
        if (!t1)
          throw H.wrapException(P.FormatException$("Invalid character in cookie value, code unit: '" + codeUnit + "'", null, null));
      }
    }
  },
  _HttpIncoming: {
    "^": "Stream;_transferLength,_dataCompleter,_stream,fullBodyRead<,headers<,upgraded<,statusCode<,reasonPhrase<,method<,uri@,hasSubscriber<",
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var t1;
      this.hasSubscriber = true;
      t1 = this._stream;
      t1 = H.setRuntimeTypeInfo(new P._HandleErrorStream(new P._HttpIncoming_listen_closure(this), null, t1), [H.getRuntimeTypeArgument(t1, "Stream", 0)]);
      return P._ForwardingStreamSubscription$(t1, onData, onError, onDone, true === cancelOnError, H.getRuntimeTypeArgument(t1, "_ForwardingStream", 0), H.getRuntimeTypeArgument(t1, "_ForwardingStream", 1));
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    listen$1: function(onData) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
    },
    get$dataDone: function() {
      return this._dataCompleter.future;
    },
    close$1: function(closing) {
      var t1;
      this.fullBodyRead = true;
      this.hasSubscriber = true;
      t1 = this._dataCompleter.future;
      if (t1._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      t1._asyncComplete$1(closing);
    },
    $asStream: function() {
      return [[P.List, P.$int]];
    }
  },
  _HttpIncoming_listen_closure: {
    "^": "Closure:58;this_0",
    call$1: function(error) {
      throw H.wrapException(P.HttpException$(error.get$message(), this.this_0.uri));
    },
    $isFunction: true
  },
  _HttpInboundMessage: {
    "^": "Stream;_cookies@",
    get$cookies: function() {
      if (this.get$_cookies() != null)
        return this.get$_cookies();
      var t1 = this._incoming.get$headers()._parseCookies$0();
      this.set$_cookies(t1);
      return t1;
    },
    get$headers: function() {
      return this._incoming.get$headers();
    },
    $asStream: function() {
      return [[P.List, P.$int]];
    }
  },
  _HttpRequest: {
    "^": "_HttpInboundMessage;response<,_httpServer,_httpConnection,_session,_requestedUri,_incoming,_cookies",
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      return this._incoming.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    listen$2$cancelOnError: function(onData, cancelOnError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, null, null);
    },
    listen$1: function(onData) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
    },
    get$uri: function() {
      return this._incoming.get$uri();
    },
    get$method: function() {
      return this._incoming.get$method();
    },
    get$connectionInfo: function() {
      return P._HttpConnectionInfo_create(this._httpConnection._socket);
    },
    _HttpRequest$4: function(response, _incoming, _httpServer, _httpConnection) {
      var t1, t2, sessionIds, sessionId, t3;
      t1 = this._incoming;
      if (t1.get$headers().protocolVersion === "1.1") {
        t2 = this.response.headers;
        t2.set$chunkedTransferEncoding(true);
        t2.set$persistentConnection(t1.get$headers()._persistentConnection);
      }
      t1 = this._httpServer;
      if (t1._sessionManagerInstance != null) {
        t2 = this.get$cookies();
        t2.toString;
        t2 = H.setRuntimeTypeInfo(new H.WhereIterable(t2, new P._HttpRequest_closure()), [H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(t2, 0)]), 0)]);
        sessionIds = H.MappedIterable_MappedIterable(t2, new P._HttpRequest_closure0(), H.getRuntimeTypeArgument(t2, "IterableBase", 0), null);
        for (t2 = H.setRuntimeTypeInfo(new H.MappedIterator(null, J.get$iterator$ax(sessionIds._iterable), sessionIds._f), [H.getTypeArgumentByIndex(sessionIds, 0), H.getTypeArgumentByIndex(sessionIds, 1)]); t2.moveNext$0();) {
          sessionId = t2._current;
          t3 = t1._sessionManagerInstance;
          if (t3 == null) {
            t3 = new P._HttpSessionManager(P.LinkedHashMap_LinkedHashMap$_empty(null, null), 1200, null, null, null);
            t1._sessionManagerInstance = t3;
          }
          this._session = t3._sessions.$index(0, sessionId);
        }
      }
    },
    static: {_HttpRequest$: function(response, _incoming, _httpServer, _httpConnection) {
        var t1 = new P._HttpRequest(response, _httpServer, _httpConnection, null, null, _incoming, null);
        t1._HttpRequest$4(response, _incoming, _httpServer, _httpConnection);
        return t1;
      }}
  },
  _HttpRequest_closure: {
    "^": "Closure:58;",
    call$1: function(cookie) {
      var t1 = cookie.get$name();
      t1.toString;
      return t1.toUpperCase() === "DARTSESSID";
    },
    $isFunction: true
  },
  _HttpRequest_closure0: {
    "^": "Closure:58;",
    call$1: [function(cookie) {
      return cookie.get$value();
    }, "call$1", null, 2, 0, null, 103, "call"],
    $isFunction: true
  },
  _HttpClientResponse: {
    "^": "_HttpInboundMessage;_httpClient,_httpRequest<,_cookies:io$_HttpClientResponse$_cookies@,_incoming,_cookies",
    get$redirects: function() {
      return this._httpRequest._responseRedirects;
    },
    get$statusCode: function() {
      return this._incoming.get$statusCode();
    },
    get$reasonPhrase: function() {
      return this._incoming.get$reasonPhrase();
    },
    get$isRedirect: function() {
      var t1 = this._httpRequest.method;
      if (t1 === "GET" || t1 === "HEAD") {
        t1 = this._incoming;
        return t1.get$statusCode() === 301 || t1.get$statusCode() === 302 || t1.get$statusCode() === 303 || t1.get$statusCode() === 307;
      } else if (t1 === "POST")
        return this._incoming.get$statusCode() === 303;
      return false;
    },
    redirect$3: function(method, url, followLoops) {
      var t1, $location, t2, t3;
      t1 = {};
      t1.method_0 = method;
      t1.url_1 = url;
      if (this._incoming.get$statusCode() === 303 && this._httpRequest.method === "POST")
        t1.method_0 = "GET";
      else
        t1.method_0 = this._httpRequest.method;
      if (t1.url_1 == null) {
        $location = this._incoming.get$headers().value$1("location");
        if ($location == null)
          throw H.wrapException(P.StateError$("Response has no Location header for redirect"));
        t1.url_1 = P.Uri_parse($location);
      }
      for (t2 = this._httpRequest._responseRedirects, t3 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]); t3.moveNext$0();)
        if (J.$eq(t3._current.get$location(), t1.url_1)) {
          t1 = new P._Future(0, $.Zone__current, null, null, null, null, null, null);
          t1.$builtinTypeInfo = [null];
          t1._asyncCompleteError$2(new P.RedirectException("Redirect loop detected", t2), null);
          return t1;
        }
      return this._httpClient._openUrlFromRequest$3(t1.method_0, t1.url_1, this._httpRequest).then$1(new P._HttpClientResponse_redirect_closure(t1, this));
    },
    redirect$0: function() {
      return this.redirect$3(null, null, null);
    },
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var stream, t1;
      stream = this._incoming;
      if (stream.get$upgraded()) {
        this._httpRequest._httpClientConnection.destroy$0();
        return P.Stream_Stream$fromIterable([], null).listen$2$onDone(null, onDone);
      }
      if (this._httpClient.autoUncompress && J.$eq(stream.get$headers().value$1("content-encoding"), "gzip")) {
        t1 = C.GZipCodec_yXb.windowBits;
        P._validateZLibWindowBits(t1);
        stream = stream.transform$1(new P.ZLibDecoder(t1, C.GZipCodec_yXb.dictionary, C.GZipCodec_yXb.raw));
      }
      return stream.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    listen$2$cancelOnError: function(onData, cancelOnError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, null, null);
    },
    listen$1: function(onData) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
    },
    get$connectionInfo: function() {
      return P._HttpConnectionInfo_create(this._httpRequest._httpClientConnection._socket);
    },
    _authenticate$1: function(proxyAuth) {
      var t1, t2, result, scheme, realm, cr;
      t1 = {};
      t2 = J.$index$asx(new P._HttpClientResponse__authenticate_authChallenge(this, proxyAuth).call$0(), 0);
      result = P._HeaderValue$("", null);
      result._parse$3(t2, ",", false);
      scheme = P._AuthenticationScheme__AuthenticationScheme$fromString(result._io$_value);
      realm = result.get$parameters()._map.$index(0, "realm");
      cr = new P._HttpClientResponse__authenticate_findCredentials(this, proxyAuth).call$1(scheme);
      t1.cr_0 = cr;
      if (cr != null) {
        cr.get$scheme();
        t1.cr_0.get$scheme();
      }
      t2 = t1.cr_0;
      if (t2 != null) {
        new P._HttpClientResponse__authenticate_removeCredentials(this, proxyAuth).call$1(t2);
        t1.cr_0 = null;
      }
      return new P._HttpClientResponse__authenticate_requestAuthentication(this, proxyAuth).call$2(scheme, realm).then$1(new P._HttpClientResponse__authenticate_closure(t1, this, new P._HttpClientResponse__authenticate_retry(this), scheme));
    }
  },
  _HttpClientResponse_redirect_closure: {
    "^": "Closure:58;box_0,this_1",
    call$1: [function(request) {
      var t1, t2, t3;
      t1 = request.get$_responseRedirects();
      t2 = this.this_1;
      C.JSArray_methods.addAll$1(t1, t2._httpRequest._responseRedirects);
      t3 = this.box_0;
      t1.push(new P._RedirectInfo(t2._incoming.get$statusCode(), t3.method_0, t3.url_1));
      return request.close$0();
    }, "call$1", null, 2, 0, null, 104, "call"],
    $isFunction: true
  },
  _HttpClientResponse__authenticate_retry: {
    "^": "Closure:105;this_1",
    call$0: function() {
      var t1 = this.this_1;
      return t1.listen$2$cancelOnError(null, true).asFuture$1(null).then$1(new P._HttpClientResponse__authenticate_retry_closure(t1));
    },
    $isFunction: true
  },
  _HttpClientResponse__authenticate_retry_closure: {
    "^": "Closure:58;this_2",
    call$1: [function(_) {
      var t1, t2;
      t1 = this.this_2;
      t2 = t1._httpRequest;
      return t1._httpClient._openUrlFromRequest$3(t2.method, t2.uri, t2).then$1(new P._HttpClientResponse__authenticate_retry__closure());
    }, "call$1", null, 2, 0, null, 60, "call"],
    $isFunction: true
  },
  _HttpClientResponse__authenticate_retry__closure: {
    "^": "Closure:58;",
    call$1: [function(request) {
      return request.close$0();
    }, "call$1", null, 2, 0, null, 104, "call"],
    $isFunction: true
  },
  _HttpClientResponse__authenticate_authChallenge: {
    "^": "Closure:106;this_3,proxyAuth_4",
    call$0: function() {
      var t1 = this.this_3;
      return this.proxyAuth_4 ? t1._incoming.get$headers()._headers.$index(0, C.JSString_methods.toLowerCase$0("proxy-authenticate")) : t1._incoming.get$headers()._headers.$index(0, C.JSString_methods.toLowerCase$0("www-authenticate"));
    },
    $isFunction: true
  },
  _HttpClientResponse__authenticate_findCredentials: {
    "^": "Closure:107;this_5,proxyAuth_6",
    call$1: function(scheme) {
      var t1 = this.this_5;
      return this.proxyAuth_6 ? t1._httpClient._findProxyCredentials$2(t1._httpRequest._proxy, scheme) : t1._httpClient._findCredentials$2(t1._httpRequest.uri, scheme);
    },
    $isFunction: true
  },
  _HttpClientResponse__authenticate_removeCredentials: {
    "^": "Closure:108;this_7,proxyAuth_8",
    call$1: function(cr) {
      var t1, index;
      t1 = this.this_7;
      if (this.proxyAuth_8) {
        t1 = t1._httpClient._proxyCredentials;
        index = H.Lists_indexOf(t1, cr, 0, t1.length);
        if (index !== -1)
          C.JSArray_methods.removeAt$1(t1, index);
      } else {
        t1 = t1._httpClient._credentials;
        index = H.Lists_indexOf(t1, cr, 0, t1.length);
        if (index !== -1)
          C.JSArray_methods.removeAt$1(t1, index);
      }
    },
    $isFunction: true
  },
  _HttpClientResponse__authenticate_requestAuthentication: {
    "^": "Closure:109;this_9,proxyAuth_10",
    call$2: function(scheme, realm) {
      if (this.proxyAuth_10)
        return P._Future$immediate(false, null);
      else
        return P._Future$immediate(false, null);
    },
    $isFunction: true
  },
  _HttpClientResponse__authenticate_closure: {
    "^": "Closure:58;box_0,this_11,retry_12,scheme_13",
    call$1: [function(credsAvailable) {
      var t1 = this.this_11;
      if (credsAvailable === true) {
        this.box_0.cr_0 = t1._httpClient._findCredentials$2(t1._httpRequest.uri, this.scheme_13);
        return this.retry_12.call$0();
      } else
        return t1;
    }, "call$1", null, 2, 0, null, 110, "call"],
    $isFunction: true
  },
  _HttpOutboundMessage: {
    "^": "_IOSinkImpl;headers<",
    set$contentLength: function(contentLength) {
      this.headers.set$contentLength(contentLength);
    },
    get$encoding: function() {
      if (this._encodingSet && this._outgoing.headersWritten)
        return this._encoding;
      var t1 = this.headers;
      return P.Encoding_getByName(t1.get$contentType() != null && t1.get$contentType().get$parameters()._map.$index(0, "charset") != null ? t1.get$contentType().get$parameters()._map.$index(0, "charset") : "iso-8859-1");
    },
    add$1: [function(_, data) {
      if (J.get$length$asx(data) === 0)
        return;
      P._StreamSinkImpl.prototype.add$1.call(this, this, data);
    }, "call$1", "get$add", 2, 0, 83],
    write$1: function(obj) {
      if (!this._encodingSet) {
        this._encoding = this.get$encoding();
        this._encodingSet = true;
      }
      P._IOSinkImpl.prototype.write$1.call(this, obj);
    },
    get$_isConnectionClosed: function() {
      return false;
    },
    _HttpOutboundMessage$4$initialHeaders: function(uri, protocolVersion, outgoing, initialHeaders, $T) {
      this._outgoing.outbound = this;
      this._encodingMutable = false;
    }
  },
  _HttpResponse: {
    "^": "_HttpOutboundMessage;_statusCode,_reasonPhrase,_cookies,_httpRequest<,_deadline,_deadlineTimer,_encodingSet,_bufferOutput,_uri,_outgoing,headers,_encoding,_encodingMutable,_io$_target,_doneCompleter,_io$_doneFuture,_controllerInstance,_controllerCompleter,_isClosed,_isBound,_io$_hasError",
    get$_isConnectionClosed: function() {
      return this._httpRequest._httpConnection._io$_state === 2;
    },
    get$statusCode: function() {
      return this._statusCode;
    },
    set$statusCode: function(statusCode) {
      if (this._outgoing.headersWritten)
        throw H.wrapException(P.StateError$("Header already sent"));
      this._statusCode = statusCode;
    },
    get$reasonPhrase: function() {
      return this._findReasonPhrase$1(this._statusCode);
    },
    get$connectionInfo: function() {
      return P._HttpConnectionInfo_create(this._httpRequest._httpConnection._socket);
    },
    set$deadline: function(d) {
      var t1 = this._deadlineTimer;
      if (t1 != null)
        t1.cancel$0();
      this._deadline = d;
      return;
    },
    _writeHeader$0: function() {
      var t1, buffer, t2, t3, t4, offset, offset0;
      t1 = {};
      buffer = new Uint8Array(8192);
      t1.offset_0 = 0;
      t2 = new P._HttpResponse__writeHeader_write(t1, buffer);
      t3 = this.headers;
      if (t3.protocolVersion === "1.1")
        t2.call$1(C.List_2Vk);
      else
        t2.call$1(C.List_2Vk1);
      t4 = t1.offset_0++;
      if (t4 < 0 || t4 >= 8192)
        return H.ioore(buffer, t4);
      buffer[t4] = 32;
      t2.call$1(new J._CodeUnits(C.JSInt_methods.toString$0(this._statusCode)));
      t4 = t1.offset_0++;
      if (t4 < 0 || t4 >= 8192)
        return H.ioore(buffer, t4);
      buffer[t4] = 32;
      t4 = this._findReasonPhrase$1(this._statusCode);
      t4.toString;
      t2.call$1(new J._CodeUnits(t4));
      t4 = t1.offset_0;
      offset = t4 + 1;
      t1.offset_0 = offset;
      if (t4 < 0 || t4 >= 8192)
        return H.ioore(buffer, t4);
      buffer[t4] = 13;
      t1.offset_0 = offset + 1;
      if (offset < 0 || offset >= 8192)
        return H.ioore(buffer, offset);
      buffer[offset] = 10;
      this._httpRequest._session;
      t2 = this._cookies;
      if (t2 != null) {
        t2.toString;
        H.IterableMixinWorkaround_forEach(t2, new P._HttpResponse__writeHeader_closure(this));
      }
      t3._mutable = false;
      offset = t3._write$2(buffer, t1.offset_0);
      t1.offset_0 = offset;
      offset0 = offset + 1;
      t1.offset_0 = offset0;
      if (offset < 0 || offset >= 8192)
        return H.ioore(buffer, offset);
      buffer[offset] = 13;
      offset = offset0 + 1;
      t1.offset_0 = offset;
      if (offset0 < 0 || offset0 >= 8192)
        return H.ioore(buffer, offset0);
      buffer[offset0] = 10;
      this._outgoing.setHeader$2(buffer, offset);
    },
    _findReasonPhrase$1: function(statusCode) {
      switch (statusCode) {
        case 100:
          return "Continue";
        case 101:
          return "Switching Protocols";
        case 200:
          return "OK";
        case 201:
          return "Created";
        case 202:
          return "Accepted";
        case 203:
          return "Non-Authoritative Information";
        case 204:
          return "No Content";
        case 205:
          return "Reset Content";
        case 206:
          return "Partial Content";
        case 300:
          return "Multiple Choices";
        case 301:
          return "Moved Permanently";
        case 302:
          return "Found";
        case 303:
          return "See Other";
        case 304:
          return "Not Modified";
        case 305:
          return "Use Proxy";
        case 307:
          return "Temporary Redirect";
        case 400:
          return "Bad Request";
        case 401:
          return "Unauthorized";
        case 402:
          return "Payment Required";
        case 403:
          return "Forbidden";
        case 404:
          return "Not Found";
        case 405:
          return "Method Not Allowed";
        case 406:
          return "Not Acceptable";
        case 407:
          return "Proxy Authentication Required";
        case 408:
          return "Request Time-out";
        case 409:
          return "Conflict";
        case 410:
          return "Gone";
        case 411:
          return "Length Required";
        case 412:
          return "Precondition Failed";
        case 413:
          return "Request Entity Too Large";
        case 414:
          return "Request-URI Too Large";
        case 415:
          return "Unsupported Media Type";
        case 416:
          return "Requested range not satisfiable";
        case 417:
          return "Expectation Failed";
        case 500:
          return "Internal Server Error";
        case 501:
          return "Not Implemented";
        case 502:
          return "Bad Gateway";
        case 503:
          return "Service Unavailable";
        case 504:
          return "Gateway Time-out";
        case 505:
          return "Http Version not supported";
        default:
          return "Status " + statusCode;
      }
    },
    $is_HttpResponse: true,
    $as_HttpOutboundMessage: function() {
      return [P.HttpResponse];
    },
    $as_StreamSinkImpl: function() {
      return [[P.List, P.$int]];
    },
    $isHttpResponse: true
  },
  _HttpResponse_deadline_closure: {
    "^": "Closure:55;this_0",
    call$0: [function() {
      this.this_0._httpRequest._httpConnection.destroy$0();
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _HttpResponse__writeHeader_write: {
    "^": "Closure:83;box_0,buffer_1",
    call$1: function(bytes) {
      var t1, len, t2, t3, i, t4, t5;
      t1 = J.getInterceptor$asx(bytes);
      len = t1.get$length(bytes);
      for (t2 = this.buffer_1, t3 = this.box_0, i = 0; i < len; ++i) {
        t4 = t3.offset_0 + i;
        t5 = t1.$index(bytes, i);
        if (t4 < 0 || t4 >= 8192)
          return H.ioore(t2, t4);
        t2[t4] = t5;
      }
      t3.offset_0 += len;
    },
    $isFunction: true
  },
  _HttpResponse__writeHeader_closure: {
    "^": "Closure:58;this_2",
    call$1: function(cookie) {
      var t1 = this.this_2.headers;
      if (!t1._mutable)
        H.throwExpression(P.HttpException$("HTTP headers are not mutable", null));
      t1._addAll$2(P._HttpHeaders__validateField("set-cookie"), cookie);
    },
    $isFunction: true
  },
  _HttpClientRequest: {
    "^": "_HttpOutboundMessage;method<,uri<,cookies,_httpClient,_httpClientConnection<,_responseCompleter,_proxy,_response,_followRedirects,_maxRedirects,_responseRedirects<,_encodingSet,_bufferOutput,_uri,_outgoing,headers,_encoding,_encodingMutable,_io$_target,_doneCompleter,_io$_doneFuture,_controllerInstance,_controllerCompleter,_isClosed,_isBound,_io$_hasError",
    get$done: function() {
      var t1 = this._response;
      if (t1 == null) {
        t1 = P.Future_wait([this._responseCompleter.future, P._StreamSinkImpl.prototype.get$done.call(this)], true).then$1(new P._HttpClientRequest_done_closure());
        this._response = t1;
      }
      return t1;
    },
    close$0: function() {
      P._StreamSinkImpl.prototype.close$0.call(this);
      return this.get$done();
    },
    set$maxRedirects: function(maxRedirects) {
      if (this._outgoing.headersWritten)
        throw H.wrapException(P.StateError$("Request already sent"));
      this._maxRedirects = maxRedirects;
    },
    set$followRedirects: function(followRedirects) {
      if (this._outgoing.headersWritten)
        throw H.wrapException(P.StateError$("Request already sent"));
      this._followRedirects = followRedirects;
    },
    get$connectionInfo: function() {
      return P._HttpConnectionInfo_create(this._httpClientConnection._socket);
    },
    _onIncoming$1: function(incoming) {
      var response, future, challenge;
      response = new P._HttpClientResponse(this._httpClient, this, null, incoming, null);
      incoming.set$uri(this.uri);
      if (this._followRedirects && response.get$isRedirect())
        future = this._responseRedirects.length < this._maxRedirects ? response.listen$2$cancelOnError(null, true).asFuture$1(null).then$1(new P._HttpClientRequest__onIncoming_closure(response)) : response.listen$2$cancelOnError(null, true).asFuture$1(null).then$1(new P._HttpClientRequest__onIncoming_closure0(response));
      else {
        challenge = incoming.get$headers()._headers.$index(0, C.JSString_methods.toLowerCase$0("proxy-authenticate"));
        if (incoming.get$statusCode() === 407 && challenge != null && J.get$length$asx(challenge) === 1)
          future = response._authenticate$1(true);
        else {
          challenge = incoming.get$headers()._headers.$index(0, C.JSString_methods.toLowerCase$0("www-authenticate"));
          future = incoming.get$statusCode() === 401 && challenge != null && J.get$length$asx(challenge) === 1 ? response._authenticate$1(false) : P._Future$immediate(response, P.HttpClientResponse);
        }
      }
      future.then$2$onError(new P._HttpClientRequest__onIncoming_closure1(this), this._responseCompleter.get$completeError());
    },
    _requestUri$0: function() {
      var t1 = new P._HttpClientRequest__requestUri_uriStartingFromPath(this);
      if (this._proxy.get$isDirect())
        return t1.call$0();
      else if (this.method === "CONNECT") {
        t1 = this.uri;
        return H.S(t1.get$host()) + ":" + H.S(t1.get$port());
      } else if (this._httpClientConnection._proxyTunnel)
        return t1.call$0();
      else
        return this.uri.toString$0(0);
    },
    _writeHeader$0: function() {
      var t1, buffer, t2, t3, offset, offset0;
      t1 = {};
      buffer = new Uint8Array(8192);
      t1.offset_0 = 0;
      t2 = new P._HttpClientRequest__writeHeader_write(t1, buffer);
      t2.call$1(new J._CodeUnits(this.method));
      t3 = t1.offset_0++;
      if (t3 < 0 || t3 >= 8192)
        return H.ioore(buffer, t3);
      buffer[t3] = 32;
      t2.call$1(new J._CodeUnits(this._requestUri$0()));
      t3 = t1.offset_0++;
      if (t3 < 0 || t3 >= 8192)
        return H.ioore(buffer, t3);
      buffer[t3] = 32;
      t2.call$1(C.List_2Vk);
      t2 = t1.offset_0;
      offset = t2 + 1;
      t1.offset_0 = offset;
      if (t2 < 0 || t2 >= 8192)
        return H.ioore(buffer, t2);
      buffer[t2] = 13;
      t1.offset_0 = offset + 1;
      if (offset < 0 || offset >= 8192)
        return H.ioore(buffer, offset);
      buffer[offset] = 10;
      t2 = this.headers;
      t2._mutable = false;
      offset = t2._write$2(buffer, t1.offset_0);
      t1.offset_0 = offset;
      offset0 = offset + 1;
      t1.offset_0 = offset0;
      if (offset < 0 || offset >= 8192)
        return H.ioore(buffer, offset);
      buffer[offset] = 13;
      offset = offset0 + 1;
      t1.offset_0 = offset;
      if (offset0 < 0 || offset0 >= 8192)
        return H.ioore(buffer, offset0);
      buffer[offset0] = 10;
      this._outgoing.setHeader$2(buffer, offset);
    },
    _HttpClientRequest$6: function(outgoing, uri, method, _proxy, _httpClient, _httpClientConnection) {
      var t1, t2;
      t1 = this.method;
      t1 = t1 === "GET" || t1 === "HEAD";
      t2 = this.headers;
      if (t1)
        t2.set$contentLength(0);
      else
        t2.set$chunkedTransferEncoding(true);
    },
    $as_HttpOutboundMessage: function() {
      return [P.HttpClientResponse];
    },
    $as_StreamSinkImpl: function() {
      return [[P.List, P.$int]];
    }
  },
  _HttpClientRequest_done_closure: {
    "^": "Closure:58;",
    call$1: [function(list) {
      return J.$index$asx(list, 0);
    }, "call$1", null, 2, 0, null, 111, "call"],
    $isFunction: true
  },
  _HttpClientRequest__onIncoming_closure: {
    "^": "Closure:58;response_0",
    call$1: [function(_) {
      return this.response_0.redirect$0();
    }, "call$1", null, 2, 0, null, 60, "call"],
    $isFunction: true
  },
  _HttpClientRequest__onIncoming_closure0: {
    "^": "Closure:58;response_1",
    call$1: [function(_) {
      return P._Future$immediateError(new P.RedirectException("Redirect limit exceeded", this.response_1._httpRequest._responseRedirects), null, null);
    }, "call$1", null, 2, 0, null, 60, "call"],
    $isFunction: true
  },
  _HttpClientRequest__onIncoming_closure1: {
    "^": "Closure:58;this_2",
    call$1: [function(v) {
      var t1 = this.this_2._responseCompleter.future;
      if (t1._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      t1._asyncComplete$1(v);
      return;
    }, "call$1", null, 2, 0, null, 112, "call"],
    $isFunction: true
  },
  _HttpClientRequest__requestUri_uriStartingFromPath: {
    "^": "Closure:99;this_0",
    call$0: function() {
      var t1, result, t2, t3, t4, t5;
      t1 = this.this_0.uri;
      result = t1._path;
      if (result.length === 0)
        result = "/";
      t2 = t1._query;
      t3 = t2 == null;
      if ((t3 ? "" : t2) !== "") {
        t1 = t1._fragment;
        t4 = t1 == null;
        if ((t4 ? "" : t1) !== "") {
          t5 = result + "?";
          t2 = t5 + H.S(t3 ? "" : t2) + "#";
          result = t2 + H.S(t4 ? "" : t1);
        } else {
          t1 = result + "?";
          result = t1 + H.S(t3 ? "" : t2);
        }
      }
      return result;
    },
    $isFunction: true
  },
  _HttpClientRequest__writeHeader_write: {
    "^": "Closure:83;box_0,buffer_1",
    call$1: function(bytes) {
      var t1, len, t2, t3, i, t4, t5;
      t1 = J.getInterceptor$asx(bytes);
      len = t1.get$length(bytes);
      for (t2 = this.buffer_1, t3 = this.box_0, i = 0; i < len; ++i) {
        t4 = t3.offset_0 + i;
        t5 = t1.$index(bytes, i);
        if (t4 < 0 || t4 >= 8192)
          return H.ioore(t2, t4);
        t2[t4] = t5;
      }
      t3.offset_0 += len;
    },
    $isFunction: true
  },
  _HttpGZipSink: {
    "^": "ByteConversionSink;_consume",
    _consume$1: function(arg0) {
      return this._consume.call$1(arg0);
    },
    add$1: [function(_, chunk) {
      this._consume$1(chunk);
    }, "call$1", "get$add", 2, 0, 83],
    close$0: function() {
    }
  },
  _HttpOutgoing: {
    "^": "Object;_doneCompleter,socket,ignoreBody,headersWritten,_buffer,_io$_length,_closeFuture,chunked,_pendingChunkedFooter,contentLength?,_bytesWritten,_gzip,_gzipSink,_gzipAdd,_gzipBuffer,_gzipBufferLength,_socketError,outbound",
    writeHeaders$2$drainRequest$setOutgoing: function(drainRequest, setOutgoing) {
      var t1, t2, acceptEncodings, contentEncoding, gzip, drainFuture, contentLength;
      t1 = new P._HttpOutgoing_writeHeaders_write(this);
      if (this.headersWritten)
        return;
      this.headersWritten = true;
      t2 = this.outbound;
      if (!!J.getInterceptor(t2).$is_HttpResponse) {
        if (t2._bufferOutput && t2.headers._chunkedTransferEncoding) {
          acceptEncodings = t2.get$_httpRequest()._incoming.get$headers()._headers.$index(0, C.JSString_methods.toLowerCase$0("accept-encoding"));
          contentEncoding = this.outbound.headers._headers.$index(0, C.JSString_methods.toLowerCase$0("content-encoding"));
          if (acceptEncodings != null && J.expand$1$ax(acceptEncodings, new P._HttpOutgoing_writeHeaders_closure()).any$1(0, new P._HttpOutgoing_writeHeaders_closure0()) === true && contentEncoding == null) {
            this.outbound.headers.set$2("content-encoding", "gzip");
            gzip = true;
          } else
            gzip = false;
        } else
          gzip = false;
        drainFuture = drainRequest && !t2.get$_httpRequest()._incoming.get$hasSubscriber() ? t2.get$_httpRequest().listen$2$cancelOnError(null, true).asFuture$1(null).catchError$1(new P._HttpOutgoing_writeHeaders_closure1()) : null;
      } else {
        drainFuture = null;
        gzip = false;
      }
      if (this.ignoreBody)
        return t1.call$0();
      if (setOutgoing) {
        t2 = this.outbound.headers;
        contentLength = t2._contentLength;
        if (t2._chunkedTransferEncoding) {
          this.chunked = true;
          if (gzip)
            this.set$gzip(true);
        } else if (J.$ge$n(contentLength, 0))
          this.contentLength = contentLength;
      }
      if (drainFuture != null)
        return drainFuture.then$1(new P._HttpOutgoing_writeHeaders_closure2(t1));
      return t1.call$0();
    },
    writeHeaders$0: function() {
      return this.writeHeaders$2$drainRequest$setOutgoing(true, true);
    },
    addStream$1: function(stream) {
      var t1, future, controller, t2;
      t1 = {};
      if (this._socketError) {
        stream.listen$1(null).cancel$0();
        return P._Future$immediate(this.outbound, null);
      }
      if (this.ignoreBody) {
        stream.listen$2$cancelOnError(null, true).asFuture$1(null).catchError$1(new P._HttpOutgoing_addStream_closure());
        future = this.writeHeaders$0();
        if (future != null)
          return future.then$1(new P._HttpOutgoing_addStream_closure0(this));
        return this.close$0();
      }
      t1.sub_0 = null;
      controller = P.StreamController_StreamController(null, null, new P._HttpOutgoing_addStream_closure1(t1), new P._HttpOutgoing_addStream_closure2(t1), true, null);
      t2 = controller.get$addError();
      t1.sub_0 = stream.listen$4$cancelOnError$onDone$onError(new P._HttpOutgoing_addStream_onData(this, controller), true, controller.get$close(), t2);
      if (!this.headersWritten) {
        future = this.writeHeaders$0();
        if (future != null)
          t1.sub_0.pause$1(future);
      }
      return this.socket.addStream$1(H.setRuntimeTypeInfo(new P._ControllerStream(controller), [null])).then$2$onError(new P._HttpOutgoing_addStream_closure3(this), new P._HttpOutgoing_addStream_closure4(this));
    },
    close$0: function() {
      var t1, error, t2, future;
      t1 = this._closeFuture;
      if (t1 != null)
        return t1;
      if (this._socketError)
        return P._Future$immediate(this.outbound, null);
      if (this.outbound.get$_isConnectionClosed())
        return P._Future$immediate(this.outbound, null);
      if (!this.headersWritten && !this.ignoreBody)
        if (J.$eq(this.outbound.headers._contentLength, -1)) {
          this.outbound.headers.set$chunkedTransferEncoding(false);
          this.outbound.headers.set$contentLength(0);
        } else if (J.$gt$n(this.outbound.headers._contentLength, 0)) {
          error = new P.HttpException("No content even though contentLength was specified to be greater than 0: " + H.S(this.outbound.headers._contentLength) + ".", this.outbound._uri);
          this._doneCompleter.completeError$1(error);
          t1 = P._Future$immediateError(error, null, null);
          this._closeFuture = t1;
          return t1;
        }
      t1 = this.contentLength;
      if (t1 != null) {
        t2 = this._bytesWritten;
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (t2 < t1) {
          error = new P.HttpException("Content size below specified contentLength.  " + H.S(t2) + " bytes written but expected " + H.S(this.contentLength) + ".", this.outbound._uri);
          this._doneCompleter.completeError$1(error);
          t1 = P._Future$immediateError(error, null, null);
          this._closeFuture = t1;
          return t1;
        }
      }
      t1 = new P._HttpOutgoing_close_finalize(this);
      future = this.writeHeaders$0();
      if (future != null) {
        t1 = future.whenComplete$1(t1);
        this._closeFuture = t1;
        return t1;
      }
      t1 = t1.call$0();
      this._closeFuture = t1;
      return t1;
    },
    setHeader$2: function(data, $length) {
      this._buffer = data;
      this._io$_length = $length;
    },
    set$gzip: function(value) {
      this._gzip = value;
      if (value) {
        this._gzipBuffer = new Uint8Array(8192);
        P._validateZLibeLevel(6);
        P._validateZLibMemLevel(8);
        P._validateZLibStrategy(0);
        P._validateZLibWindowBits(15);
        this._gzipSink = new P.ZLibEncoder(true, 6, 8, 0, 15, null, false).startChunkedConversion$1(new P._HttpGZipSink(new P._HttpOutgoing_gzip_closure(this)));
      }
    },
    _ignoreError$1: function(error) {
      var t1 = J.getInterceptor(error);
      return (!!t1.$isSocketException || !!t1.$isTlsException) && !!J.getInterceptor(this.outbound).$isHttpResponse;
    },
    _addGZipChunk$2: function(chunk, add) {
      var t1, t2, t3, t4;
      if (!this.outbound._bufferOutput) {
        add.call$1(chunk);
        return;
      }
      t1 = J.getInterceptor$asx(chunk);
      t2 = t1.get$length(chunk);
      this._gzipBuffer.length;
      if (J.$gt$n(t2, 8192 - this._gzipBufferLength)) {
        add.call$1(J.asUint8List$2$x(this._gzipBuffer.buffer, 0, this._gzipBufferLength));
        this._gzipBuffer = new Uint8Array(8192);
        this._gzipBufferLength = 0;
      }
      if (J.$gt$n(t1.get$length(chunk), 8192))
        add.call$1(chunk);
      else {
        t2 = this._gzipBuffer;
        t3 = this._gzipBufferLength;
        t4 = t1.get$length(chunk);
        if (typeof t4 !== "number")
          return H.iae(t4);
        J.setRange$3$ax(t2, t3, t3 + t4, chunk);
        t4 = this._gzipBufferLength;
        t1 = t1.get$length(chunk);
        if (typeof t1 !== "number")
          return H.iae(t1);
        this._gzipBufferLength = t4 + t1;
      }
    },
    _addChunk$2: function(chunk, add) {
      var t1, t2, t3, t4;
      if (!this.outbound._bufferOutput) {
        t1 = this._buffer;
        if (t1 != null) {
          add.call$1(J.asUint8List$2$x(t1.buffer, 0, this._io$_length));
          this._buffer = null;
          this._io$_length = 0;
        }
        add.call$1(chunk);
        return;
      }
      t1 = J.getInterceptor$asx(chunk);
      t2 = t1.get$length(chunk);
      this._buffer.length;
      if (J.$gt$n(t2, 8192 - this._io$_length)) {
        add.call$1(J.asUint8List$2$x(this._buffer.buffer, 0, this._io$_length));
        this._buffer = new Uint8Array(8192);
        this._io$_length = 0;
      }
      if (J.$gt$n(t1.get$length(chunk), 8192))
        add.call$1(chunk);
      else {
        t2 = this._buffer;
        t3 = this._io$_length;
        t4 = t1.get$length(chunk);
        if (typeof t4 !== "number")
          return H.iae(t4);
        J.setRange$3$ax(t2, t3, t3 + t4, chunk);
        t4 = this._io$_length;
        t1 = t1.get$length(chunk);
        if (typeof t1 !== "number")
          return H.iae(t1);
        this._io$_length = t4 + t1;
      }
    },
    _chunkHeader$1: function($length) {
      var size, len, t1, footerAndHeader, index, t2, t3;
      if ($length === 0) {
        if (this._pendingChunkedFooter === 2)
          return C.List_E7y0;
        return C.List_yTu;
      }
      size = this._pendingChunkedFooter;
      for (len = $length; t1 = J.getInterceptor$n(len), t1.$gt(len, 0);) {
        ++size;
        len = t1.$shr(len, 4);
      }
      t1 = size + 2;
      footerAndHeader = new Uint8Array(t1);
      if (this._pendingChunkedFooter === 2) {
        footerAndHeader[0] = 13;
        footerAndHeader[1] = 10;
      }
      for (index = size; index > this._pendingChunkedFooter;) {
        --index;
        t2 = J.getInterceptor$n($length);
        t3 = t2.$and($length, 15);
        if (t3 >= 16)
          return H.ioore(C.List_cGl, t3);
        t3 = C.List_cGl[t3];
        if (index >= t1)
          return H.ioore(footerAndHeader, index);
        footerAndHeader[index] = t3;
        $length = t2.$shr($length, 4);
      }
      if (size >= t1)
        return H.ioore(footerAndHeader, size);
      footerAndHeader[size] = 13;
      t2 = size + 1;
      if (t2 >= t1)
        return H.ioore(footerAndHeader, t2);
      footerAndHeader[t2] = 10;
      return footerAndHeader;
    },
    static: {"^": "_HttpOutgoing__footerAndChunk0Length,_HttpOutgoing__chunk0Length"}
  },
  _HttpOutgoing_writeHeaders_write: {
    "^": "Closure:73;this_0",
    call$0: function() {
      var exception;
      try {
        this.this_0.outbound._writeHeader$0();
      } catch (exception) {
        H.unwrapException(exception);
        return P._Future$immediateError(new P.HttpException("Headers size exceeded the of '8192' bytes", null), null, null);
      }

    },
    $isFunction: true
  },
  _HttpOutgoing_writeHeaders_closure: {
    "^": "Closure:58;",
    call$1: [function(list) {
      return J.split$1$s(list, ",");
    }, "call$1", null, 2, 0, null, 111, "call"],
    $isFunction: true
  },
  _HttpOutgoing_writeHeaders_closure0: {
    "^": "Closure:58;",
    call$1: function(encoding) {
      return J.trim$0$s(encoding).toLowerCase() === "gzip";
    },
    $isFunction: true
  },
  _HttpOutgoing_writeHeaders_closure1: {
    "^": "Closure:58;",
    call$1: [function(_) {
    }, "call$1", null, 2, 0, null, 60, "call"],
    $isFunction: true
  },
  _HttpOutgoing_writeHeaders_closure2: {
    "^": "Closure:58;write_1",
    call$1: [function(_) {
      return this.write_1.call$0();
    }, "call$1", null, 2, 0, null, 60, "call"],
    $isFunction: true
  },
  _HttpOutgoing_addStream_closure: {
    "^": "Closure:58;",
    call$1: [function(_) {
    }, "call$1", null, 2, 0, null, 60, "call"],
    $isFunction: true
  },
  _HttpOutgoing_addStream_closure0: {
    "^": "Closure:58;this_1",
    call$1: [function(_) {
      return this.this_1.close$0();
    }, "call$1", null, 2, 0, null, 60, "call"],
    $isFunction: true
  },
  _HttpOutgoing_addStream_closure1: {
    "^": "Closure:55;box_0",
    call$0: function() {
      return this.box_0.sub_0.pause$0();
    },
    $isFunction: true
  },
  _HttpOutgoing_addStream_closure2: {
    "^": "Closure:55;box_0",
    call$0: function() {
      return this.box_0.sub_0.resume$0();
    },
    $isFunction: true
  },
  _HttpOutgoing_addStream_onData: {
    "^": "Closure:13;this_2,controller_3",
    call$1: [function(data) {
      var t1, t2, t3;
      t1 = this.this_2;
      if (t1._socketError)
        return;
      t2 = J.getInterceptor$asx(data);
      if (t2.get$length(data) === 0)
        return;
      if (t1.chunked) {
        if (t1._gzip) {
          t2 = this.controller_3;
          t1._gzipAdd = t2.get$add(t2);
          t2 = t1._gzipSink;
          t1._addGZipChunk$2(data, t2.get$add(t2));
          t1._gzipAdd = null;
          return;
        }
        t3 = this.controller_3;
        t1._addChunk$2(t1._chunkHeader$1(t2.get$length(data)), t3.get$add(t3));
        t1._pendingChunkedFooter = 2;
      } else if (t1.contentLength != null) {
        t3 = t1._bytesWritten;
        t2 = t2.get$length(data);
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = t3 + t2;
        t1._bytesWritten = t2;
        t3 = t1.contentLength;
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (t2 > t3) {
          t3 = this.controller_3;
          t1 = "Content size exceeds specified contentLength. " + H.S(t2) + " bytes written while expected " + H.S(t1.contentLength) + ". [" + P.String_String$fromCharCodes(data) + "]";
          if (t3._state >= 4)
            H.throwExpression(t3._badEventState$0());
          t3._addError$2(new P.HttpException(t1, null), null);
          return;
        }
      }
      t2 = this.controller_3;
      t1._addChunk$2(data, t2.get$add(t2));
    }, "call$1", null, 2, 0, null, 72, "call"],
    $isFunction: true
  },
  _HttpOutgoing_addStream_closure3: {
    "^": "Closure:58;this_4",
    call$1: [function(_) {
      return this.this_4.outbound;
    }, "call$1", null, 2, 0, null, 60, "call"],
    $isFunction: true
  },
  _HttpOutgoing_addStream_closure4: {
    "^": "Closure:58;this_5",
    call$1: [function(error) {
      var t1 = this.this_5;
      if (t1._gzip)
        t1._gzipSink.close$0();
      t1._socketError = true;
      t1._doneCompleter.completeError$1(error);
      if (t1._ignoreError$1(error))
        return t1.outbound;
      else
        throw H.wrapException(error);
    }, "call$1", null, 2, 0, null, 17, "call"],
    $isFunction: true
  },
  _HttpOutgoing_close_finalize: {
    "^": "Closure:73;this_0",
    call$0: [function() {
      var t1, t2, t3;
      t1 = this.this_0;
      if (t1.chunked) {
        if (t1._gzip) {
          t1._gzipAdd = J.get$add$ax(t1.socket);
          t2 = t1._gzipBufferLength;
          if (t2 > 0) {
            t3 = t1._gzipSink;
            t2 = J.asUint8List$2$x(t1._gzipBuffer.buffer, 0, t2);
            t3.addSlice$4(t2, 0, t2.length, false);
          }
          t1._gzipBuffer = null;
          t1._gzipSink.close$0();
          t1._gzipAdd = null;
        }
        t1._addChunk$2(t1._chunkHeader$1(0), J.get$add$ax(t1.socket));
      }
      t2 = t1._io$_length;
      if (t2 > 0)
        J.add$1$ax(t1.socket, J.asUint8List$2$x(t1._buffer.buffer, 0, t2));
      t1._buffer = null;
      return t1.socket.flush$0().then$2$onError(new P._HttpOutgoing_close_finalize_closure(t1), new P._HttpOutgoing_close_finalize_closure0(t1));
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _HttpOutgoing_close_finalize_closure: {
    "^": "Closure:58;this_1",
    call$1: [function(_) {
      var t1, t2;
      t1 = this.this_1;
      t2 = t1._doneCompleter.future;
      if (t2._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      t2._asyncComplete$1(t1.socket);
      return t1.outbound;
    }, "call$1", null, 2, 0, null, 60, "call"],
    $isFunction: true
  },
  _HttpOutgoing_close_finalize_closure0: {
    "^": "Closure:58;this_2",
    call$1: [function(error) {
      var t1 = this.this_2;
      t1._doneCompleter.completeError$1(error);
      if (t1._ignoreError$1(error))
        return t1.outbound;
      else
        throw H.wrapException(error);
    }, "call$1", null, 2, 0, null, 17, "call"],
    $isFunction: true
  },
  _HttpOutgoing_gzip_closure: {
    "^": "Closure:58;this_0",
    call$1: function(data) {
      var t1 = this.this_0;
      if (t1._gzipAdd == null)
        return;
      t1._addChunk$2(t1._chunkHeader$1(J.get$length$asx(data)), t1._gzipAdd);
      t1._pendingChunkedFooter = 2;
      t1._addChunk$2(data, t1._gzipAdd);
    },
    $isFunction: true
  },
  _HttpClientConnection: {
    "^": "Object;key,_socket,_proxyTunnel,_httpParser,_subscription,_httpClient,_dispose,_idleTimer,closed<,_currentUri,_nextResponseCompleter,_streamFuture",
    send$4: function(uri, port, method, proxy) {
      var t1, t2, outgoing, t3, t4, t5, t6, t7, request, proxyCreds, creds;
      t1 = {};
      if (this.closed)
        throw H.wrapException(P.HttpException$("Socket closed before request was sent", uri));
      this._currentUri = uri;
      this._subscription.pause$0();
      t1.proxyCreds_0 = null;
      t1.creds_1 = null;
      t2 = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(null)), [null]);
      outgoing = new P._HttpOutgoing(t2, this._socket, false, false, null, 0, null, false, 0, null, 0, false, null, null, null, 0, false, null);
      t3 = this._httpClient;
      t4 = H.setRuntimeTypeInfo([], [P.Cookie]);
      t5 = P.HttpClientResponse;
      t5 = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(t5)), [t5]);
      t6 = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(null)), [null]);
      t7 = P._HttpHeaders$("1.1", uri.scheme === "https" ? 443 : 80, null);
      request = new P._HttpClientRequest(method, uri, t4, t3, this, t5, proxy, null, true, 5, [], false, true, uri, outgoing, t7, null, true, outgoing, t6, null, null, null, false, false, false);
      request._io$_doneFuture = t6.future;
      request._HttpOutboundMessage$4$initialHeaders(uri, "1.1", outgoing, null, P.HttpClientResponse);
      request._HttpClientRequest$6(outgoing, uri, method, proxy, t3, this);
      t6 = uri.get$host();
      if (!t7._mutable)
        H.throwExpression(P.HttpException$("HTTP headers are not mutable", null));
      t7._io$_host = t6;
      t7._updateHostHeader$0();
      if (!t7._mutable)
        H.throwExpression(P.HttpException$("HTTP headers are not mutable", null));
      t7._io$_port = port;
      t7._updateHostHeader$0();
      t7._io$_add$2("accept-encoding", "gzip");
      t7._io$_add$2("user-agent", t3.userAgent);
      if (proxy.get$isAuthenticated()) {
        t4 = H.S(proxy.get$username()) + ":" + H.S(proxy.get$password());
        t7.set$2("proxy-authorization", "Basic " + P._CryptoUtils_bytesToBase64(C.Utf8Codec_false.get$encoder().convert$1(t4), false, false));
      } else if (!proxy.get$isDirect() && t3._proxyCredentials.length > 0) {
        proxyCreds = t3._findProxyCredentials$1(proxy);
        t1.proxyCreds_0 = proxyCreds;
        if (proxyCreds != null)
          proxyCreds.authorize$1(request);
      }
      if (uri._userInfo.length !== 0)
        t7.set$2("authorization", "Basic " + P._CryptoUtils_bytesToBase64(C.Utf8Codec_false.get$encoder().convert$1(uri._userInfo), false, false));
      else {
        creds = t3._findCredentials$1(uri);
        t1.creds_1 = creds;
        if (creds != null)
          creds.authorize$1(request);
      }
      if (method === "HEAD")
        this._httpParser._noMessageBody = true;
      this._streamFuture = t2.future.then$2$onError(new P._HttpClientConnection_send_closure(t1, this, uri, request), new P._HttpClientConnection_send_closure0(this));
      return request;
    },
    destroy$0: function() {
      this.closed = true;
      this._httpClient._connectionClosed$1(this);
      this._socket.destroy$0();
    },
    close$0: function() {
      this.closed = true;
      this._httpClient._connectionClosed$1(this);
      this._streamFuture.then$1(new P._HttpClientConnection_close_closure(this));
    },
    createProxyTunnel$4: function(host, port, proxy, callback) {
      var request, t1;
      request = this.send$4(P.Uri_Uri(null, host, null, null, port, null, null, "", ""), port, "CONNECT", proxy);
      if (proxy.get$isAuthenticated()) {
        t1 = H.S(proxy.get$username()) + ":" + H.S(proxy.get$password());
        request.headers.set$2("proxy-authorization", "Basic " + P._CryptoUtils_bytesToBase64(C.Utf8Codec_false.get$encoder().convert$1(t1), false, false));
      }
      P._StreamSinkImpl.prototype.close$0.call(request);
      return request.get$done().then$1(new P._HttpClientConnection_createProxyTunnel_closure(host, callback)).then$1(new P._HttpClientConnection_createProxyTunnel_closure0(host, port, request));
    },
    get$connectionInfo: function() {
      return P._HttpConnectionInfo_create(this._socket);
    },
    stopTimer$0: function() {
      var t1 = this._idleTimer;
      if (t1 != null) {
        t1.cancel$0();
        this._idleTimer = null;
      }
    },
    startTimer$0: function() {
      this._idleTimer = P.Timer_Timer(this._httpClient._idleTimeout, new P._HttpClientConnection_startTimer_closure(this));
    },
    _HttpClientConnection$4: function(key, _socket, _httpClient, _proxyTunnel) {
      var t1, t2, t3;
      t1 = this._httpParser;
      t2 = t1.get$_io$_onData();
      t3 = t1.get$_io$_onError();
      t1._socketSubscription = this._socket.listen$3$onDone$onError(t2, t1.get$_io$_onDone(), t3);
      this._subscription = H.setRuntimeTypeInfo(new P._ControllerStream(t1._controller), [null]).listen$4$cancelOnError$onDone$onError(new P._HttpClientConnection_closure(this), null, new P._HttpClientConnection_closure0(this), new P._HttpClientConnection_closure1(this));
    },
    static: {_HttpClientConnection$: function(key, _socket, _httpClient, _proxyTunnel) {
        var t1 = new P._HttpClientConnection(key, _socket, _proxyTunnel, P._HttpParser$_(false), null, _httpClient, false, null, false, null, null, null);
        t1._HttpClientConnection$4(key, _socket, _httpClient, _proxyTunnel);
        return t1;
      }}
  },
  _HttpClientConnection_closure: {
    "^": "Closure:58;this_0",
    call$1: [function(incoming) {
      var t1, t2;
      t1 = this.this_0;
      t1._subscription.pause$0();
      t2 = t1._nextResponseCompleter;
      if (t2 == null)
        throw H.wrapException(P.HttpException$("Unexpected response (unsolicited response without request).", t1._currentUri));
      t2 = t2.future;
      if (t2._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      t2._asyncComplete$1(incoming);
      t1._nextResponseCompleter = null;
    }, "call$1", null, 2, 0, null, 113, "call"],
    $isFunction: true
  },
  _HttpClientConnection_closure1: {
    "^": "Closure:114;this_1",
    call$2: [function(error, stackTrace) {
      var t1, t2;
      t1 = this.this_1;
      t2 = t1._nextResponseCompleter;
      if (t2 != null) {
        t2.completeError$2(new P.HttpException(error.get$message(), t1._currentUri), stackTrace);
        t1._nextResponseCompleter = null;
      }
    }, function(error) {
      return this.call$2(error, null);
    }, "call$1", "call$2", null, null, 2, 2, null, 16, 17, 18, "call"],
    $isFunction: true
  },
  _HttpClientConnection_closure0: {
    "^": "Closure:55;this_2",
    call$0: [function() {
      var t1, t2;
      t1 = this.this_2;
      t2 = t1._nextResponseCompleter;
      if (t2 != null) {
        t2.completeError$1(new P.HttpException("Connection closed before response was received", t1._currentUri));
        t1._nextResponseCompleter = null;
      }
      t1.close$0();
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _HttpClientConnection_send_closure: {
    "^": "Closure:58;box_0,this_1,uri_2,request_3",
    call$1: [function(s) {
      var t1, t2, t3;
      t1 = this.this_1;
      t2 = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(null)), [null]);
      t1._nextResponseCompleter = t2;
      t3 = this.request_3;
      t2.future.then$1(new P._HttpClientConnection_send__closure(this.box_0, t1, t3)).catchError$2$test(new P._HttpClientConnection_send__closure0(this.uri_2), new P._HttpClientConnection_send__closure1()).catchError$1(new P._HttpClientConnection_send__closure2(t1, t3));
      t1._subscription.resume$0();
      return s;
    }, "call$1", null, 2, 0, null, 75, "call"],
    $isFunction: true
  },
  _HttpClientConnection_send__closure: {
    "^": "Closure:58;box_0,this_4,request_5",
    call$1: [function(incoming) {
      var t1, t2, t3;
      t1 = this.this_4;
      t1._currentUri = null;
      t2 = this.request_5;
      incoming.get$dataDone().then$1(new P._HttpClientConnection_send___closure(t1, t2, incoming));
      t1 = this.box_0;
      t3 = t1.proxyCreds_0;
      if (t3 != null)
        t3.get$scheme();
      t1 = t1.creds_1;
      if (t1 != null)
        t1.get$scheme();
      t2._onIncoming$1(incoming);
    }, "call$1", null, 2, 0, null, 113, "call"],
    $isFunction: true
  },
  _HttpClientConnection_send___closure: {
    "^": "Closure:58;this_6,request_7,incoming_8",
    call$1: [function(closing) {
      var t1, t2;
      t1 = this.incoming_8;
      if (t1.get$upgraded()) {
        t1 = this.this_6;
        t1._httpClient._connectionClosed$1(t1);
        t1.startTimer$0();
        return;
      }
      t2 = this.this_6;
      if (t2.closed)
        return;
      if (closing !== true && !t2._dispose && t1.get$headers()._persistentConnection && this.request_7.headers._persistentConnection) {
        t1 = t2._httpClient;
        t1._connectionTargets.$index(0, t2.key).returnConnection$1(t2);
        t1._updateTimers$0();
        t2._subscription.resume$0();
      } else
        t2.destroy$0();
    }, "call$1", null, 2, 0, null, 115, "call"],
    $isFunction: true
  },
  _HttpClientConnection_send__closure0: {
    "^": "Closure:58;uri_9",
    call$1: [function(error) {
      throw H.wrapException(P.HttpException$("Connection closed before data was received", this.uri_9));
    }, "call$1", null, 2, 0, null, 17, "call"],
    $isFunction: true
  },
  _HttpClientConnection_send__closure1: {
    "^": "Closure:58;",
    call$1: [function(error) {
      return !!J.getInterceptor(error).$isStateError;
    }, "call$1", null, 2, 0, null, 17, "call"],
    $isFunction: true
  },
  _HttpClientConnection_send__closure2: {
    "^": "Closure:56;this_10,request_11",
    call$2: [function(error, stackTrace) {
      this.this_10.destroy$0();
      this.request_11._responseCompleter.completeError$2(error, stackTrace);
    }, "call$2", null, 4, 0, null, 17, 18, "call"],
    $isFunction: true
  },
  _HttpClientConnection_send_closure0: {
    "^": "Closure:58;this_12",
    call$1: [function(e) {
      this.this_12.destroy$0();
    }, "call$1", null, 2, 0, null, 2, "call"],
    $isFunction: true
  },
  _HttpClientConnection_close_closure: {
    "^": "Closure:58;this_0",
    call$1: [function(_) {
      return this.this_0._socket.destroy$0();
    }, "call$1", null, 2, 0, null, 60, "call"],
    $isFunction: true
  },
  _HttpClientConnection_createProxyTunnel_closure: {
    "^": "Closure:58;host_0,callback_1",
    call$1: [function(response) {
      if (response.get$statusCode() !== 200)
        throw H.wrapException("Proxy failed to establish tunnel (" + H.S(response.get$statusCode()) + " " + H.S(response.get$reasonPhrase()) + ")");
      return P.SecureSocket_secure(response.get$_httpRequest().get$_httpClientConnection()._socket, null, this.host_0, this.callback_1, false);
    }, "call$1", null, 2, 0, null, 116, "call"],
    $isFunction: true
  },
  _HttpClientConnection_createProxyTunnel_closure0: {
    "^": "Closure:58;host_2,port_3,request_4",
    call$1: [function(secureSocket) {
      var key = "ssh:" + H.S(this.host_2) + ":" + H.S(this.port_3);
      return P._HttpClientConnection$(key, secureSocket, this.request_4._httpClient, true);
    }, "call$1", null, 2, 0, null, 117, "call"],
    $isFunction: true
  },
  _HttpClientConnection_startTimer_closure: {
    "^": "Closure:55;this_0",
    call$0: [function() {
      var t1 = this.this_0;
      t1._idleTimer = null;
      t1.close$0();
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _ConnectionInfo: {
    "^": "Object;connection<,proxy<"
  },
  _ConnectionTarget: {
    "^": "Object;key,host<,port<,isSecure,_idle,_active,_io$_pending,_connecting",
    get$isEmpty: function(_) {
      return this._idle._collection$_length === 0 && this._active._collection$_length === 0 && this._connecting === 0;
    },
    get$hasIdle: function() {
      return this._idle._collection$_length !== 0;
    },
    get$hasActive: function() {
      return this._active._collection$_length !== 0 || this._connecting > 0;
    },
    addNewActive$1: function(connection) {
      this._active.add$1(0, connection);
    },
    returnConnection$1: function(connection) {
      var t1;
      this._active.remove$1(0, connection);
      this._idle.add$1(0, connection);
      connection.startTimer$0();
      t1 = this._io$_pending;
      if (!t1.get$isEmpty(t1))
        t1.removeFirst$0().call$0();
    },
    connectionClosed$1: function(connection) {
      var t1;
      this._active.remove$1(0, connection);
      this._idle.remove$1(0, connection);
      t1 = this._io$_pending;
      if (!t1.get$isEmpty(t1))
        t1.removeFirst$0().call$0();
    },
    close$1: function(force) {
      var t1;
      for (t1 = this._idle.toList$0(0), t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
        t1._current.close$0();
      if (force)
        for (t1 = this._active.toList$0(0), t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
          t1._current.destroy$0();
    },
    connect$4: function(uriHost, uriPort, proxy, client) {
      var t1, connection, t2, t3, t4, socketFuture;
      t1 = this._idle;
      if (t1._collection$_length !== 0) {
        connection = t1.get$first(t1);
        t1.remove$1(0, connection);
        connection.stopTimer$0();
        this._active.add$1(0, connection);
        client._updateTimers$0();
        return P._Future$immediate(new P._ConnectionInfo(connection, proxy), null);
      }
      t1 = new P._ConnectionTarget_connect_callback(uriHost, uriPort, client._badCertificateCallback);
      t2 = this.isSecure && proxy.get$isDirect();
      t3 = this.host;
      t4 = this.port;
      socketFuture = t2 ? P.SecureSocket_connect(t3, t4, null, t1, true) : P.Socket_connect(t3, t4);
      ++this._connecting;
      return socketFuture.then$2$onError(new P._ConnectionTarget_connect_closure(this, uriHost, uriPort, proxy, client, t1), new P._ConnectionTarget_connect_closure0(this));
    }
  },
  _ConnectionTarget_connect_closure1: {
    "^": "Closure:55;this_0,uriHost_1,uriPort_2,proxy_3,client_4,completer_5",
    call$0: [function() {
      var t1 = this.completer_5;
      this.this_0.connect$4(this.uriHost_1, this.uriPort_2, this.proxy_3, this.client_4).then$2$onError(t1.get$complete(), t1.get$completeError());
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _ConnectionTarget_connect_callback: {
    "^": "Closure:119;uriHost_6,uriPort_7,currentBadCertificateCallback_8",
    call$1: [function(certificate) {
      return false;
    }, "call$1", null, 2, 0, null, 118, "call"],
    $isFunction: true
  },
  _ConnectionTarget_connect_closure: {
    "^": "Closure:58;this_9,uriHost_10,uriPort_11,proxy_12,client_13,callback_14",
    call$1: function(socket) {
      var t1, t2, connection, t3, t4;
      t1 = this.this_9;
      --t1._connecting;
      socket.setOption$2(C.SocketOption_0, true);
      t2 = this.client_13;
      connection = P._HttpClientConnection$(t1.key, socket, t2, false);
      t3 = t1.isSecure && !this.proxy_12.get$isDirect();
      t4 = this.proxy_12;
      if (t3) {
        connection._dispose = true;
        t1 = this.uriHost_10;
        t3 = this.uriPort_11;
        return connection.createProxyTunnel$4(t1, t3, t4, this.callback_14).then$1(new P._ConnectionTarget_connect__closure(t1, t3, t4, t2));
      } else {
        t1._active.add$1(0, connection);
        return new P._ConnectionInfo(connection, t4);
      }
    },
    $isFunction: true
  },
  _ConnectionTarget_connect__closure: {
    "^": "Closure:58;uriHost_15,uriPort_16,proxy_17,client_18",
    call$1: [function(tunnel) {
      this.client_18._getConnectionTarget$3(this.uriHost_15, this.uriPort_16, true).addNewActive$1(tunnel);
      return new P._ConnectionInfo(tunnel, this.proxy_17);
    }, "call$1", null, 2, 0, null, 120, "call"],
    $isFunction: true
  },
  _ConnectionTarget_connect_closure0: {
    "^": "Closure:58;this_19",
    call$1: function(error) {
      var t1 = this.this_19;
      --t1._connecting;
      t1 = t1._io$_pending;
      if (!t1.get$isEmpty(t1))
        t1.removeFirst$0().call$0();
      throw H.wrapException(error);
    },
    $isFunction: true
  },
  _HttpClient: {
    "^": "Object;_closing,_connectionTargets,_credentials,_proxyCredentials,_authenticate,_authenticateProxy,_findProxy,_idleTimeout,_badCertificateCallback,_noActiveTimer,maxConnectionsPerHost,autoUncompress,userAgent",
    _findProxy$1: function(arg0) {
      return this._findProxy.call$1(arg0);
    },
    close$1$force: function(force) {
      var t1;
      this._closing = true;
      t1 = this._connectionTargets.get$values();
      H.IterableMixinWorkaround_forEach(P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "IterableBase", 0)), new P._HttpClient_close_closure(force));
    },
    close$0: function() {
      return this.close$1$force(false);
    },
    _openUrl$2: function(method, uri) {
      var t1, error, stackTrace, isSecure, port, exception;
      t1 = {};
      if (method == null)
        throw H.wrapException(P.ArgumentError$(method));
      if (method !== "CONNECT")
        if (uri.get$host().length === 0)
          throw H.wrapException(P.ArgumentError$("No host specified in URI " + H.S(uri)));
        else if (uri.get$scheme() !== "http" && uri.get$scheme() !== "https")
          throw H.wrapException(P.ArgumentError$("Unsupported scheme '" + uri.get$scheme() + "' in URI " + H.S(uri)));
      isSecure = uri.get$scheme() === "https";
      port = uri.get$port();
      t1.port_0 = port;
      if (port === 0)
        t1.port_0 = isSecure ? 443 : 80;
      t1.proxyConf_1 = C._ProxyConfiguration_8Zd;
      try {
        t1.proxyConf_1 = P._ProxyConfiguration$(this._findProxy$1(uri));
      } catch (exception) {
        t1 = H.unwrapException(exception);
        error = t1;
        stackTrace = new H._StackTrace(exception, null);
        return P._Future$immediateError(error, stackTrace, null);
      }

      return this._getConnection$4(uri.get$host(), t1.port_0, t1.proxyConf_1, isSecure).then$1(new P._HttpClient__openUrl_closure(t1, this, method, uri, isSecure));
    },
    _openUrlFromRequest$3: function(method, uri, previous) {
      return this._openUrl$2(method, previous.uri.resolveUri$1(uri)).then$1(new P._HttpClient__openUrlFromRequest_closure(previous));
    },
    _connectionClosed$1: function(connection) {
      var t1, t2, connectionTarget;
      connection.stopTimer$0();
      t1 = this._connectionTargets;
      t2 = connection.key;
      connectionTarget = t1.$index(0, t2);
      if (connectionTarget != null) {
        connectionTarget.connectionClosed$1(connection);
        if (J.get$isEmpty$asx(connectionTarget) === true)
          t1.remove$1(0, t2);
        this._updateTimers$0();
      }
    },
    _updateTimers$0: function() {
      var t1 = this._connectionTargets;
      if (!t1.get$values().any$1(0, new P._HttpClient__updateTimers_closure())) {
        if (t1.get$values().any$1(0, new P._HttpClient__updateTimers_closure0()) && this._noActiveTimer == null)
          this._noActiveTimer = P.Timer_Timer(C.Duration_100000, new P._HttpClient__updateTimers_closure1(this));
      } else {
        t1 = this._noActiveTimer;
        if (t1 != null) {
          t1.cancel$0();
          this._noActiveTimer = null;
        }
      }
    },
    _getConnectionTarget$3: function(host, port, isSecure) {
      var key = isSecure ? "ssh:" + H.S(host) + ":" + H.S(port) : H.S(host) + ":" + H.S(port);
      return this._connectionTargets.putIfAbsent$2(key, new P._HttpClient__getConnectionTarget_closure(host, port, isSecure, key));
    },
    _getConnection$4: function(uriHost, uriPort, proxyConf, isSecure) {
      var t1 = proxyConf.proxies;
      return new P._HttpClient__getConnection_connect(this, uriHost, uriPort, isSecure, H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)])).call$1(new P.HttpException("No proxies given", null));
    },
    _findCredentials$2: function(url, scheme) {
      return H.IterableMixinWorkaround_fold(this._credentials, null, new P._HttpClient__findCredentials_closure(url, scheme));
    },
    _findCredentials$1: function(url) {
      return this._findCredentials$2(url, null);
    },
    _findProxyCredentials$2: function(proxy, scheme) {
      var t1, it;
      t1 = this._proxyCredentials;
      it = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]);
      for (; it.moveNext$0();)
        it._current.applies$2(proxy, scheme);
    },
    _findProxyCredentials$1: function(proxy) {
      return this._findProxyCredentials$2(proxy, null);
    },
    static: {"^": "_HttpClient__platformEnvironmentCache", _HttpClient__findProxyFromEnvironment: function(url, environment) {
        var t1, t2, noProxy, proxyCfg, t3, proxy;
        t1 = new P._HttpClient__findProxyFromEnvironment_checkProxy();
        t2 = $.get$_HttpClient__platformEnvironmentCache()._map;
        noProxy = t2.$index(0, "no_proxy");
        if (noProxy == null)
          noProxy = t2.$index(0, "NO_PROXY");
        proxyCfg = new P._HttpClient__findProxyFromEnvironment_checkNoProxy(url).call$1(noProxy);
        if (proxyCfg != null)
          return proxyCfg;
        t3 = url.scheme;
        if (t3 === "http") {
          proxy = t2.$index(0, "http_proxy");
          proxyCfg = t1.call$1(proxy == null ? t2.$index(0, "HTTP_PROXY") : proxy);
          if (proxyCfg != null)
            return proxyCfg;
        } else if (t3 === "https") {
          proxy = t2.$index(0, "https_proxy");
          proxyCfg = t1.call$1(proxy == null ? t2.$index(0, "HTTPS_PROXY") : proxy);
          if (proxyCfg != null)
            return proxyCfg;
        }
        return "DIRECT";
      }}
  },
  _HttpClient_close_closure: {
    "^": "Closure:58;force_0",
    call$1: function(c) {
      return c.close$1(this.force_0);
    },
    $isFunction: true
  },
  _HttpClient__openUrl_closure: {
    "^": "Closure:58;box_0,this_1,method_2,uri_3,isSecure_4",
    call$1: [function(info) {
      var t1, t2, t3;
      t1 = this.box_0;
      t2 = this.uri_3;
      t3 = new P._HttpClient__openUrl__send(t1, this.method_2, t2);
      if (info.get$connection().get$closed())
        return this.this_1._getConnection$4(t2.get$host(), t1.port_0, t1.proxyConf_1, this.isSecure_4).then$1(t3);
      return t3.call$1(info);
    }, "call$1", null, 2, 0, null, 121, "call"],
    $isFunction: true
  },
  _HttpClient__openUrl__send: {
    "^": "Closure:58;box_0,method_5,uri_6",
    call$1: [function(info) {
      var t1, t2, t3;
      t1 = info.get$connection();
      t2 = this.box_0.port_0;
      t3 = this.method_5;
      t3.toString;
      return t1.send$4(this.uri_6, t2, t3.toUpperCase(), info.get$proxy());
    }, "call$1", null, 2, 0, null, 121, "call"],
    $isFunction: true
  },
  _HttpClient__openUrlFromRequest_closure: {
    "^": "Closure:122;previous_0",
    call$1: [function(request) {
      var t1, t2, t3, header, t4, $name;
      t1 = this.previous_0;
      request.set$followRedirects(t1._followRedirects);
      request.set$maxRedirects(t1._maxRedirects);
      for (t1 = t1.headers._headers, t2 = H.setRuntimeTypeInfo(new P.HashMapKeyIterable(t1), [H.getTypeArgumentByIndex(t1, 0)]), t3 = t2._map, t2 = H.setRuntimeTypeInfo(new P.HashMapKeyIterator(t3, t3._computeKeys$0(), 0, null), [H.getTypeArgumentByIndex(t2, 0)]); t2.moveNext$0();) {
        header = t2._collection$_current;
        t3 = J.getInterceptor$s(header);
        if (request.get$headers()._headers.$index(0, t3.toLowerCase$0(header)) == null) {
          t4 = request.get$headers();
          t3 = t1.$index(0, t3.toLowerCase$0(header));
          if (!t4._mutable)
            H.throwExpression(P.HttpException$("HTTP headers are not mutable", null));
          $name = P._HttpHeaders__validateField(header);
          t4._headers.remove$1(0, $name);
          if ($name === "transfer-encoding")
            t4._chunkedTransferEncoding = false;
          t4._addAll$2($name, t3);
        }
      }
      request.get$headers().set$chunkedTransferEncoding(false);
      request.set$contentLength(0);
      return request;
    }, "call$1", null, 2, 0, null, 104, "call"],
    $isFunction: true
  },
  _HttpClient__updateTimers_closure: {
    "^": "Closure:58;",
    call$1: function(t) {
      return t.get$hasActive();
    },
    $isFunction: true
  },
  _HttpClient__updateTimers_closure0: {
    "^": "Closure:58;",
    call$1: function(t) {
      return t.get$hasIdle();
    },
    $isFunction: true
  },
  _HttpClient__updateTimers_closure1: {
    "^": "Closure:55;this_0",
    call$0: [function() {
      var t1 = this.this_0;
      t1._noActiveTimer = null;
      if (!t1._connectionTargets.get$values().any$1(0, new P._HttpClient__updateTimers__closure())) {
        t1.close$0();
        t1._closing = false;
      }
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _HttpClient__updateTimers__closure: {
    "^": "Closure:58;",
    call$1: function(t) {
      return t.get$hasActive();
    },
    $isFunction: true
  },
  _HttpClient__getConnectionTarget_closure: {
    "^": "Closure:55;host_0,port_1,isSecure_2,key_3",
    call$0: function() {
      return new P._ConnectionTarget(this.key_3, this.host_0, this.port_1, this.isSecure_2, P.HashSet_HashSet(null, null, null, null), P.HashSet_HashSet(null, null, null, null), P.ListQueue$(null, null), 0);
    },
    $isFunction: true
  },
  _HttpClient__getConnection_connect: {
    "^": "Closure:123;this_0,uriHost_1,uriPort_2,isSecure_3,proxies_4",
    call$1: [function(error) {
      var t1, proxy, host, port;
      t1 = this.proxies_4;
      if (!t1.moveNext$0())
        return P._Future$immediateError(error, null, null);
      proxy = t1._current;
      host = proxy.get$isDirect() ? this.uriHost_1 : proxy.get$host();
      port = proxy.get$isDirect() ? this.uriPort_2 : proxy.get$port();
      t1 = this.this_0;
      return t1._getConnectionTarget$3(host, port, this.isSecure_3).connect$4(this.uriHost_1, this.uriPort_2, proxy, t1).catchError$1(this);
    }, "call$1", null, 2, 0, null, 17, "call"],
    $isFunction: true
  },
  _HttpClient__findCredentials_closure: {
    "^": "Closure:56;url_0,scheme_1",
    call$2: function(prev, value) {
      value.applies$2(this.url_0, this.scheme_1);
      return prev;
    },
    $isFunction: true
  },
  _HttpClient__findProxyFromEnvironment_checkNoProxy: {
    "^": "Closure:3;url_0",
    call$1: function(option) {
      var t1, names, $name, t2;
      if (option == null)
        return;
      t1 = H.setRuntimeTypeInfo(new H.MappedListIterable(J.split$1$s(option, ","), new P._HttpClient__findProxyFromEnvironment_checkNoProxy_closure()), [null, null]);
      names = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.get$length(t1), 0, null), [H.getRuntimeTypeArgument(t1, "ListIterable", 0)]);
      for (t1 = this.url_0; names.moveNext$0();) {
        $name = names._current;
        t2 = J.getInterceptor$s($name);
        if (!(t2.startsWith$1($name, "[") && t2.endsWith$1($name, "]") && "[" + H.S(t1.get$host()) + "]" === $name))
          t2 = t2.get$isNotEmpty($name) && J.endsWith$1$s(t1.get$host(), $name);
        else
          t2 = true;
        if (t2)
          return "DIRECT";
      }
      return;
    },
    $isFunction: true
  },
  _HttpClient__findProxyFromEnvironment_checkNoProxy_closure: {
    "^": "Closure:58;",
    call$1: [function(s) {
      return J.trim$0$s(s);
    }, "call$1", null, 2, 0, null, 75, "call"],
    $isFunction: true
  },
  _HttpClient__findProxyFromEnvironment_checkProxy: {
    "^": "Closure:3;",
    call$1: function(option) {
      var pos;
      if (option == null)
        return;
      option = J.trim$0$s(option);
      if (option.length === 0)
        return;
      pos = C.JSString_methods.indexOf$1(option, "://");
      if (pos >= 0)
        option = C.JSString_methods.substring$1(option, pos + 3);
      pos = C.JSString_methods.indexOf$1(option, "/");
      if (pos >= 0)
        option = C.JSString_methods.substring$2(option, 0, pos);
      if (C.JSString_methods.indexOf$1(option, "[") === 0) {
        pos = C.JSString_methods.lastIndexOf$1(option, ":");
        if (C.JSString_methods.indexOf$1(option, "]") > pos)
          option += ":1080";
      } else if (C.JSString_methods.indexOf$1(option, ":") === -1)
        option += ":1080";
      return "PROXY " + option;
    },
    $isFunction: true
  },
  _HttpConnection: {
    "^": "LinkedListEntry__ServiceObject;_socket,_httpServer,_httpParser,_io$_state,_subscription,_idleTimer,_idleMark,_streamFuture,io$_ServiceObject$__serviceId,_list,_next,_previous",
    markIdle$0: function() {
      this._idleMark = true;
    },
    get$isMarkedIdle: function() {
      return this._idleMark;
    },
    destroy$0: function() {
      var t1 = this._io$_state;
      if (t1 === 2 || t1 === 3)
        return;
      this._io$_state = 2;
      this._socket.destroy$0();
      this._list._unlink$1(this);
      this._httpServer._maybePerformCleanup$0();
      $.get$_HttpConnection__connections().remove$1(0, this.get$_serviceId());
    },
    get$connectionInfo: function() {
      return P._HttpConnectionInfo_create(this._socket);
    },
    _HttpConnection$2: function(_socket, _httpServer) {
      var _, exception, t1, t2, t3;
      try {
        this._socket.set$_owner(this);
      } catch (exception) {
        t1 = H.unwrapException(exception);
        _ = t1;
        P.print(_);
      }

      $.get$_HttpConnection__connections().$indexSet(0, this.get$_serviceId(), this);
      t1 = this._httpParser;
      t2 = t1.get$_io$_onData();
      t3 = t1.get$_io$_onError();
      t1._socketSubscription = this._socket.listen$3$onDone$onError(t2, t1.get$_io$_onDone(), t3);
      this._subscription = H.setRuntimeTypeInfo(new P._ControllerStream(t1._controller), [null]).listen$4$cancelOnError$onDone$onError(new P._HttpConnection_closure(this), null, new P._HttpConnection_closure0(this), new P._HttpConnection_closure1(this));
    },
    static: {"^": "_HttpConnection__ACTIVE,_HttpConnection__IDLE,_HttpConnection__CLOSING,_HttpConnection__DETACHED,_HttpConnection__connections", _HttpConnection$: function(_socket, _httpServer) {
        var t1 = new P._HttpConnection(_socket, _httpServer, P._HttpParser$_(true), 1, null, null, false, null, 0, null, null, null);
        t1._HttpConnection$2(_socket, _httpServer);
        return t1;
      }}
  },
  LinkedListEntry__ServiceObject: {
    "^": "LinkedListEntry+_ServiceObject;",
    $asLinkedListEntry: function() {
      return [P._HttpConnection];
    }
  },
  _HttpConnection_closure: {
    "^": "Closure:58;this_0",
    call$1: [function(incoming) {
      var t1, t2, t3, outgoing, t4, t5, t6, t7, response, request;
      t1 = this.this_0;
      t2 = t1._httpServer;
      t2._idleConnections.remove$1(0, t1);
      t3 = t2._activeConnections;
      t3._insertAfter$2(t3._previous, t1);
      incoming.get$dataDone().then$1(new P._HttpConnection__closure(t1));
      t1._subscription.pause$0();
      t1._io$_state = 0;
      t3 = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(null)), [null]);
      outgoing = new P._HttpOutgoing(t3, t1._socket, false, false, null, 0, null, false, 0, null, 0, false, null, null, null, 0, false, null);
      t4 = incoming.get$uri();
      t5 = incoming.get$headers().protocolVersion;
      t6 = t2.defaultResponseHeaders;
      t7 = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(null)), [null]);
      response = new P._HttpResponse(200, null, null, null, null, null, false, true, t4, outgoing, P._HttpHeaders$(t5, t4.get$scheme() === "https" ? 443 : 80, t6), null, true, outgoing, t7, null, null, null, false, false, false);
      response._io$_doneFuture = t7.future;
      response._HttpOutboundMessage$4$initialHeaders(t4, t5, outgoing, t6, P.HttpResponse);
      request = P._HttpRequest$(response, incoming, t2, t1);
      t1._streamFuture = t3.future.then$2$onError(new P._HttpConnection__closure0(t1, incoming, response, request), new P._HttpConnection__closure1(t1));
      outgoing.ignoreBody = request._incoming.get$method() === "HEAD";
      response._httpRequest = request;
      t2._handleRequest$1(request);
    }, "call$1", null, 2, 0, null, 113, "call"],
    $isFunction: true
  },
  _HttpConnection__closure: {
    "^": "Closure:58;this_1",
    call$1: [function(closing) {
      if (closing === true)
        this.this_1.destroy$0();
    }, "call$1", null, 2, 0, null, 115, "call"],
    $isFunction: true
  },
  _HttpConnection__closure0: {
    "^": "Closure:58;this_2,incoming_3,response_4,request_5",
    call$1: [function(_) {
      var t1, t2;
      t1 = this.response_4;
      t1.set$deadline(null);
      t2 = this.this_2;
      if (t2._io$_state === 3)
        return;
      if (t1.headers._persistentConnection)
        if (this.request_5._incoming.get$headers()._persistentConnection)
          if (this.incoming_3.get$fullBodyRead()) {
            t1 = t2._httpParser;
            t1 = !(t1._connectionUpgrade === true && t1._io$_state === 26) && !t2._httpServer.closed;
          } else
            t1 = false;
        else
          t1 = false;
      else
        t1 = false;
      if (t1) {
        t2._io$_state = 1;
        t2._idleMark = false;
        t1 = t2._httpServer;
        t1._activeConnections.remove$1(0, t2);
        t1 = t1._idleConnections;
        t1._insertAfter$2(t1._previous, t2);
        t2._subscription.resume$0();
      } else
        t2.destroy$0();
    }, "call$1", null, 2, 0, null, 60, "call"],
    $isFunction: true
  },
  _HttpConnection__closure1: {
    "^": "Closure:58;this_6",
    call$1: [function(_) {
      this.this_6.destroy$0();
    }, "call$1", null, 2, 0, null, 60, "call"],
    $isFunction: true
  },
  _HttpConnection_closure0: {
    "^": "Closure:55;this_7",
    call$0: [function() {
      this.this_7.destroy$0();
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _HttpConnection_closure1: {
    "^": "Closure:58;this_8",
    call$1: [function(error) {
      this.this_8.destroy$0();
    }, "call$1", null, 2, 0, null, 17, "call"],
    $isFunction: true
  },
  _HttpServer: {
    "^": "Stream__ServiceObject;serverHeader,defaultResponseHeaders,_idleTimeout,_idleTimer,_sessionManagerInstance,closed<,_serverSocket,_closeServer,_activeConnections,_idleConnections,_controller,io$_ServiceObject$__serviceId",
    set$idleTimeout: function(duration) {
      var t1 = this._idleTimer;
      if (t1 != null) {
        t1.cancel$0();
        this._idleTimer = null;
      }
      this._idleTimeout = duration;
      if (duration != null)
        this._idleTimer = P.Timer_Timer$periodic(duration, new P._HttpServer_idleTimeout_closure(this));
    },
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var t1;
      this._serverSocket.listen$3$onDone$onError(new P._HttpServer_listen_closure(this), this._controller.get$close(), new P._HttpServer_listen_closure0(this));
      t1 = this._controller;
      t1.toString;
      return H.setRuntimeTypeInfo(new P._ControllerStream(t1), [null]).listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    listen$1: function(onData) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
    },
    close$1$force: [function(force) {
      var result, t1;
      this.closed = true;
      result = this._closeServer ? this._serverSocket.close$0() : P._Future$immediate(null, null);
      this.set$idleTimeout(null);
      if (force === true)
        for (t1 = this._activeConnections, t1 = P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "IterableBase", 0)), t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
          t1._current.destroy$0();
      for (t1 = this._idleConnections, t1 = P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "IterableBase", 0)), t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
        t1._current.destroy$0();
      this._maybePerformCleanup$0();
      return result;
    }, function() {
      return this.close$1$force(false);
    }, "close$0", "call$1$force", "call$0", "get$close", 0, 3, 124, 125, 126],
    _maybePerformCleanup$0: function() {
      if (this.closed && this._idleConnections._collection$_length === 0 && this._activeConnections._collection$_length === 0 && this._sessionManagerInstance != null) {
        this._sessionManagerInstance._stopTimer$0();
        this._sessionManagerInstance = null;
        $.get$_HttpServer__servers().remove$1(0, this.get$_serviceId());
      }
    },
    get$port: function() {
      if (this.closed)
        throw H.wrapException(P.HttpException$("HttpServer is not bound to a socket", null));
      return this._serverSocket.get$port();
    },
    _handleRequest$1: function(request) {
      P.Timer_Timer(C.Duration_0, new P._HttpServer__handleRequest_closure(this, request));
    },
    _io$_HttpServer$_$2: function(_serverSocket, _closeServer) {
      this._controller = P.StreamController_StreamController(this.get$close(), null, null, null, true, P.HttpRequest);
      this.set$idleTimeout(C.Duration_120000000);
      $.get$_HttpServer__servers().$indexSet(0, this.get$_serviceId(), this);
      this._serverSocket.set$_owner(this);
    },
    static: {"^": "_HttpServer__servers", _HttpServer_bind: function(address, port, backlog) {
        return P.ServerSocket_bind(address, port, backlog, false).then$1(new P._HttpServer_bind_closure());
      }}
  },
  Stream__ServiceObject: {
    "^": "Stream+_ServiceObject;",
    $asStream: function() {
      return [P.HttpRequest];
    }
  },
  _HttpServer_bind_closure: {
    "^": "Closure:58;",
    call$1: function(socket) {
      var defaultResponseHeaders, t1, t2;
      defaultResponseHeaders = P._HttpHeaders$("1.1", 80, null);
      t1 = $.get$ContentType_TEXT();
      if (!defaultResponseHeaders._mutable)
        H.throwExpression(P.HttpException$("HTTP headers are not mutable", null));
      defaultResponseHeaders._set$2("content-type", J.toString$0(t1));
      defaultResponseHeaders.set$2("X-Frame-Options", "SAMEORIGIN");
      defaultResponseHeaders.set$2("X-Content-Type-Options", "nosniff");
      defaultResponseHeaders.set$2("X-XSS-Protection", "1; mode=block");
      t1 = H.setRuntimeTypeInfo(new P.LinkedList(0, 0, null, null), [P._HttpConnection]);
      t1._previous = t1;
      t1._next = t1;
      t2 = H.setRuntimeTypeInfo(new P.LinkedList(0, 0, null, null), [P._HttpConnection]);
      t2._previous = t2;
      t2._next = t2;
      t2 = new P._HttpServer(null, defaultResponseHeaders, null, null, null, false, socket, true, t1, t2, null, 0);
      t2._io$_HttpServer$_$2(socket, true);
      return t2;
    },
    $isFunction: true
  },
  _HttpServer_idleTimeout_closure: {
    "^": "Closure:58;this_0",
    call$1: [function(_) {
      var t1, idle;
      for (t1 = this.this_0._idleConnections, t1 = P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "IterableBase", 0)), t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        idle = t1._current;
        if (idle.get$isMarkedIdle())
          idle.destroy$0();
        else
          idle.markIdle$0();
      }
    }, "call$1", null, 2, 0, null, 60, "call"],
    $isFunction: true
  },
  _HttpServer_listen_closure: {
    "^": "Closure:128;this_0",
    call$1: [function(socket) {
      var t1, connection;
      socket.setOption$2(C.SocketOption_0, true);
      t1 = this.this_0;
      connection = P._HttpConnection$(socket, t1);
      t1 = t1._idleConnections;
      t1._insertAfter$2(t1._previous, connection);
    }, "call$1", null, 2, 0, null, 127, "call"],
    $isFunction: true
  },
  _HttpServer_listen_closure0: {
    "^": "Closure:58;this_1",
    call$1: [function(error) {
      var t1;
      if (!J.getInterceptor(error).$isHandshakeException) {
        t1 = this.this_1._controller;
        if (t1._state >= 4)
          H.throwExpression(t1._badEventState$0());
        t1._addError$2(error, null);
      }
    }, "call$1", null, 2, 0, null, 17, "call"],
    $isFunction: true
  },
  _HttpServer__handleRequest_closure: {
    "^": "Closure:55;this_0,request_1",
    call$0: [function() {
      var t1, t2;
      t1 = this.this_0;
      t2 = this.request_1;
      if (!t1.closed) {
        t1 = t1._controller;
        if (t1._state >= 4)
          H.throwExpression(t1._badEventState$0());
        t1._async$_add$1(t2);
      } else
        t2._httpConnection.destroy$0();
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _ProxyConfiguration: {
    "^": "Object;proxies",
    _ProxyConfiguration$1: function(configuration) {
      if (configuration == null)
        throw H.wrapException(P.HttpException$("Invalid proxy configuration " + H.S(configuration), null));
      H.IterableMixinWorkaround_forEach(J.split$1$s(configuration, ";"), new P._ProxyConfiguration_closure(this, configuration));
    },
    static: {"^": "_ProxyConfiguration_PROXY_PREFIX,_ProxyConfiguration_DIRECT_PREFIX", _ProxyConfiguration$: function(configuration) {
        var t1 = new P._ProxyConfiguration(H.setRuntimeTypeInfo([], [P._Proxy]));
        t1._ProxyConfiguration$1(configuration);
        return t1;
      }}
  },
  _ProxyConfiguration_closure: {
    "^": "Closure:3;this_0,configuration_1",
    call$1: function(proxy) {
      var portString, port, at, userinfo, colon, username, password, host, exception;
      proxy = J.trim$0$s(proxy);
      if (proxy.length !== 0)
        if (C.JSString_methods.startsWith$1(proxy, "PROXY ")) {
          proxy = C.JSString_methods.trim$0(C.JSString_methods.substring$1(proxy, 6));
          at = C.JSString_methods.indexOf$1(proxy, "@");
          if (at !== -1) {
            userinfo = C.JSString_methods.trim$0(C.JSString_methods.substring$2(proxy, 0, at));
            proxy = C.JSString_methods.trim$0(C.JSString_methods.substring$1(proxy, at + 1));
            colon = C.JSString_methods.indexOf$1(userinfo, ":");
            if (colon === -1 || colon === 0 || colon === proxy.length - 1)
              throw H.wrapException(P.HttpException$("Invalid proxy configuration " + H.S(this.configuration_1), null));
            username = C.JSString_methods.trim$0(C.JSString_methods.substring$2(userinfo, 0, colon));
            password = C.JSString_methods.trim$0(C.JSString_methods.substring$1(userinfo, colon + 1));
          } else {
            username = null;
            password = null;
          }
          colon = C.JSString_methods.lastIndexOf$1(proxy, ":");
          if (colon === -1 || colon === 0 || colon === proxy.length - 1)
            throw H.wrapException(P.HttpException$("Invalid proxy configuration " + H.S(this.configuration_1), null));
          host = C.JSString_methods.trim$0(C.JSString_methods.substring$2(proxy, 0, colon));
          if (C.JSString_methods.startsWith$1(host, "[") && C.JSString_methods.endsWith$1(host, "]"))
            host = C.JSString_methods.substring$2(host, 1, host.length - 1);
          portString = C.JSString_methods.trim$0(C.JSString_methods.substring$1(proxy, colon + 1));
          port = null;
          try {
            port = H.Primitives_parseInt(portString, null, null);
          } catch (exception) {
            if (!!J.getInterceptor(H.unwrapException(exception)).$isFormatException)
              throw H.wrapException(P.HttpException$("Invalid proxy configuration " + H.S(this.configuration_1) + ", invalid port '" + H.S(portString) + "'", null));
            else
              throw exception;
          }

          C.JSArray_methods.add$1(this.this_0.proxies, new P._Proxy(host, port, username, password, false));
        } else if (C.JSString_methods.trim$0(proxy) === "DIRECT")
          C.JSArray_methods.add$1(this.this_0.proxies, P._Proxy$direct());
        else
          throw H.wrapException(P.HttpException$("Invalid proxy configuration " + H.S(this.configuration_1), null));
    },
    $isFunction: true
  },
  _Proxy: {
    "^": "Object;host<,port<,username<,password<,isDirect<",
    get$isAuthenticated: function() {
      return this.username != null;
    },
    static: {_Proxy$direct: function() {
        return new P._Proxy(null, null, null, null, true);
      }}
  },
  _HttpConnectionInfo: {
    "^": "Object;remoteAddress@,remotePort@,localPort?",
    static: {_HttpConnectionInfo_create: function(socket) {
        var info, t1, exception;
        if (socket == null)
          return;
        try {
          info = new P._HttpConnectionInfo(null, null, null);
          t1 = info;
          t1.set$remoteAddress(socket.get$remoteAddress());
          t1.set$remotePort(socket.get$remotePort());
          t1.set$localPort(socket.get$port());
          return t1;
        } catch (exception) {
          H.unwrapException(exception);
        }

        return;
      }}
  },
  _AuthenticationScheme: {
    "^": "Object;_scheme",
    toString$0: function(_) {
      if (this === C._AuthenticationScheme_0)
        return "Basic";
      if (this === C._AuthenticationScheme_1)
        return "Digest";
      return "Unknown";
    },
    static: {"^": "_AuthenticationScheme_UNKNOWN,_AuthenticationScheme_BASIC,_AuthenticationScheme_DIGEST", _AuthenticationScheme__AuthenticationScheme$fromString: function(scheme) {
        if (scheme.toLowerCase() === "basic")
          return C._AuthenticationScheme_0;
        if (scheme.toLowerCase() === "digest")
          return C._AuthenticationScheme_1;
        return C._AuthenticationScheme_m1;
      }}
  },
  _Credentials: {
    "^": "Object;"
  },
  _RedirectInfo: {
    "^": "Object;statusCode<,method<,location<"
  },
  _HttpParser: {
    "^": "Stream;_parserCalled,_buffer,_io$_index,_requestParser,_io$_state,_httpVersionIndex,_messageType,_statusCode,_statusCodeLength,_io$_method,_uri_or_reason_phrase,_headerField,_headerValue,_httpVersion,_transferLength,_persistentConnection,_connectionUpgrade,_chunked,_noMessageBody,_remainingContent,_headers,_incoming,_socketSubscription,_paused,_bodyPaused,_controller,_bodyController",
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      return H.setRuntimeTypeInfo(new P._ControllerStream(this._controller), [null]).listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    listen$1: function(onData) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
    },
    _parse$0: function() {
      var e, s, exception, t1;
      try {
        this._doParse$0();
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        this._io$_state = 27;
        this._reportError$2(e, s);
      }

    },
    _doParse$0: function() {
      var t1, t2, t3, t4, t5, t6, t7, t8, $byte, i, headerField, headerValue, tokens, tmp, t9, value, dataAvailable, data;
      this._parserCalled = true;
      t1 = this._io$_state;
      if (t1 === 25)
        throw H.wrapException(P.HttpException$("Data on closed connection", null));
      if (t1 === 27)
        throw H.wrapException(P.HttpException$("Data on failed connection", null));
      t1 = this._headerField;
      t2 = this._headerValue;
      t3 = this._uri_or_reason_phrase;
      t4 = this._io$_method;
      t5 = this._requestParser;
      t6 = !t5;
      while (true) {
        t7 = this._buffer;
        if (t7 != null) {
          t8 = this._io$_index;
          t7 = J.get$length$asx(t7);
          if (typeof t8 !== "number")
            return t8.$lt();
          if (typeof t7 !== "number")
            return H.iae(t7);
          if (t8 < t7) {
            t7 = this._io$_state;
            t7 = t7 !== 27 && t7 !== 26;
          } else
            t7 = false;
        } else
          t7 = false;
        if (!t7)
          break;
        t7 = this._incoming == null;
        if (!(!t7 && this._bodyPaused))
          t7 = t7 && this._paused;
        else
          t7 = true;
        if (t7) {
          this._parserCalled = false;
          return;
        }
        t7 = this._buffer;
        t8 = this._io$_index;
        if (typeof t8 !== "number")
          return t8.$add();
        this._io$_index = t8 + 1;
        $byte = J.$index$asx(t7, t8);
        switch (this._io$_state) {
          case 0:
            t7 = J.getInterceptor($byte);
            if (t7.$eq($byte, 72)) {
              this._httpVersionIndex = 1;
              this._io$_state = 1;
            } else {
              if (t7.$gt($byte, 31))
                if (t7.$lt($byte, 128)) {
                  if ($byte >>> 0 !== $byte || $byte >= 256)
                    return H.ioore(C.List_NUU, $byte);
                  t7 = !C.List_NUU[$byte];
                } else
                  t7 = false;
              else
                t7 = false;
              if (!t7)
                throw H.wrapException(P.HttpException$("Invalid request method", null));
              t4.push($byte);
              if (t6)
                throw H.wrapException(P.HttpException$("Invalid response line", null));
              this._io$_state = 3;
            }
            break;
          case 1:
            t7 = this._httpVersionIndex;
            if (typeof t7 !== "number")
              return t7.$lt();
            if (t7 < 4 && J.$eq($byte, C.List_72_84_84_80[t7])) {
              t7 = this._httpVersionIndex;
              if (typeof t7 !== "number")
                return t7.$add();
              this._httpVersionIndex = t7 + 1;
            } else if (this._httpVersionIndex === 4 && J.$eq($byte, 47)) {
              t7 = this._httpVersionIndex;
              if (typeof t7 !== "number")
                return t7.$add();
              this._httpVersionIndex = t7 + 1;
              if (t5)
                throw H.wrapException(P.HttpException$("Invalid request line", null));
              this._io$_state = 2;
            } else {
              i = 0;
              while (true) {
                t7 = this._httpVersionIndex;
                if (typeof t7 !== "number")
                  return H.iae(t7);
                if (!(i < t7))
                  break;
                if (i >= 4)
                  return H.ioore(C.List_72_84_84_80, i);
                t4.push(C.List_72_84_84_80[i]);
                ++i;
              }
              if (J.$eq($byte, 32))
                this._io$_state = 4;
              else {
                t4.push($byte);
                this._httpVersion = 0;
                if (t6)
                  throw H.wrapException(P.HttpException$("Invalid response line", null));
                this._io$_state = 3;
              }
            }
            break;
          case 2:
            t7 = this._httpVersionIndex;
            if (typeof t7 !== "number")
              return t7.$lt();
            if (t7 < 7) {
              if (!J.$eq($byte, C.List_E7y[t7]))
                H.throwExpression(P.HttpException$("Failed to parse HTTP", null));
              t7 = this._httpVersionIndex;
              if (typeof t7 !== "number")
                return t7.$add();
              this._httpVersionIndex = t7 + 1;
            } else if (t7 === 7 && J.$eq($byte, 49)) {
              this._httpVersion = 2;
              this._persistentConnection = true;
              t7 = this._httpVersionIndex;
              if (typeof t7 !== "number")
                return t7.$add();
              this._httpVersionIndex = t7 + 1;
            } else if (this._httpVersionIndex === 7 && J.$eq($byte, 48)) {
              this._httpVersion = 1;
              this._persistentConnection = false;
              t7 = this._httpVersionIndex;
              if (typeof t7 !== "number")
                return t7.$add();
              this._httpVersionIndex = t7 + 1;
            } else if (this._httpVersionIndex === 8) {
              if (!J.$eq($byte, 32))
                H.throwExpression(P.HttpException$("Failed to parse HTTP", null));
              this._io$_state = 7;
            } else
              throw H.wrapException(P.HttpException$("Invalid response line", null));
            break;
          case 3:
            if (J.$eq($byte, 32))
              this._io$_state = 4;
            else {
              if ($byte >>> 0 !== $byte || $byte >= 256)
                return H.ioore(C.List_NUU, $byte);
              if (C.List_NUU[$byte] || $byte === 13 || $byte === 10)
                throw H.wrapException(P.HttpException$("Invalid request method", null));
              t4.push($byte);
            }
            break;
          case 4:
            t7 = J.getInterceptor($byte);
            if (t7.$eq($byte, 32)) {
              if (t3.length === 0)
                throw H.wrapException(P.HttpException$("Invalid request URI", null));
              this._io$_state = 5;
              this._httpVersionIndex = 0;
            } else {
              if (t7.$eq($byte, 13) || t7.$eq($byte, 10))
                throw H.wrapException(P.HttpException$("Invalid request URI", null));
              t3.push($byte);
            }
            break;
          case 5:
            t7 = this._httpVersionIndex;
            if (typeof t7 !== "number")
              return t7.$lt();
            if (t7 < 7) {
              if (!J.$eq($byte, C.List_2Vk[t7]))
                H.throwExpression(P.HttpException$("Failed to parse HTTP", null));
              t7 = this._httpVersionIndex;
              if (typeof t7 !== "number")
                return t7.$add();
              this._httpVersionIndex = t7 + 1;
            } else if (t7 === 7) {
              t7 = J.getInterceptor($byte);
              if (t7.$eq($byte, 49)) {
                this._httpVersion = 2;
                this._persistentConnection = true;
                t7 = this._httpVersionIndex;
                if (typeof t7 !== "number")
                  return t7.$add();
                this._httpVersionIndex = t7 + 1;
              } else if (t7.$eq($byte, 48)) {
                this._httpVersion = 1;
                this._persistentConnection = false;
                t7 = this._httpVersionIndex;
                if (typeof t7 !== "number")
                  return t7.$add();
                this._httpVersionIndex = t7 + 1;
              } else
                throw H.wrapException(P.HttpException$("Invalid response line", null));
            } else {
              if (!J.$eq($byte, 13))
                H.throwExpression(P.HttpException$("Failed to parse HTTP", null));
              this._io$_state = 6;
            }
            break;
          case 6:
            if (!J.$eq($byte, 10))
              H.throwExpression(P.HttpException$("Failed to parse HTTP", null));
            this._messageType = 1;
            this._io$_state = 10;
            break;
          case 7:
            t7 = J.getInterceptor($byte);
            if (t7.$eq($byte, 32))
              this._io$_state = 8;
            else if (t7.$eq($byte, 13))
              this._io$_state = 9;
            else {
              ++this._statusCodeLength;
              if (t7.$lt($byte, 48)) {
                if (typeof $byte !== "number")
                  return H.iae($byte);
                t7 = 57 < $byte;
              } else
                t7 = false;
              if (t7 || this._statusCodeLength > 3)
                throw H.wrapException(P.HttpException$("Invalid response status code", null));
              else {
                t7 = this._statusCode;
                if (typeof $byte !== "number")
                  return H.iae($byte);
                this._statusCode = t7 * 10 + $byte - 48;
              }
            }
            break;
          case 8:
            t7 = J.getInterceptor($byte);
            if (t7.$eq($byte, 13))
              this._io$_state = 9;
            else {
              if (t7.$eq($byte, 13) || t7.$eq($byte, 10))
                throw H.wrapException(P.HttpException$("Invalid response reason phrase", null));
              t3.push($byte);
            }
            break;
          case 9:
            if (!J.$eq($byte, 10))
              H.throwExpression(P.HttpException$("Failed to parse HTTP", null));
            t7 = this._statusCode;
            if (t7 < 100 || t7 > 599)
              throw H.wrapException(P.HttpException$("Invalid response status code", null));
            else if (t7 <= 199 || t7 === 204 || t7 === 304)
              this._noMessageBody = true;
            this._io$_state = 10;
            break;
          case 10:
            this._headers = P._HttpHeaders$(this.get$version(), 80, null);
            t7 = J.getInterceptor($byte);
            if (t7.$eq($byte, 13))
              this._io$_state = 16;
            else {
              t1.push(J.$and$n(t7.$sub($byte, 65), 127) < 26 ? t7.$or($byte, 32) : $byte);
              this._io$_state = 11;
            }
            break;
          case 11:
            t7 = J.getInterceptor($byte);
            if (t7.$eq($byte, 58))
              this._io$_state = 12;
            else {
              if (t7.$gt($byte, 31))
                if (t7.$lt($byte, 128)) {
                  if ($byte >>> 0 !== $byte || $byte >= 256)
                    return H.ioore(C.List_NUU, $byte);
                  t8 = !C.List_NUU[$byte];
                } else
                  t8 = false;
              else
                t8 = false;
              if (!t8)
                throw H.wrapException(P.HttpException$("Invalid header field name", null));
              t1.push(J.$and$n(t7.$sub($byte, 65), 127) < 26 ? t7.$or($byte, 32) : $byte);
            }
            break;
          case 12:
            t7 = J.getInterceptor($byte);
            if (t7.$eq($byte, 13))
              this._io$_state = 14;
            else if (!t7.$eq($byte, 32) && !t7.$eq($byte, 9)) {
              t2.push($byte);
              this._io$_state = 13;
            }
            break;
          case 13:
            if (J.$eq($byte, 13))
              this._io$_state = 14;
            else
              t2.push($byte);
            break;
          case 14:
            if (!J.$eq($byte, 10))
              H.throwExpression(P.HttpException$("Failed to parse HTTP", null));
            this._io$_state = 15;
            break;
          case 15:
            t7 = J.getInterceptor($byte);
            if (t7.$eq($byte, 32) || t7.$eq($byte, 9))
              this._io$_state = 12;
            else {
              headerField = H.Primitives_stringFromCharCodes(t1);
              headerValue = H.Primitives_stringFromCharCodes(t2);
              if (headerField === "transfer-encoding" && this._caseInsensitiveCompare$2(new J._CodeUnits("chunked"), t2))
                this._chunked = true;
              if (headerField === "connection") {
                tokens = P._HttpParser__tokenizeFieldValue(headerValue);
                for (i = 0; i < tokens.length; ++i) {
                  if (this._caseInsensitiveCompare$2(new J._CodeUnits("upgrade"), new J._CodeUnits(tokens[i])))
                    this._connectionUpgrade = true;
                  t8 = this._headers;
                  if (i >= tokens.length)
                    return H.ioore(tokens, i);
                  t8._io$_add$2(headerField, tokens[i]);
                }
              } else
                this._headers._io$_add$2(headerField, headerValue);
              C.JSArray_methods.set$length(t1, 0);
              C.JSArray_methods.set$length(t2, 0);
              if (t7.$eq($byte, 13))
                this._io$_state = 16;
              else {
                t1.push(J.$and$n(t7.$sub($byte, 65), 127) < 26 ? t7.$or($byte, 32) : $byte);
                this._io$_state = 11;
              }
            }
            break;
          case 16:
            if (!J.$eq($byte, 10))
              H.throwExpression(P.HttpException$("Failed to parse HTTP", null));
            t7 = this._headers;
            t7._mutable = false;
            t7 = t7._contentLength;
            this._transferLength = t7;
            if (this._chunked === true) {
              this._transferLength = -1;
              t7 = -1;
            }
            if (this._messageType === 1 && J.$lt$n(t7, 0) && this._chunked === false)
              this._transferLength = 0;
            if (this._connectionUpgrade === true) {
              this._io$_state = 26;
              this._transferLength = 0;
            }
            this._createIncoming$1(this._transferLength);
            t7 = this._incoming;
            if (t5) {
              t7.method = H.Primitives_stringFromCharCodes(t4);
              t7 = this._incoming;
              t7.uri = P.Uri_parse(H.Primitives_stringFromCharCodes(t3));
            } else {
              t7.statusCode = this._statusCode;
              t7.reasonPhrase = H.Primitives_stringFromCharCodes(t3);
            }
            C.JSArray_methods.set$length(t4, 0);
            C.JSArray_methods.set$length(t3, 0);
            if (this._connectionUpgrade === true) {
              t1 = this._incoming;
              t1.upgraded = true;
              this._parserCalled = false;
              this._closeIncoming$0();
              t2 = this._controller;
              if (t2._state >= 4)
                H.throwExpression(t2._badEventState$0());
              t3 = t2._state;
              if ((t3 & 1) !== 0)
                t2._sendData$1(t1);
              else if ((t3 & 3) === 0) {
                t3 = t2._ensurePendingEvents$0();
                t1 = new P._DelayedData(t1, null);
                t1.$builtinTypeInfo = [H.getRuntimeTypeArgument(t2, "_StreamController", 0)];
                t3.add$1(0, t1);
              }
              return;
            }
            if (!J.$eq(this._transferLength, 0))
              t7 = this._messageType === 0 && this._noMessageBody;
            else
              t7 = true;
            if (t7) {
              this._reset$0();
              tmp = this._incoming;
              this._closeIncoming$0();
              t7 = this._controller;
              if (t7._state >= 4)
                H.throwExpression(t7._badEventState$0());
              t8 = t7._state;
              if ((t8 & 1) !== 0)
                t7._sendData$1(tmp);
              else if ((t8 & 3) === 0) {
                t8 = t7._ensurePendingEvents$0();
                t9 = new P._DelayedData(tmp, null);
                t9.$builtinTypeInfo = [H.getRuntimeTypeArgument(t7, "_StreamController", 0)];
                t8.add$1(0, t9);
              }
              break;
            } else if (this._chunked === true) {
              this._io$_state = 19;
              this._remainingContent = 0;
            } else if (J.$gt$n(this._transferLength, 0)) {
              this._remainingContent = this._transferLength;
              this._io$_state = 24;
            } else
              this._io$_state = 24;
            this._parserCalled = false;
            t1 = this._controller;
            t2 = this._incoming;
            if (t1._state >= 4)
              H.throwExpression(t1._badEventState$0());
            t3 = t1._state;
            if ((t3 & 1) !== 0)
              t1._sendData$1(t2);
            else if ((t3 & 3) === 0) {
              t3 = t1._ensurePendingEvents$0();
              t2 = new P._DelayedData(t2, null);
              t2.$builtinTypeInfo = [H.getRuntimeTypeArgument(t1, "_StreamController", 0)];
              t3.add$1(0, t2);
            }
            return;
          case 17:
            if (!J.$eq($byte, 13))
              H.throwExpression(P.HttpException$("Failed to parse HTTP", null));
            this._io$_state = 18;
            break;
          case 18:
            if (!J.$eq($byte, 10))
              H.throwExpression(P.HttpException$("Failed to parse HTTP", null));
            this._io$_state = 19;
            break;
          case 19:
            t7 = J.getInterceptor($byte);
            if (t7.$eq($byte, 13))
              this._io$_state = 21;
            else if (t7.$eq($byte, 59))
              this._io$_state = 20;
            else {
              value = this._expectHexDigit$1($byte);
              this._remainingContent = J.$add$ns(J.$mul$ns(this._remainingContent, 16), value);
            }
            break;
          case 20:
            if (J.$eq($byte, 13))
              this._io$_state = 21;
            break;
          case 21:
            if (!J.$eq($byte, 10))
              H.throwExpression(P.HttpException$("Failed to parse HTTP", null));
            if (J.$gt$n(this._remainingContent, 0))
              this._io$_state = 24;
            else
              this._io$_state = 22;
            break;
          case 22:
            if (!J.$eq($byte, 13))
              H.throwExpression(P.HttpException$("Failed to parse HTTP", null));
            this._io$_state = 23;
            break;
          case 23:
            if (!J.$eq($byte, 10))
              H.throwExpression(P.HttpException$("Failed to parse HTTP", null));
            this._reset$0();
            this._closeIncoming$0();
            break;
          case 24:
            t7 = this._io$_index;
            if (typeof t7 !== "number")
              return t7.$sub();
            this._io$_index = t7 - 1;
            dataAvailable = J.$sub$n(J.get$length$asx(this._buffer), this._io$_index);
            if (J.$ge$n(this._remainingContent, 0)) {
              t7 = this._remainingContent;
              if (typeof t7 !== "number")
                return H.iae(t7);
              t7 = dataAvailable > t7;
            } else
              t7 = false;
            if (t7)
              dataAvailable = this._remainingContent;
            t7 = J.get$buffer$x(this._buffer);
            t8 = J.get$offsetInBytes$x(this._buffer);
            t9 = this._io$_index;
            if (typeof t8 !== "number")
              return t8.$add();
            if (typeof t9 !== "number")
              return H.iae(t9);
            data = J.asUint8List$2$x(t7, t8 + t9, dataAvailable);
            t9 = this._bodyController;
            if (t9._state >= 4)
              H.throwExpression(t9._badEventState$0());
            t7 = t9._state;
            if ((t7 & 1) !== 0)
              t9._sendData$1(data);
            else if ((t7 & 3) === 0) {
              t7 = t9._ensurePendingEvents$0();
              t8 = new P._DelayedData(data, null);
              t8.$builtinTypeInfo = [H.getRuntimeTypeArgument(t9, "_StreamController", 0)];
              t7.add$1(0, t8);
            }
            if (!J.$eq(this._remainingContent, -1))
              this._remainingContent = J.$sub$n(this._remainingContent, data.length);
            t7 = this._io$_index;
            if (typeof t7 !== "number")
              return t7.$add();
            this._io$_index = t7 + data.length;
            if (J.$eq(this._remainingContent, 0))
              if (this._chunked !== true) {
                this._reset$0();
                this._closeIncoming$0();
              } else
                this._io$_state = 17;
            break;
          case 27:
            break;
          default:
            break;
        }
      }
      this._parserCalled = false;
      t1 = this._buffer;
      if (t1 != null && this._io$_index === J.get$length$asx(t1)) {
        this._buffer = null;
        this._io$_index = null;
        t1 = this._io$_state;
        if (t1 !== 26 && t1 !== 27)
          this._socketSubscription.resume$0();
      }
    },
    _io$_onData$1: [function(buffer) {
      this._socketSubscription.pause$0();
      this._buffer = buffer;
      this._io$_index = 0;
      this._parse$0();
    }, "call$1", "get$_io$_onData", 2, 0, 83, 129],
    _io$_onDone$0: [function() {
      var t1, t2;
      this._socketSubscription = null;
      t1 = this._io$_state;
      if (t1 === 25 || t1 === 27)
        return;
      if (this._incoming != null) {
        if (t1 !== 26)
          if (!(t1 === 0 && !this._requestParser)) {
            t2 = !(t1 === 24 && this._chunked !== true && J.$eq(this._transferLength, -1));
            t1 = t2;
          } else
            t1 = false;
        else
          t1 = false;
        if (t1) {
          t1 = this._bodyController;
          if (t1._state >= 4)
            H.throwExpression(t1._badEventState$0());
          t1._addError$2(new P.HttpException("Connection closed while receiving data", null), null);
        }
        this._closeIncoming$1(true);
        this._controller.close$0();
        return;
      }
      if (t1 === 0) {
        if (!this._requestParser)
          this._reportError$1(new P.HttpException("Connection closed before full header was received", null));
        this._controller.close$0();
        return;
      }
      if (t1 === 26) {
        this._controller.close$0();
        return;
      }
      if (typeof t1 !== "number")
        return t1.$lt();
      if (t1 < 17) {
        this._io$_state = 27;
        this._reportError$1(new P.HttpException("Connection closed before full header was received", null));
        this._controller.close$0();
        return;
      }
      if (this._chunked !== true && J.$eq(this._transferLength, -1))
        this._io$_state = 25;
      else {
        this._io$_state = 27;
        this._reportError$1(new P.HttpException("Connection closed before full body was received", null));
      }
      this._controller.close$0();
    }, "call$0", "get$_io$_onDone", 0, 0, 12],
    _io$_onError$2: [function(e, stackTrace) {
      var t1 = this._controller;
      if (t1._state >= 4)
        H.throwExpression(t1._badEventState$0());
      t1._addError$2(e, stackTrace);
    }, function(e) {
      return this._io$_onError$2(e, null);
    }, "_io$_onError$1", "call$2", "call$1", "get$_io$_onError", 2, 2, 15, 16, 2, 18],
    get$version: function() {
      switch (this._httpVersion) {
        case 1:
          return "1.0";
        case 2:
          return "1.1";
      }
      return;
    },
    _reset$0: function() {
      if (this._io$_state === 26)
        return;
      this._io$_state = 0;
      this._messageType = 0;
      C.JSArray_methods.set$length(this._headerField, 0);
      C.JSArray_methods.set$length(this._headerValue, 0);
      C.JSArray_methods.set$length(this._io$_method, 0);
      C.JSArray_methods.set$length(this._uri_or_reason_phrase, 0);
      this._statusCode = 0;
      this._statusCodeLength = 0;
      this._httpVersion = 0;
      this._transferLength = -1;
      this._persistentConnection = false;
      this._connectionUpgrade = false;
      this._chunked = false;
      this._noMessageBody = false;
      this._remainingContent = -1;
      this._headers = null;
    },
    _caseInsensitiveCompare$2: function(expected, value) {
      var t1, t2, t3, i, t4, t5, t6;
      t1 = expected._string;
      t2 = t1.length;
      t3 = J.getInterceptor$asx(value);
      if (t2 !== t3.get$length(value))
        return false;
      for (i = 0; i < t2; ++i) {
        if (i >= t2)
          H.throwExpression(P.RangeError$value(i));
        t4 = t1.charCodeAt(i);
        t5 = t3.$index(value, i);
        t6 = J.getInterceptor$n(t5);
        if (t4 !== (J.$and$n(t6.$sub(t5, 65), 127) < 26 ? t6.$or(t5, 32) : t5))
          return false;
      }
      return true;
    },
    _expectHexDigit$1: function($byte) {
      if (typeof $byte !== "number")
        return H.iae($byte);
      if (48 <= $byte && $byte <= 57)
        return $byte - 48;
      else if (65 <= $byte && $byte <= 70)
        return $byte - 65 + 10;
      else if (97 <= $byte && $byte <= 102)
        return $byte - 97 + 10;
      else
        throw H.wrapException(P.HttpException$("Failed to parse HTTP", null));
    },
    _createIncoming$1: function(transferLength) {
      var t1, t2, t3, t4, incoming;
      t1 = {};
      t1.incoming_0 = null;
      t2 = P.StreamController_StreamController(new P._HttpParser__createIncoming_closure(t1, this), new P._HttpParser__createIncoming_closure0(t1, this), new P._HttpParser__createIncoming_closure1(t1, this), new P._HttpParser__createIncoming_closure2(t1, this), true, [P.List, P.$int]);
      this._bodyController = t2;
      t3 = this._headers;
      t2 = new P._ControllerStream(t2);
      t2.$builtinTypeInfo = [null];
      t4 = new P._Future(0, $.Zone__current, null, null, null, null, null, null);
      t4.$builtinTypeInfo = [null];
      t4 = new P._AsyncCompleter(t4);
      t4.$builtinTypeInfo = [null];
      incoming = new P._HttpIncoming(transferLength, t4, t2, false, t3, false, null, null, null, null, false);
      this._incoming = incoming;
      t1.incoming_0 = incoming;
      this._bodyPaused = true;
      this._pauseStateChanged$0();
    },
    _closeIncoming$1: function(closing) {
      var t1 = this._incoming;
      if (t1 == null)
        return;
      t1.fullBodyRead = true;
      t1.hasSubscriber = true;
      t1 = t1._dataCompleter.future;
      if (t1._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      t1._asyncComplete$1(closing);
      this._incoming = null;
      t1 = this._bodyController;
      if (t1 != null) {
        t1.close$0();
        this._bodyController = null;
      }
      this._bodyPaused = false;
      this._pauseStateChanged$0();
    },
    _closeIncoming$0: function() {
      return this._closeIncoming$1(false);
    },
    _pauseStateChanged$0: function() {
      if (this._incoming != null) {
        if (!this._bodyPaused && !this._parserCalled)
          this._parse$0();
      } else if (!this._paused && !this._parserCalled)
        this._parse$0();
    },
    _reportError$2: function(error, stackTrace) {
      var t1 = this._socketSubscription;
      if (t1 != null)
        t1.cancel$0();
      this._io$_state = 27;
      t1 = this._controller;
      if (t1._state >= 4)
        H.throwExpression(t1._badEventState$0());
      t1._addError$2(error, stackTrace);
      this._controller.close$0();
    },
    _reportError$1: function(error) {
      return this._reportError$2(error, null);
    },
    _io$_HttpParser$_$1: function(_requestParser) {
      this._controller = P.StreamController_StreamController(new P._HttpParser$__closure(this), new P._HttpParser$__closure0(this), new P._HttpParser$__closure1(this), new P._HttpParser$__closure2(this), true, P._HttpIncoming);
      this._reset$0();
    },
    $asStream: function() {
      return [P._HttpIncoming];
    },
    static: {_HttpParser$_: function(_requestParser) {
        var t1 = new P._HttpParser(false, null, null, _requestParser, null, null, null, 0, 0, [], [], [], [], null, -1, null, null, null, false, -1, null, null, null, true, false, null, null);
        t1._io$_HttpParser$_$1(_requestParser);
        return t1;
      }, _HttpParser__tokenizeFieldValue: function(headerValue) {
        var tokens, t1, start, index, t2;
        tokens = [];
        tokens.$builtinTypeInfo = [P.String];
        for (t1 = headerValue.length, start = 0, index = 0; index < t1;) {
          t2 = headerValue[index];
          if (t2 === ",") {
            tokens.push(C.JSString_methods.substring$2(headerValue, start, index));
            start = index + 1;
          } else if (t2 === " " || t2 === "\t")
            ++start;
          ++index;
        }
        tokens.push(C.JSString_methods.substring$2(headerValue, start, index));
        return tokens;
      }}
  },
  _HttpParser$__closure0: {
    "^": "Closure:55;this_0",
    call$0: function() {
      this.this_0._paused = false;
    },
    $isFunction: true
  },
  _HttpParser$__closure1: {
    "^": "Closure:55;this_1",
    call$0: function() {
      var t1 = this.this_1;
      t1._paused = true;
      t1._pauseStateChanged$0();
    },
    $isFunction: true
  },
  _HttpParser$__closure2: {
    "^": "Closure:55;this_2",
    call$0: function() {
      var t1 = this.this_2;
      t1._paused = false;
      t1._pauseStateChanged$0();
    },
    $isFunction: true
  },
  _HttpParser$__closure: {
    "^": "Closure:55;this_3",
    call$0: [function() {
      var t1 = this.this_3._socketSubscription;
      if (t1 != null)
        t1.cancel$0();
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _HttpParser__createIncoming_closure0: {
    "^": "Closure:55;box_0,this_1",
    call$0: function() {
      var t1, t2, t3;
      t1 = this.box_0.incoming_0;
      t2 = this.this_1;
      t3 = t2._incoming;
      if (t1 == null ? t3 != null : t1 !== t3)
        return;
      t2._bodyPaused = false;
      t2._pauseStateChanged$0();
    },
    $isFunction: true
  },
  _HttpParser__createIncoming_closure1: {
    "^": "Closure:55;box_0,this_2",
    call$0: function() {
      var t1, t2, t3;
      t1 = this.box_0.incoming_0;
      t2 = this.this_2;
      t3 = t2._incoming;
      if (t1 == null ? t3 != null : t1 !== t3)
        return;
      t2._bodyPaused = true;
      t2._pauseStateChanged$0();
    },
    $isFunction: true
  },
  _HttpParser__createIncoming_closure2: {
    "^": "Closure:55;box_0,this_3",
    call$0: function() {
      var t1, t2, t3;
      t1 = this.box_0.incoming_0;
      t2 = this.this_3;
      t3 = t2._incoming;
      if (t1 == null ? t3 != null : t1 !== t3)
        return;
      t2._bodyPaused = false;
      t2._pauseStateChanged$0();
    },
    $isFunction: true
  },
  _HttpParser__createIncoming_closure: {
    "^": "Closure:55;box_0,this_4",
    call$0: [function() {
      var t1, t2, t3;
      t1 = this.box_0.incoming_0;
      t2 = this.this_4;
      t3 = t2._incoming;
      if (t1 == null ? t3 != null : t1 !== t3)
        return;
      t1 = t2._socketSubscription;
      if (t1 != null)
        t1.cancel$0();
      t2._closeIncoming$1(true);
      t2._controller.close$0();
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _HttpSessionManager: {
    "^": "Object;_sessions,_sessionTimeout,_io$_head,_io$_tail,_timer",
    close$0: function() {
      return this._stopTimer$0();
    },
    _stopTimer$0: function() {
    }
  },
  _StreamSinkImpl: {
    "^": "Object;",
    add$1: [function(_, data) {
      var t1;
      if (this._isClosed)
        return;
      t1 = this.get$_controller();
      if (t1._state >= 4)
        H.throwExpression(t1._badEventState$0());
      t1._async$_add$1(data);
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "void__T1", void: true, args: [T]};
      }, this.$receiver, "_StreamSinkImpl");
    }],
    addError$2: function(error, stackTrace) {
      var t1 = this.get$_controller();
      if (t1._state >= 4)
        H.throwExpression(t1._badEventState$0());
      t1._addError$2(error, stackTrace);
      return;
    },
    addStream$1: function(stream) {
      var t1, t2, future;
      if (this._isBound)
        throw H.wrapException(P.StateError$("StreamSink is already bound to a stream"));
      this._isBound = true;
      if (this._io$_hasError)
        return this.get$done();
      t1 = new P._StreamSinkImpl_addStream_targetAddStream(this, stream);
      t2 = this._controllerInstance;
      if (t2 == null)
        return t1.call$0();
      future = this._controllerCompleter.future;
      t2.close$0();
      return future.then$1(new P._StreamSinkImpl_addStream_closure(t1));
    },
    flush$0: function() {
      var t1, future;
      if (this._isBound)
        throw H.wrapException(P.StateError$("StreamSink is bound to a stream"));
      t1 = this._controllerInstance;
      if (t1 == null)
        return P._Future$immediate(this, null);
      this._isBound = true;
      future = this._controllerCompleter.future;
      t1.close$0();
      return future.whenComplete$1(new P._StreamSinkImpl_flush_closure(this));
    },
    close$0: function() {
      if (this._isBound)
        throw H.wrapException(P.StateError$("StreamSink is bound to a stream"));
      if (!this._isClosed) {
        this._isClosed = true;
        var t1 = this._controllerInstance;
        if (t1 != null)
          t1.close$0();
        else
          this._closeTarget$0();
      }
      return this.get$done();
    },
    _closeTarget$0: function() {
      this._io$_target.close$0().then$2$onError(new P._StreamSinkImpl__closeTarget_closure(this), new P._StreamSinkImpl__closeTarget_closure0(this));
    },
    get$done: function() {
      return this._io$_doneFuture;
    },
    _completeDone$2$error$value: function(error, value) {
      var t1 = this._doneCompleter;
      if (t1 == null)
        return;
      if (error == null) {
        t1 = t1.future;
        if (t1._state !== 0)
          H.throwExpression(P.StateError$("Future already completed"));
        t1._asyncComplete$1(value);
      } else {
        this._io$_hasError = true;
        t1.completeError$1(error);
      }
      this._doneCompleter = null;
    },
    _completeDone$1$error: function(error) {
      return this._completeDone$2$error$value(error, null);
    },
    _completeDone$1$value: function(value) {
      return this._completeDone$2$error$value(null, value);
    },
    get$_controller: function() {
      if (this._isBound)
        throw H.wrapException(P.StateError$("StreamSink is bound to a stream"));
      if (this._isClosed)
        throw H.wrapException(P.StateError$("StreamSink is closed"));
      if (this._controllerInstance == null) {
        this._controllerInstance = P.StreamController_StreamController(null, null, null, null, true, H.getRuntimeTypeArgument(this, "_StreamSinkImpl", 0));
        this._controllerCompleter = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(null)), [null]);
        var t1 = this.get$_controller();
        t1.toString;
        this._io$_target.addStream$1(H.setRuntimeTypeInfo(new P._ControllerStream(t1), [null])).then$2$onError(new P._StreamSinkImpl__controller_closure(this), new P._StreamSinkImpl__controller_closure0(this));
      }
      return this._controllerInstance;
    }
  },
  _StreamSinkImpl_addStream_targetAddStream: {
    "^": "Closure:73;this_0,stream_1",
    call$0: function() {
      var t1 = this.this_0;
      return t1._io$_target.addStream$1(this.stream_1).whenComplete$1(new P._StreamSinkImpl_addStream_targetAddStream_closure(t1));
    },
    $isFunction: true
  },
  _StreamSinkImpl_addStream_targetAddStream_closure: {
    "^": "Closure:55;this_2",
    call$0: [function() {
      this.this_2._isBound = false;
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _StreamSinkImpl_addStream_closure: {
    "^": "Closure:58;targetAddStream_3",
    call$1: [function(_) {
      return this.targetAddStream_3.call$0();
    }, "call$1", null, 2, 0, null, 60, "call"],
    $isFunction: true
  },
  _StreamSinkImpl_flush_closure: {
    "^": "Closure:55;this_0",
    call$0: [function() {
      this.this_0._isBound = false;
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _StreamSinkImpl__closeTarget_closure: {
    "^": "Closure:58;this_0",
    call$1: [function(value) {
      return this.this_0._completeDone$1$value(value);
    }, "call$1", null, 2, 0, null, 14, "call"],
    $isFunction: true
  },
  _StreamSinkImpl__closeTarget_closure0: {
    "^": "Closure:58;this_1",
    call$1: [function(error) {
      return this.this_1._completeDone$1$error(error);
    }, "call$1", null, 2, 0, null, 17, "call"],
    $isFunction: true
  },
  _StreamSinkImpl__controller_closure: {
    "^": "Closure:58;this_0",
    call$1: [function(_) {
      var t1, t2;
      t1 = this.this_0;
      if (t1._isBound) {
        t2 = t1._controllerCompleter.future;
        if (t2._state !== 0)
          H.throwExpression(P.StateError$("Future already completed"));
        t2._asyncComplete$1(t1);
        t1._controllerCompleter = null;
        t1._controllerInstance = null;
      } else
        t1._closeTarget$0();
    }, "call$1", null, 2, 0, null, 60, "call"],
    $isFunction: true
  },
  _StreamSinkImpl__controller_closure0: {
    "^": "Closure:58;this_1",
    call$1: [function(error) {
      var t1 = this.this_1;
      if (t1._isBound) {
        t1._controllerCompleter.completeError$1(error);
        t1._controllerCompleter = null;
        t1._controllerInstance = null;
      } else
        t1._completeDone$1$error(error);
    }, "call$1", null, 2, 0, null, 17, "call"],
    $isFunction: true
  },
  _IOSinkImpl: {
    "^": "_StreamSinkImpl;",
    write$1: function(obj) {
      if (obj.length === 0)
        return;
      this.add$1(0, this._encoding.get$encoder().convert$1(obj));
    },
    writeAll$2: function(objects, separator) {
      objects.get$iterator(objects).moveNext$0();
      return;
    },
    $as_StreamSinkImpl: function() {
      return [[P.List, P.$int]];
    }
  },
  SecureSocket_connect_closure: {
    "^": "Closure:58;",
    call$1: function(rawSocket) {
      return P.SecureSocket_SecureSocket$_(rawSocket);
    },
    $isFunction: true
  },
  SecureSocket_secure_closure: {
    "^": "Closure:58;host_0,sendClientCertificate_1,onBadCertificate_2",
    call$1: function(detachedRaw) {
      return P.RawSecureSocket_secure(detachedRaw.$index(0, 0), null, this.host_0, this.onBadCertificate_2, this.sendClientCertificate_1, detachedRaw.$index(0, 1));
    },
    $isFunction: true
  },
  SecureSocket_secure_closure0: {
    "^": "Closure:58;completer_3",
    call$1: function(raw) {
      P.SecureSocket_SecureSocket$_(raw);
    },
    $isFunction: true
  },
  RawSecureSocket: {
    "^": "Object;"
  },
  RawSecureSocket_connect_closure: {
    "^": "Closure:58;sendClientCertificate_0,certificateName_1,onBadCertificate_2",
    call$1: function(socket) {
      return P.RawSecureSocket_secure(socket, this.certificateName_1, null, this.onBadCertificate_2, this.sendClientCertificate_0, null);
    },
    $isFunction: true
  },
  X509Certificate: {
    "^": "Object;"
  },
  _FilterStatus: {
    "^": "Object;progress,readEmpty,writeEmpty,readPlaintextNoLongerEmpty,writePlaintextNoLongerFull,readEncryptedNoLongerFull,writeEncryptedNoLongerEmpty"
  },
  _RawSecureSocket: {
    "^": "Stream;_socket,_handshakeComplete,_controller,_stream,_socketSubscription,_bufferedData,_bufferedDataIndex,address,is_server,certificateName,requestClientCertificate,requireClientCertificate,sendClientCertificate,onBadCertificate,_status,_writeEventsEnabled,_readEventsEnabled,_pauseCount,_pendingReadEvent,_socketClosedRead,_socketClosedWrite,_closedRead,_closedWrite,_closeCompleter,_filterStatus,_connectPending,_filterPending,_filterActive,_secureFilter,_filterPointer",
    onBadCertificate$1: function(arg0) {
      return this.onBadCertificate.call$1(arg0);
    },
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      this._sendWriteEvent$0();
      return this._stream.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    listen$1: function(onData) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
    },
    get$port: function() {
      return this._socket.get$port();
    },
    get$remoteAddress: function() {
      return this._socket.get$remoteAddress();
    },
    get$remotePort: function() {
      return this._socket.get$remotePort();
    },
    set$_owner: function(owner) {
      this._socket.set$_owner(owner);
    },
    close$0: function() {
      this.shutdown$1(C.SocketDirection_2);
      return this._closeCompleter.future;
    },
    _completeCloseCompleter$1: [function(dummy) {
      var t1 = this._closeCompleter.future;
      if (t1._state === 0)
        t1._asyncComplete$1(this);
    }, function() {
      return this._completeCloseCompleter$1(null);
    }, "_completeCloseCompleter$0", "call$1", "call$0", "get$_completeCloseCompleter", 0, 2, 65, 16, 130],
    _io$_close$0: function() {
      this._closedWrite = true;
      this._closedRead = true;
      this._socket.close$0().then$1(this.get$_completeCloseCompleter());
      this._socketClosedWrite = true;
      this._socketClosedRead = true;
      if (!this._filterActive)
        ;
      this._controller.close$0();
      this._status = 203;
    },
    shutdown$1: function(direction) {
      if (direction === C.SocketDirection_1 || direction === C.SocketDirection_2) {
        this._closedWrite = true;
        if (this._filterStatus.writeEmpty) {
          this._socket.shutdown$1(C.SocketDirection_1);
          this._socketClosedWrite = true;
          if (this._closedRead)
            this._io$_close$0();
        }
      }
      if (direction === C.SocketDirection_0 || direction === C.SocketDirection_2) {
        this._closedRead = true;
        this._socketClosedRead = true;
        this._socket.shutdown$1(C.SocketDirection_0);
        if (this._socketClosedWrite)
          this._io$_close$0();
      }
    },
    write$3: function(data, offset, bytes) {
      var t1, written;
      bytes.$lt(0, 0);
      offset.$lt(0, 0);
      if (this._closedWrite) {
        t1 = this._controller;
        if (t1._state >= 4)
          H.throwExpression(t1._badEventState$0());
        t1._addError$2(new P.SocketException("Writing to a closed socket", null, null, null), null);
        return 0;
      }
      if (this._status !== 202)
        return 0;
      written = this._secureFilter.get$buffers().$index(0, 1).write$3(data, offset, bytes);
      written.$gt(0, 0);
      this._filterPending = true;
      this._tryFilter$0();
      return written;
    },
    write$1: function(data) {
      return this.write$3(data, null, null);
    },
    _onBadCertificateWrapper$1: [function(certificate) {
      var result = this.onBadCertificate$1(certificate);
      if (typeof result === "boolean")
        return result;
      throw H.wrapException(P.ArgumentError$("onBadCertificate callback returned non-boolean " + H.S(result)));
    }, "call$1", "get$_onBadCertificateWrapper", 2, 0, 119, 118],
    setOption$2: function(option, enabled) {
      return this._socket.setOption$2(option, enabled);
    },
    _eventDispatcher$1: [function($event) {
      var e, stackTrace, exception, t1;
      try {
        if (J.$eq($event, C.RawSocketEvent_0)) {
          this._readSocket$0();
          this._filterPending = true;
          this._tryFilter$0();
        } else if (J.$eq($event, C.RawSocketEvent_1)) {
          this._writeSocket$0();
          this._filterPending = true;
          this._tryFilter$0();
        } else if (J.$eq($event, C.RawSocketEvent_2))
          this._closeHandler$0();
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        stackTrace = new H._StackTrace(exception, null);
        this._reportError$2(e, stackTrace);
      }

    }, "call$1", "get$_eventDispatcher", 2, 0, 131, 132],
    _doneHandler$0: [function() {
      if (this._filterStatus.readEmpty)
        this._io$_close$0();
    }, "call$0", "get$_doneHandler", 0, 0, 12],
    _reportError$2: [function(e, stackTrace) {
      var t1;
      if (this._status === 203)
        return;
      else if (this._connectPending)
        this._handshakeComplete.completeError$2(e, stackTrace);
      else {
        t1 = this._controller;
        if (t1._state >= 4)
          H.throwExpression(t1._badEventState$0());
        t1._addError$2(e, stackTrace);
      }
      this._io$_close$0();
    }, function(e) {
      return this._reportError$2(e, null);
    }, "_reportError$1", "call$2", "call$1", "get$_reportError", 2, 2, 15, 16, 2, 18],
    _closeHandler$0: function() {
      var t1 = this._status;
      if (t1 === 202) {
        if (this._closedRead)
          return;
        this._socketClosedRead = true;
        if (this._filterStatus.readEmpty) {
          this._closedRead = true;
          t1 = this._controller;
          if (t1._state >= 4)
            H.throwExpression(t1._badEventState$0());
          t1._async$_add$1(C.RawSocketEvent_2);
          if (this._socketClosedWrite)
            this._io$_close$0();
        } else {
          this._filterPending = true;
          this._tryFilter$0();
        }
      } else if (t1 === 201) {
        this._socketClosedRead = true;
        if (this._filterStatus.readEmpty)
          this._reportError$2(new P.HandshakeException("HandshakeException", "Connection terminated during handshake", null), null);
        else
          this._secureHandshake$0();
      }
    },
    _secureHandshake$0: function() {
      var e, stackTrace, exception, t1;
      try {
        this._secureFilter.handshake$0();
        this._filterStatus.writeEmpty = false;
        this._readSocket$0();
        this._writeSocket$0();
        this._filterPending = true;
        this._tryFilter$0();
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        stackTrace = new H._StackTrace(exception, null);
        this._reportError$2(e, stackTrace);
      }

    },
    _secureHandshakeCompleteHandler$0: [function() {
      this._status = 202;
      if (this._connectPending) {
        this._connectPending = false;
        P.Timer_Timer(C.Duration_0, new P._RawSecureSocket__secureHandshakeCompleteHandler_closure(this));
      }
    }, "call$0", "get$_secureHandshakeCompleteHandler", 0, 0, 12],
    _onPauseStateChange$0: [function() {
      var t1, t2;
      t1 = this._controller;
      t2 = t1._state;
      t1 = (t2 & 1) !== 0 ? t1.get$_async$_subscription().get$_isInputPaused() : (t2 & 2) === 0;
      t2 = this._pauseCount;
      if (t1)
        this._pauseCount = t2 + 1;
      else {
        t1 = t2 - 1;
        this._pauseCount = t1;
        if (t1 === 0) {
          this._scheduleReadEvent$0();
          this._sendWriteEvent$0();
        }
      }
      if (!this._socketClosedRead || !this._socketClosedWrite) {
        t1 = this._controller;
        t2 = t1._state;
        t1 = (t2 & 1) !== 0 ? t1.get$_async$_subscription().get$_isInputPaused() : (t2 & 2) === 0;
        t2 = this._socketSubscription;
        if (t1)
          t2.pause$0();
        else
          t2.resume$0();
      }
    }, "call$0", "get$_onPauseStateChange", 0, 0, 12],
    _onSubscriptionStateChange$0: [function() {
      if ((this._controller._state & 1) !== 0)
        ;
    }, "call$0", "get$_onSubscriptionStateChange", 0, 0, 12],
    _tryFilter$0: function() {
      if (this._status === 203)
        return;
      if (this._filterPending && !this._filterActive) {
        this._filterActive = true;
        this._filterPending = false;
        this._pushAllFilterStages$0().then$1(new P._RawSecureSocket__tryFilter_closure(this)).catchError$1(this.get$_reportError());
      }
    },
    _readSocketOrBufferedData$1: [function(bytes) {
      if (!this._socketClosedRead)
        return this._socket.read$1(bytes);
      else
        return;
    }, "call$1", "get$_readSocketOrBufferedData", 2, 0, 133],
    _readSocket$0: function() {
      if (this._status === 203)
        return;
      this._secureFilter.get$buffers().$index(0, 2).writeFromSource$1(this.get$_readSocketOrBufferedData()).$gt(0, 0);
      this._socket.set$readEventsEnabled(false);
    },
    _writeSocket$0: function() {
      if (this._socketClosedWrite)
        return;
      this._secureFilter.get$buffers().$index(0, 3).readToSocket$1(this._socket);
    },
    _scheduleReadEvent$0: function() {
      if (!this._pendingReadEvent)
        if (this._readEventsEnabled)
          if (this._pauseCount === 0)
            var t1 = false;
          else
            t1 = false;
        else
          t1 = false;
      else
        t1 = false;
      if (t1) {
        this._pendingReadEvent = true;
        P.Timer_Timer(C.Duration_0, this.get$_sendReadEvent());
      }
    },
    _sendReadEvent$0: [function() {
      this._pendingReadEvent = false;
      if (this._status !== 203)
        if (this._readEventsEnabled)
          if (this._pauseCount === 0)
            var t1 = false;
          else
            t1 = false;
        else
          t1 = false;
      else
        t1 = false;
      if (t1) {
        t1 = this._controller;
        if (t1._state >= 4)
          H.throwExpression(t1._badEventState$0());
        t1._async$_add$1(C.RawSocketEvent_0);
        this._scheduleReadEvent$0();
      }
    }, "call$0", "get$_sendReadEvent", 0, 0, 55],
    _sendWriteEvent$0: function() {
      if (!this._closedWrite)
        if (this._writeEventsEnabled)
          if (this._pauseCount === 0)
            var t1 = false;
          else
            t1 = false;
        else
          t1 = false;
      else
        t1 = false;
      if (t1) {
        this._writeEventsEnabled = false;
        t1 = this._controller;
        if (t1._state >= 4)
          H.throwExpression(t1._badEventState$0());
        t1._async$_add$1(C.RawSocketEvent_1);
      }
    },
    _pushAllFilterStages$0: function() {
      var wasInHandshake, args, bufs, i, t1, t2, t3;
      wasInHandshake = this._status !== 202;
      args = Array(10);
      args[0] = this._filterPointer;
      args[1] = wasInHandshake;
      bufs = this._secureFilter.get$buffers();
      for (i = 0; i < 4; ++i) {
        t1 = 2 * i;
        t2 = t1 + 2;
        t3 = bufs.$index(0, i).get$start();
        if (t2 >= 10)
          return H.ioore(args, t2);
        args[t2] = t3;
        t1 += 3;
        t3 = bufs.$index(0, i).get$end();
        if (t1 >= 10)
          return H.ioore(args, t1);
        args[t1] = t3;
      }
      return P._IOService_dispatch(38, args).then$1(new P._RawSecureSocket__pushAllFilterStages_closure(this, wasInHandshake, bufs));
    },
    _RawSecureSocket$11: function(address, requestedPort, certificateName, is_server, _socket, _socketSubscription, _bufferedData, requestClientCertificate, requireClientCertificate, sendClientCertificate, onBadCertificate) {
      var e, s, t1, t2, t3, t4, t5, exception;
      t1 = this.get$_onSubscriptionStateChange();
      t2 = this.get$_onPauseStateChange();
      t3 = this.get$_onPauseStateChange();
      t3 = P.StreamController_StreamController(this.get$_onSubscriptionStateChange(), t1, t2, t3, true, P.RawSocketEvent);
      this._controller = t3;
      this._stream = H.setRuntimeTypeInfo(new P._ControllerStream(t3), [null]);
      this._secureFilter.init$0();
      this._filterPointer = this._secureFilter._pointer$0();
      this._secureFilter.registerHandshakeCompleteCallback$1(this.get$_secureHandshakeCompleteHandler());
      this._secureFilter.registerBadCertificateCallback$1(this.get$_onBadCertificateWrapper());
      t1 = this._socket;
      t1.set$readEventsEnabled(true);
      t1.set$writeEventsEnabled(false);
      t2 = this.get$_eventDispatcher();
      t3 = this.get$_reportError();
      this._socketSubscription = t1.listen$3$onDone$onError(t2, this.get$_doneHandler(), t3);
      try {
        t1 = this._secureFilter;
        t2 = this.address;
        t3 = t2.get$host();
        t2 = t2.get$_in_addr();
        t4 = this.get$port();
        t5 = this.requestClientCertificate || this.requireClientCertificate;
        t1.connect$8(t3, t2, t4, this.is_server, this.certificateName, t5, this.requireClientCertificate, this.sendClientCertificate);
        this._secureHandshake$0();
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        this._reportError$2(e, s);
      }

    },
    $asStream: function() {
      return [P.RawSocketEvent];
    },
    static: {"^": "_RawSecureSocket_HANDSHAKE,_RawSecureSocket_CONNECTED,_RawSecureSocket_CLOSED,_RawSecureSocket_READ_PLAINTEXT,_RawSecureSocket_WRITE_PLAINTEXT,_RawSecureSocket_READ_ENCRYPTED,_RawSecureSocket_WRITE_ENCRYPTED,_RawSecureSocket_NUM_BUFFERS", _RawSecureSocket$: function(address, requestedPort, certificateName, is_server, _socket, _socketSubscription, _bufferedData, requestClientCertificate, requireClientCertificate, sendClientCertificate, onBadCertificate) {
        var t1 = P._RawSecureSocket;
        t1 = new P._RawSecureSocket(_socket, H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(t1)), [t1]), null, null, _socketSubscription, _bufferedData, 0, address, is_server, certificateName, requestClientCertificate, requireClientCertificate, sendClientCertificate, onBadCertificate, 201, true, true, 0, false, false, false, false, false, H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(null)), [null]), new P._FilterStatus(false, true, true, false, false, false, false), true, false, false, P._SecureFilter__SecureFilter(), null);
        t1._RawSecureSocket$11(address, requestedPort, certificateName, is_server, _socket, _socketSubscription, _bufferedData, requestClientCertificate, requireClientCertificate, sendClientCertificate, onBadCertificate);
        return t1;
      }, _RawSecureSocket__verifyFields: function(host, requestedPort, certificateName, is_server, requestClientCertificate, requireClientCertificate, sendClientCertificate, onBadCertificate) {
        if (typeof host !== "string" && true)
          throw H.wrapException(P.ArgumentError$("host is not a String or an InternetAddress"));
        if (typeof requestedPort !== "number" || Math.floor(requestedPort) !== requestedPort)
          throw H.wrapException(P.ArgumentError$("requestedPort is not an int"));
        if (requestedPort < 0 || requestedPort > 65535)
          throw H.wrapException(P.ArgumentError$("requestedPort is not in the range 0..65535"));
        if (is_server)
          throw H.wrapException(P.ArgumentError$("certificateName is null on a server"));
        if (!onBadCertificate.$isFunction)
          throw H.wrapException(P.ArgumentError$("onBadCertificate is not null or a Function"));
      }}
  },
  _RawSecureSocket__secureHandshakeCompleteHandler_closure: {
    "^": "Closure:55;this_0",
    call$0: [function() {
      var t1, t2;
      t1 = this.this_0;
      t2 = t1._handshakeComplete.future;
      if (t2._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      t2._asyncComplete$1(t1);
      return;
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _RawSecureSocket__tryFilter_closure: {
    "^": "Closure:58;this_0",
    call$1: function($status) {
      var t1, t2;
      t1 = this.this_0;
      t1._filterStatus = $status;
      t1._filterActive = false;
      if (t1._status === 203) {
        t1._secureFilter.destroy$0();
        t1._secureFilter = null;
        return;
      }
      t1._socket.set$readEventsEnabled(true);
      if (t1._filterStatus.writeEmpty && t1._closedWrite && !t1._socketClosedWrite) {
        t1.shutdown$1(C.SocketDirection_1);
        if (t1._status === 203)
          return;
      }
      if (t1._filterStatus.readEmpty && t1._socketClosedRead && !t1._closedRead) {
        if (t1._status === 201) {
          t1._secureFilter.handshake$0();
          if (t1._status === 201)
            throw H.wrapException(P.HandshakeException$("Connection terminated during handshake", null));
        }
        t1._closeHandler$0();
      }
      if (t1._status === 203)
        return;
      t2 = t1._filterStatus;
      if (t2.progress) {
        t1._filterPending = true;
        if (t2.writePlaintextNoLongerFull)
          t1._sendWriteEvent$0();
        if (t1._filterStatus.readEncryptedNoLongerFull)
          t1._readSocket$0();
        if (t1._filterStatus.writeEncryptedNoLongerEmpty)
          t1._writeSocket$0();
        if (t1._filterStatus.readPlaintextNoLongerEmpty)
          t1._scheduleReadEvent$0();
        if (t1._status === 201)
          t1._secureHandshake$0();
      }
      t1._tryFilter$0();
    },
    $isFunction: true
  },
  _RawSecureSocket__pushAllFilterStages_closure: {
    "^": "Closure:58;this_0,wasInHandshake_1,bufs_2",
    call$1: function(response) {
      var t1, t2, $status, t3, t4, buffer, new_start, new_end;
      response.get$length(response);
      t1 = new P._RawSecureSocket__pushAllFilterStages__start(response);
      t2 = new P._RawSecureSocket__pushAllFilterStages__end(response);
      $status = new P._FilterStatus(false, true, true, false, false, false, false);
      t3 = this.bufs_2;
      t4 = t3.$index(0, 1);
      t4.get$isEmpty(t4);
      $status.writeEmpty = false;
      if (this.wasInHandshake_1)
        $status.writeEmpty = false;
      t4 = t3.$index(0, 2);
      t4.get$isEmpty(t4);
      $status.readEmpty = false;
      buffer = t3.$index(0, 1);
      new_start = t1.call$1(1);
      J.$eq(new_start, buffer.get$start());
      $status.progress = true;
      buffer.get$free();
      buffer.set$start(new_start);
      buffer = t3.$index(0, 2);
      new_start = t1.call$1(2);
      J.$eq(new_start, buffer.get$start());
      $status.progress = true;
      buffer.get$free();
      buffer.set$start(new_start);
      buffer = t3.$index(0, 3);
      new_end = t2.call$1(3);
      J.$eq(new_end, buffer.get$end());
      $status.progress = true;
      buffer.get$length(buffer);
      buffer.set$end(new_end);
      buffer = t3.$index(0, 0);
      new_end = t2.call$1(0);
      J.$eq(new_end, buffer.get$end());
      $status.progress = true;
      buffer.get$length(buffer);
      buffer.set$end(new_end);
      return $status;
    },
    $isFunction: true
  },
  _RawSecureSocket__pushAllFilterStages__start: {
    "^": "Closure:134;response_3",
    call$1: function(index) {
      return this.response_3.$index(0, 2 * index);
    },
    $isFunction: true
  },
  _RawSecureSocket__pushAllFilterStages__end: {
    "^": "Closure:134;response_4",
    call$1: function(index) {
      return this.response_4.$index(0, 2 * index + 1);
    },
    $isFunction: true
  },
  TlsException: {
    "^": "Object;message<",
    toString$0: function(_) {
      var sb, t1;
      sb = P.StringBuffer$("");
      sb.write$1(this.type);
      t1 = this.message;
      if (t1.length !== 0)
        sb.write$1(": " + t1);
      return sb._contents;
    },
    $isTlsException: true
  },
  HandshakeException: {
    "^": "TlsException;type,message,osError",
    $isHandshakeException: true,
    static: {HandshakeException$: function(message, osError) {
        return new P.HandshakeException("HandshakeException", message, osError);
      }}
  },
  _ServiceObject: {
    "^": "Object;",
    get$_serviceId: function() {
      var t1 = this.io$_ServiceObject$__serviceId;
      if (t1 === 0) {
        t1 = $._nextServiceId;
        $._nextServiceId = t1 + 1;
        this.io$_ServiceObject$__serviceId = t1;
      }
      return t1;
    }
  },
  SocketDirection: {
    "^": "Object;_io$_value",
    static: {"^": "SocketDirection_RECEIVE,SocketDirection_SEND,SocketDirection_BOTH"}
  },
  SocketOption: {
    "^": "Object;_io$_value",
    static: {"^": "SocketOption_TCP_NODELAY,SocketOption__IP_MULTICAST_LOOP,SocketOption__IP_MULTICAST_HOPS,SocketOption__IP_MULTICAST_IF,SocketOption__IP_BROADCAST"}
  },
  RawSocketEvent: {
    "^": "Object;_io$_value",
    toString$0: function(_) {
      var t1, t2;
      t1 = ["RawSocketEvent:READ", "RawSocketEvent:WRITE", "RawSocketEvent:READ_CLOSED", "RawSocketEvent:CLOSED"];
      t2 = this._io$_value;
      if (t2 >= 4)
        return H.ioore(t1, t2);
      return t1[t2];
    },
    static: {"^": "RawSocketEvent_READ,RawSocketEvent_WRITE,RawSocketEvent_READ_CLOSED,RawSocketEvent_CLOSED"}
  },
  RawSocket: {
    "^": "Object;"
  },
  Socket: {
    "^": "Object;"
  },
  SocketException: {
    "^": "Object;message<,osError,address,port<",
    toString$0: function(_) {
      var sb, t1;
      sb = P.StringBuffer$("");
      sb.write$1("SocketException");
      t1 = this.message;
      if (t1.length !== 0)
        sb.write$1(": " + t1);
      return sb._contents;
    },
    $isSocketException: true
  }
}],
["dart.isolate", "dart:isolate", , P, {
  "^": "",
  Capability: {
    "^": "Object;",
    $isCapability: true
  }
}],
["dart.math", "dart:math", , P, {
  "^": "",
  max: [function(a, b) {
    if (typeof a !== "number")
      throw H.wrapException(P.ArgumentError$(a));
    if (typeof b !== "number")
      throw H.wrapException(P.ArgumentError$(b));
    if (a > b)
      return a;
    if (a < b)
      return b;
    if (typeof b === "number") {
      if (typeof a === "number")
        if (a === 0)
          return a + b;
      if (C.JSDouble_methods.get$isNaN(b))
        return b;
      return a;
    }
    if (b === 0 && C.JSNumber_methods.get$isNegative(a))
      return b;
    return a;
  }, "call$2", "max$closure", 4, 0, 53, 43, 44],
  _JSRandom: {
    "^": "Object;",
    nextInt$1: function(max) {
      if (max <= 0 || max > 4294967296)
        throw H.wrapException(P.RangeError$("max must be in range 0 < max \u2264 2^32, was " + max));
      return Math.random() * max >>> 0;
    }
  },
  _Random: {
    "^": "Object;_lo,_hi",
    _nextState$0: function() {
      var t1, tmpHi, tmpHiLo, tmpLo, tmpLoLo, newLo;
      t1 = this._lo;
      tmpHi = 4294901760 * t1;
      tmpHiLo = (tmpHi & 4294967295) >>> 0;
      tmpLo = 55905 * t1;
      tmpLoLo = (tmpLo & 4294967295) >>> 0;
      newLo = tmpLoLo + tmpHiLo + this._hi;
      t1 = (newLo & 4294967295) >>> 0;
      this._lo = t1;
      this._hi = (C.JSInt_methods._tdivFast$1(tmpLo - tmpLoLo + (tmpHi - tmpHiLo) + (newLo - t1), 4294967296) & 4294967295) >>> 0;
    },
    nextInt$1: function(max) {
      var t1, rnd32, result;
      if (max <= 0 || max > 4294967296)
        throw H.wrapException(P.RangeError$("max must be in range 0 < max \u2264 2^32, was " + max));
      t1 = max - 1;
      if ((max & t1) >>> 0 === 0) {
        this._nextState$0();
        return (this._lo & t1) >>> 0;
      }
      do {
        this._nextState$0();
        rnd32 = this._lo;
        result = rnd32 % max;
      } while (rnd32 - result + max >= 4294967296);
      return result;
    },
    _Random$1: function(seed) {
      var empty_seed, low, high, tmplow, low0, t1, t2, t3;
      if (typeof seed !== "number")
        return seed.$lt();
      empty_seed = seed < 0 ? -1 : 0;
      do {
        low = (seed & 4294967295) >>> 0;
        seed = C.JSInt_methods._tdivFast$1(seed - low, 4294967296);
        high = (seed & 4294967295) >>> 0;
        seed = C.JSInt_methods._tdivFast$1(seed - high, 4294967296);
        tmplow = ((~low & 4294967295) >>> 0) + (low << 21 >>> 0);
        low0 = (tmplow & 4294967295) >>> 0;
        high = (~high >>> 0) + ((high << 21 | low >>> 11) >>> 0) + C.JSInt_methods._tdivFast$1(tmplow - low0, 4294967296) & 4294967295;
        tmplow = ((low0 ^ (low0 >>> 24 | high << 8)) >>> 0) * 265;
        low = (tmplow & 4294967295) >>> 0;
        high = ((high ^ high >>> 24) >>> 0) * 265 + C.JSInt_methods._tdivFast$1(tmplow - low, 4294967296) & 4294967295;
        tmplow = ((low ^ (low >>> 14 | high << 18)) >>> 0) * 21;
        low = (tmplow & 4294967295) >>> 0;
        high = ((high ^ high >>> 14) >>> 0) * 21 + C.JSInt_methods._tdivFast$1(tmplow - low, 4294967296) & 4294967295;
        low = (low ^ (low >>> 28 | high << 4)) >>> 0;
        high = (high ^ high >>> 28) >>> 0;
        tmplow = (low << 31 >>> 0) + low;
        low0 = (tmplow & 4294967295) >>> 0;
        t1 = C.JSInt_methods._tdivFast$1(tmplow - low0, 4294967296);
        tmplow = this._lo * 1037;
        t2 = (tmplow & 4294967295) >>> 0;
        this._lo = t2;
        t3 = (this._hi * 1037 + C.JSInt_methods._tdivFast$1(tmplow - t2, 4294967296) & 4294967295) >>> 0;
        this._hi = t3;
        t2 = (t2 ^ low0) >>> 0;
        this._lo = t2;
        t1 = (t3 ^ high + ((high << 31 | low >>> 1) >>> 0) + t1 & 4294967295) >>> 0;
        this._hi = t1;
      } while (seed !== empty_seed);
      if (t1 === 0 && t2 === 0)
        this._lo = 23063;
      this._nextState$0();
      this._nextState$0();
      this._nextState$0();
      this._nextState$0();
    },
    static: {"^": "_Random__POW2_53_D,_Random__POW2_27_D,_Random__MASK32", _Random$: function(seed) {
        var t1 = new P._Random(0, 0);
        t1._Random$1(seed);
        return t1;
      }}
  }
}],
["dart.typed_data.implementation", "dart:_native_typed_data", , H, {
  "^": "",
  _ensureNativeList: function(list) {
    var t1, t2, result, i, t3;
    t1 = J.getInterceptor(list);
    if (!!t1.$isJSIndexable)
      return list;
    t2 = t1.get$length(list);
    if (typeof t2 !== "number")
      return H.iae(t2);
    result = Array(t2);
    result.fixed$length = init;
    t2 = result.length;
    i = 0;
    while (true) {
      t3 = t1.get$length(list);
      if (typeof t3 !== "number")
        return H.iae(t3);
      if (!(i < t3))
        break;
      t3 = t1.$index(list, i);
      if (i >= t2)
        return H.ioore(result, i);
      result[i] = t3;
      ++i;
    }
    return result;
  },
  NativeByteBuffer: {
    "^": "Interceptor;",
    get$runtimeType: function(receiver) {
      return C.Type_wAg;
    },
    asUint8List$2: function(receiver, offsetInBytes, $length) {
      var t1 = $length == null;
      if (!t1 && (typeof $length !== "number" || Math.floor($length) !== $length))
        H.throwExpression(P.ArgumentError$("Invalid view length " + H.S($length)));
      return t1 ? new Uint8Array(receiver, offsetInBytes) : new Uint8Array(receiver, offsetInBytes, $length);
    },
    $isByteBuffer: true,
    "%": "ArrayBuffer"
  },
  NativeTypedData: {
    "^": "Interceptor;buffer=,lengthInBytes:byteLength=,offsetInBytes:byteOffset=",
    _invalidIndex$2: function(receiver, index, $length) {
      var t1 = J.getInterceptor$n(index);
      if (t1.$lt(index, 0) || t1.$ge(index, $length))
        throw H.wrapException(P.RangeError$range(index, 0, $length));
      else
        throw H.wrapException(P.ArgumentError$("Invalid list index " + H.S(index)));
    },
    _checkIndex$2: function(receiver, index, $length) {
      if (index >>> 0 !== index || index >= $length)
        this._invalidIndex$2(receiver, index, $length);
    },
    _checkSublistArguments$3: function(receiver, start, end, $length) {
      var t1 = $length + 1;
      this._checkIndex$2(receiver, start, t1);
      this._checkIndex$2(receiver, end, t1);
      if (typeof start !== "number")
        return start.$gt();
      if (typeof end !== "number")
        return H.iae(end);
      if (start > end)
        throw H.wrapException(P.RangeError$range(start, 0, end));
      return end;
    },
    "%": ";ArrayBufferView;NativeTypedArray|NativeTypedArray_ListMixin|NativeTypedArray_ListMixin_FixedLengthListMixin|NativeTypedArrayOfInt"
  },
  NativeUint8List: {
    "^": "NativeTypedArrayOfInt;",
    get$runtimeType: function(receiver) {
      return C.Type_6L0;
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      return new Uint8Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isUint8List: true,
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: function() {
      return [P.$int];
    },
    "%": ";Uint8Array"
  },
  NativeTypedArray: {
    "^": "NativeTypedData;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $isJavaScriptIndexingBehavior: true,
    $isJSIndexable: true
  },
  NativeTypedArrayOfInt: {
    "^": "NativeTypedArray_ListMixin_FixedLengthListMixin;",
    $indexSet: function(receiver, index, value) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      receiver[index] = value;
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      var t1, count, sourceLength, source;
      if (!!J.getInterceptor(iterable).$isNativeTypedArrayOfInt) {
        t1 = receiver.length + 1;
        if (start >>> 0 !== start || start >= t1)
          this._invalidIndex$2(receiver, start, t1);
        if (end >>> 0 !== end || end >= t1)
          this._invalidIndex$2(receiver, end, t1);
        if (start > end)
          H.throwExpression(P.RangeError$range(start, 0, end));
        count = end - start;
        if (skipCount < 0)
          H.throwExpression(P.ArgumentError$(skipCount));
        sourceLength = iterable.length;
        if (sourceLength - skipCount < count)
          H.throwExpression(P.StateError$("Not enough elements"));
        source = skipCount !== 0 || sourceLength !== count ? iterable.subarray(skipCount, skipCount + count) : iterable;
        receiver.set(source, start);
        return;
      }
      P.ListMixin.prototype.setRange$4.call(this, receiver, start, end, iterable, skipCount);
    },
    setRange$3: function($receiver, start, end, iterable) {
      return this.setRange$4($receiver, start, end, iterable, 0);
    },
    $isNativeTypedArrayOfInt: true,
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: function() {
      return [P.$int];
    }
  },
  NativeTypedArray_ListMixin: {
    "^": "NativeTypedArray+ListMixin;",
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: function() {
      return [P.$int];
    }
  },
  NativeTypedArray_ListMixin_FixedLengthListMixin: {
    "^": "NativeTypedArray_ListMixin+FixedLengthListMixin;"
  }
}],
["dart2js._js_primitives", "dart:_js_primitives", , H, {
  "^": "",
  printString: function(string) {
    if (typeof dartPrint == "function") {
      dartPrint(string);
      return;
    }
    if (typeof console == "object" && typeof console.log != "undefined") {
      console.log(string);
      return;
    }
    if (typeof window == "object")
      return;
    if (typeof print == "function") {
      print(string);
      return;
    }
    throw "Unable to print message: " + String(string);
  }
}],
["frame", "package:stack_trace/src/frame.dart", , S, {
  "^": "",
  Frame: {
    "^": "Object;uri<,line<,column<,member<",
    get$isCore: function() {
      return this.uri.get$scheme() === "dart";
    },
    get$library: function() {
      return $.get$context().prettyUri$1(this.uri);
    },
    get$$package: function() {
      var t1 = this.uri;
      if (t1.get$scheme() !== "package")
        return;
      return C.JSArray_methods.get$first(t1.get$path().split("/"));
    },
    get$location: function() {
      var t1, t2;
      t1 = this.line;
      if (t1 == null)
        return $.get$context().prettyUri$1(this.uri);
      t2 = this.column;
      if (t2 == null)
        return $.get$context().prettyUri$1(this.uri) + " " + H.S(t1);
      return $.get$context().prettyUri$1(this.uri) + " " + H.S(t1) + ":" + H.S(t2);
    },
    toString$0: function(_) {
      return this.get$location() + " in " + H.S(this.member);
    },
    static: {"^": "Frame__uriRegExp,Frame__windowsRegExp", Frame_Frame$parseVM: function(frame) {
        var match, t1, member, uri, line, columnMatch, column;
        if (J.$eq(frame, "..."))
          return new S.Frame(P.Uri_Uri(null, null, null, null, null, null, null, "", ""), null, null, "...");
        match = $.get$_vmFrame().firstMatch$1(frame);
        if (match == null)
          throw H.wrapException(P.FormatException$("Couldn't parse VM stack trace line '" + H.S(frame) + "'.", null, null));
        t1 = match._match;
        if (1 >= t1.length)
          return H.ioore(t1, 1);
        member = J.replaceAll$2$s(t1[1], "<anonymous closure>", "<fn>");
        if (2 >= t1.length)
          return H.ioore(t1, 2);
        uri = P.Uri_parse(t1[2]);
        if (3 >= t1.length)
          return H.ioore(t1, 3);
        line = H.Primitives_parseInt(t1[3], null, null);
        if (4 >= t1.length)
          return H.ioore(t1, 4);
        columnMatch = t1[4];
        column = columnMatch != null ? H.Primitives_parseInt(columnMatch, null, null) : null;
        return new S.Frame(uri, line, column, member);
      }, Frame_Frame$parseV8: function(frame) {
        var match, t1, t2, t3, t4;
        match = $.get$_v8Frame().firstMatch$1(frame);
        if (match == null)
          throw H.wrapException(P.FormatException$("Couldn't parse V8 stack trace line '" + H.S(frame) + "'.", null, null));
        t1 = new S.Frame_Frame$parseV8_parseLocation(frame);
        t2 = match._match;
        t3 = t2.length;
        if (2 >= t3)
          return H.ioore(t2, 2);
        t4 = t2[2];
        if (t4 != null) {
          t2 = J.replaceAll$2$s(t2[1], "<anonymous>", "<fn>");
          return t1.call$2(t4, H.stringReplaceAllUnchecked(t2, "Anonymous function", "<fn>"));
        } else {
          if (3 >= t3)
            return H.ioore(t2, 3);
          return t1.call$2(t2[3], "<fn>");
        }
      }, Frame__uriOrPathToUri: function(uriOrPath) {
        var t1 = J.getInterceptor$asx(uriOrPath);
        if (t1.contains$1(uriOrPath, $.get$Frame__uriRegExp()) === true)
          return P.Uri_parse(uriOrPath);
        else if (t1.contains$1(uriOrPath, $.get$Frame__windowsRegExp()) === true)
          return P.Uri_Uri$file(uriOrPath, true);
        else if (t1.startsWith$1(uriOrPath, "/"))
          return P.Uri_Uri$file(uriOrPath, false);
        if (t1.contains$1(uriOrPath, "\\") === true)
          return $.get$windows().toUri$1(uriOrPath);
        return P.Uri_parse(uriOrPath);
      }}
  },
  Frame_Frame$parseV8_parseLocation: {
    "^": "Closure:56;frame_0",
    call$2: function($location, member) {
      var t1, evalMatch, t2, urlMatch, t3;
      t1 = $.get$_v8EvalLocation();
      evalMatch = t1.firstMatch$1($location);
      for (; evalMatch != null;) {
        t2 = evalMatch._match;
        if (1 >= t2.length)
          return H.ioore(t2, 1);
        $location = t2[1];
        evalMatch = t1.firstMatch$1($location);
      }
      urlMatch = $.get$_v8UrlLocation().firstMatch$1($location);
      if (urlMatch == null)
        throw H.wrapException(P.FormatException$("Couldn't parse V8 stack trace line '" + H.S(this.frame_0) + "'.", null, null));
      t1 = urlMatch._match;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      t2 = S.Frame__uriOrPathToUri(t1[1]);
      if (2 >= t1.length)
        return H.ioore(t1, 2);
      t3 = H.Primitives_parseInt(t1[2], null, null);
      if (3 >= t1.length)
        return H.ioore(t1, 3);
      return new S.Frame(t2, t3, H.Primitives_parseInt(t1[3], null, null), member);
    },
    $isFunction: true
  }
}],
["hetima", "package:hetima/hetima.dart", , V, {
  "^": "",
  PeerIdCreator_createPeerid: function(id) {
    var t1, output, i, i0, t2;
    t1 = Array(20);
    t1.fixed$length = init;
    output = H.setRuntimeTypeInfo(t1, [P.$int]);
    for (i = 0; i < 20; ++i)
      output[i] = $.get$PeerIdCreator__random().nextInt$1(255);
    t1 = id.length;
    i = 0;
    while (true) {
      if (!(i < 5 && i < t1))
        break;
      i0 = i + 1;
      if (i >= t1)
        H.throwExpression(P.RangeError$value(i));
      t2 = id.charCodeAt(i);
      if (i0 >= 20)
        return H.ioore(output, i0);
      output[i0] = t2;
      i = i0;
    }
    return output;
  },
  HttpUrlDecoder_queryMap: function(query) {
    var ret, pats, t1, pat, t2, pa, key;
    ret = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
    if (query.length === 0 || !J.contains$1$asx(query, "="))
      return P.LinkedHashMap_LinkedHashMap$_empty(null, null);
    pats = query.split("&");
    for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(pats, pats.length, 0, null), [H.getTypeArgumentByIndex(pats, 0)]); t1.moveNext$0();) {
      pat = t1._current;
      t2 = J.getInterceptor$s(pat);
      pa = t2.split$1(pat, "=");
      if (0 >= pa.length)
        return H.ioore(pa, 0);
      key = pa[0];
      ret.$indexSet(0, key, t2.substring$1(pat, J.$add$ns(J.get$length$asx(key), 1)));
    }
    return ret;
  },
  ArrayBuilder: {
    "^": "HetimaBuilder;_max,_buffer8,_hetima$_length,completer,mGetByteFutreList,completerFin,_immutable",
    update$1: function(plusLength) {
      var t1, t2, nextMax, next, t3, i, t4;
      t1 = this._hetima$_length;
      if (typeof plusLength !== "number")
        return H.iae(plusLength);
      t1 += plusLength;
      t2 = this._max;
      if (t1 < t2)
        return;
      else {
        nextMax = t1 + t2;
        if (typeof nextMax !== "number" || Math.floor(nextMax) !== nextMax)
          H.throwExpression(P.ArgumentError$("Invalid length " + H.S(nextMax)));
        next = new Uint8Array(nextMax);
        for (t1 = this._hetima$_length, t2 = this._buffer8, t3 = next.length, i = 0; i < t1; ++i) {
          if (i >= t2.length)
            return H.ioore(t2, i);
          t4 = t2[i];
          if (i >= t3)
            return H.ioore(next, i);
          next[i] = t4;
        }
        this._buffer8 = null;
        this._buffer8 = next;
        this._max = nextMax;
      }
    },
    appendByte$1: function(v) {
      var t1, t2, removeList, t3, f, t4, t5;
      if (this._immutable)
        return;
      this.update$1(1);
      t1 = this._buffer8;
      t2 = this._hetima$_length;
      if (t2 >= t1.length)
        return H.ioore(t1, t2);
      t1[t2] = v;
      this._hetima$_length = t2 + 1;
      removeList = [];
      t1 = this.mGetByteFutreList;
      t2 = new H.ListIterator(t1, t1.length, 0, null);
      t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(t1, 0)];
      t3 = this.completer.future;
      for (; t2.moveNext$0();) {
        f = t2._current;
        if (t3._state === 0) {
          f.get$completerResult();
          t4 = true;
        } else
          t4 = false;
        if (t4)
          f.get$completerResult().add$1(0, v);
        f.get$completerResult();
        t4 = f.get$completerResultLength();
        t5 = f.get$completerResult();
        t4.$le(0, t5.get$length(t5));
      }
      t2 = new H.ListIterator(removeList, removeList.length, 0, null);
      t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(removeList, 0)];
      for (; t2.moveNext$0();)
        C.JSArray_methods.remove$1(t1, t2._current);
    },
    appendString$1: function(text) {
      var code, i;
      code = C.Utf8Codec_false.get$encoder().convert$1(text);
      this.update$1(code.length);
      for (i = 0; i < code.length; ++i)
        this.appendByte$1(code[i]);
    },
    appendUint8List$3: function(buffer, index, $length) {
      var t1, i;
      this.update$1($length);
      if (typeof $length !== "number")
        return H.iae($length);
      t1 = J.getInterceptor$asx(buffer);
      i = 0;
      for (; i < $length; ++i)
        this.appendByte$1(t1.$index(buffer, index + i));
    },
    appendIntList$3: function(buffer, index, $length) {
      var i, t1;
      this.update$1($length);
      for (i = 0; i < $length; ++i) {
        t1 = index + i;
        if (t1 >= buffer.length)
          return H.ioore(buffer, t1);
        this.appendByte$1(buffer[t1]);
      }
    },
    toList$0: function(_) {
      return J.sublist$2$ax(this._buffer8, 0, this._hetima$_length);
    }
  },
  HetimaBuilder: {
    "^": "Object;"
  },
  HetiTest: {
    "^": "Object;ticketMap,endNum,_id",
    test$2: function(id, timeout_ms) {
      var t1, t2, ticket;
      t1 = this.ticketMap;
      if (t1.containsKey$1(id))
        throw H.wrapException(P.Error$());
      t2 = P.bool;
      t2 = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(t2)), [t2]);
      ticket = new V.HetiTestTicket(t2, "", true, false, "");
      ticket._id = id;
      t1.$indexSet(0, id, ticket);
      t2.future.then$1(new V.HetiTest_test_closure(this));
      return ticket;
    }
  },
  HetiTest_test_closure: {
    "^": "Closure:71;this_0",
    call$1: [function(r) {
      var t1, t2, t3, line;
      t1 = this.this_0;
      t2 = ++t1.endNum;
      t3 = t1.ticketMap;
      if (t3._collection$_length === t2) {
        P.print("################");
        P.print("### " + t1._id);
        for (t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t3), [H.getTypeArgumentByIndex(t3, 0)]), t2 = t1._map, t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterator(t2, t2._modifications, null, null), [H.getTypeArgumentByIndex(t1, 0)]), t1._cell = t1._map._first; t1.moveNext$0();) {
          line = H.S(J.toString$0(t3.$index(0, t1._collection$_current)));
          t2 = $.printToZone;
          if (t2 == null)
            H.printString(line);
          else
            t2.call$1(line);
        }
      }
    }, "call$1", null, 2, 0, null, 135, "call"],
    $isFunction: true
  },
  HetiTestTicket: {
    "^": "Object;_completer,_id,_hetima$_result,_isFin,_hetima$_message",
    assertTrue$2: function(message, isPassed) {
      if (!isPassed && this._hetima$_result) {
        this._hetima$_result = false;
        this._hetima$_message = message;
      }
    },
    toString$0: function(_) {
      var t1, t2;
      t1 = !this._isFin && this._hetima$_result;
      t2 = this._id;
      if (t1)
        return "[" + t2 + "]TIMEOUT";
      else {
        t1 = "[" + t2 + "]";
        return t1 + (this._hetima$_result ? "OK" : "NG") + ":" + this._hetima$_message;
      }
    },
    fin$0: function() {
      var t1, t2;
      this._isFin = true;
      t1 = this._completer.future;
      if (t1._state === 0) {
        t2 = this._hetima$_result;
        t1._asyncComplete$1(t2);
      }
    }
  },
  Bdecoder: {
    "^": "Object;index",
    decodeBenObject$1: function(buffer) {
      var t1, t2, t3, ret;
      t1 = this.index;
      t2 = buffer.length;
      if (t1 >>> 0 !== t1 || t1 >= t2)
        return H.ioore(buffer, t1);
      t3 = buffer[t1];
      if (48 <= t3 && t3 <= 57)
        return this.decodeBytes$1(buffer);
      else if (105 === t3)
        return this.decodeNumber$1(buffer);
      else if (108 === t3) {
        ++t1;
        this.index = t1;
        if (t3 !== 108)
          H.throwExpression(V.BencodeParseError$("benlist", buffer, t1));
        ret = this.decodeListElemets$1(buffer);
        t1 = this.index;
        if (typeof t1 !== "number")
          return t1.$add();
        t3 = t1 + 1;
        this.index = t3;
        if (t1 < 0 || t1 >= t2)
          return H.ioore(buffer, t1);
        if (buffer[t1] !== 101)
          H.throwExpression(V.BencodeParseError$("benlist", buffer, t3));
        return ret;
      } else if (100 === t3) {
        P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
        t1 = this.index;
        if (typeof t1 !== "number")
          return t1.$add();
        t3 = t1 + 1;
        this.index = t3;
        if (t1 < 0 || t1 >= t2)
          return H.ioore(buffer, t1);
        if (buffer[t1] !== 100)
          H.throwExpression(V.BencodeParseError$("bendiction", buffer, t3));
        ret = this.decodeDictionElements$1(buffer);
        t1 = this.index;
        if (typeof t1 !== "number")
          return t1.$add();
        t3 = t1 + 1;
        this.index = t3;
        if (t1 < 0 || t1 >= t2)
          return H.ioore(buffer, t1);
        if (buffer[t1] !== 101)
          H.throwExpression(V.BencodeParseError$("bendiction", buffer, t3));
        return ret;
      }
      throw H.wrapException(V.BencodeParseError$("benobject", buffer, t1));
    },
    decodeDictionElements$1: function(buffer) {
      var ret, t1, allowMalformed, t2;
      ret = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t1 = buffer.length;
      allowMalformed = C.Utf8Codec_false._allowMalformed;
      while (true) {
        t2 = this.index;
        if (typeof t2 !== "number")
          return t2.$lt();
        if (t2 < t1) {
          if (t2 < 0)
            return H.ioore(buffer, t2);
          t2 = buffer[t2] !== 101;
        } else
          t2 = false;
        if (!t2)
          break;
        t2 = J.toList$0$ax(this.decodeBenObject$1(buffer));
        ret.$indexSet(0, new P.Utf8Decoder(allowMalformed).convert$1(t2), this.decodeBenObject$1(buffer));
      }
      return ret;
    },
    decodeListElemets$1: function(buffer) {
      var ret, t1, t2;
      ret = [];
      t1 = buffer.length;
      while (true) {
        t2 = this.index;
        if (typeof t2 !== "number")
          return t2.$lt();
        if (t2 < t1) {
          if (t2 < 0)
            return H.ioore(buffer, t2);
          t2 = buffer[t2] !== 101;
        } else
          t2 = false;
        if (!t2)
          break;
        ret.push(this.decodeBenObject$1(buffer));
      }
      return ret;
    },
    decodeNumber$1: function(buffer) {
      var t1, t2, t3, $returnValue;
      t1 = this.index;
      if (typeof t1 !== "number")
        return t1.$add();
      t2 = t1 + 1;
      this.index = t2;
      t3 = buffer.length;
      if (t1 < 0 || t1 >= t3)
        return H.ioore(buffer, t1);
      if (buffer[t1] !== 105)
        throw H.wrapException(V.BencodeParseError$("bennumber", buffer, t2));
      t1 = t2;
      $returnValue = 0;
      while (true) {
        if (t1 < t3) {
          if (t1 < 0)
            return H.ioore(buffer, t1);
          t2 = buffer[t1] !== 101;
        } else
          t2 = false;
        if (!t2)
          break;
        if (t1 < 0 || t1 >= t3)
          return H.ioore(buffer, t1);
        t2 = buffer[t1];
        if (!(48 <= t2 && t2 <= 57))
          throw H.wrapException(V.BencodeParseError$("bennumber", buffer, t1));
        ++t1;
        this.index = t1;
        $returnValue = $returnValue * 10 + (t2 - 48);
      }
      t2 = t1 + 1;
      this.index = t2;
      if (t1 < 0 || t1 >= t3)
        return H.ioore(buffer, t1);
      if (buffer[t1] !== 101)
        throw H.wrapException(V.BencodeParseError$("bennumber", buffer, t2));
      return $returnValue;
    },
    decodeBytes$1: function(buffer) {
      var t1, $length, t2, t3, ret;
      t1 = buffer.length;
      $length = 0;
      while (true) {
        t2 = this.index;
        if (typeof t2 !== "number")
          return t2.$lt();
        if (t2 < t1) {
          if (t2 < 0)
            return H.ioore(buffer, t2);
          t3 = buffer[t2] !== 58;
        } else
          t3 = false;
        if (!t3)
          break;
        if (t2 < 0 || t2 >= t1)
          return H.ioore(buffer, t2);
        t3 = buffer[t2];
        if (!(48 <= t3 && t3 <= 57))
          throw H.wrapException(V.BencodeParseError$("benstring", buffer, t2));
        this.index = t2 + 1;
        $length = $length * 10 + (t3 - 48);
      }
      t3 = t2 + 1;
      this.index = t3;
      if (t2 < 0 || t2 >= t1)
        return H.ioore(buffer, t2);
      if (buffer[t2] !== 58)
        throw H.wrapException(V.BencodeParseError$("benstring", buffer, t3));
      ret = new Uint8Array(H._ensureNativeList(C.NativeUint8List_methods.sublist$2(buffer, t3, t3 + $length)));
      t1 = this.index;
      if (typeof t1 !== "number")
        return t1.$add();
      this.index = t1 + $length;
      return ret;
    }
  },
  Bencoder: {
    "^": "Object;builder",
    encodeString$1: function(obj) {
      this.builder.appendString$1(C.JSString_methods.$add(C.JSInt_methods.toString$0(C.Utf8Codec_false.get$encoder().convert$1(obj).length) + ":", obj));
    },
    encodeDictionary$1: function(obj) {
      var keys, t1, t2, key;
      keys = obj.get$keys();
      t1 = this.builder;
      t1.appendString$1("d");
      for (t2 = keys.get$iterator(keys); t2.moveNext$0();) {
        key = t2.get$current();
        this.encodeString$1(key);
        this.encodeObject$1(obj.$index(0, key));
      }
      t1.appendString$1("e");
    },
    encodeList$1: function(list) {
      var t1, t2, i;
      t1 = this.builder;
      t1.appendString$1("l");
      for (t2 = J.getInterceptor$asx(list), i = 0; i < t2.get$length(list); ++i)
        this.encodeObject$1(t2.$index(list, i));
      t1.appendString$1("e");
    },
    encodeObject$1: function(obj) {
      var t1, t2;
      if (typeof obj === "number")
        this.builder.appendString$1("i" + C.JSNumber_methods.toString$0(obj) + "e");
      else if (obj === true)
        this.encodeString$1("true");
      else if (obj === false)
        this.encodeString$1("false");
      else if (obj == null)
        this.encodeString$1("null");
      else if (typeof obj === "string")
        this.encodeString$1(obj);
      else {
        t1 = J.getInterceptor(obj);
        if (!!t1.$isByteBuffer) {
          t1 = t1.asUint8List$2(obj, 0, null);
          t2 = this.builder;
          t2.appendString$1(J.toString$0(t1.byteLength) + ":");
          t2.appendUint8List$3(t1, 0, t1.length);
        } else if (!!t1.$isUint8List) {
          t2 = this.builder;
          t2.appendString$1(J.toString$0(t1.get$lengthInBytes(obj)) + ":");
          t2.appendUint8List$3(obj, 0, obj.length);
        } else if (!!t1.$isList)
          this.encodeList$1(obj);
        else if (!!t1.$isMap)
          this.encodeDictionary$1(obj);
      }
    }
  },
  BencodeParseError: {
    "^": "Object;log",
    toString$0: function(_) {
      return this.log;
    },
    BencodeParseError$3: function(s, buffer, index) {
      this.log = s + "#" + P.IterableBase_iterableToFullString(C.NativeUint8List_methods.toList$0(buffer), "[", "]") + "index=" + J.toString$0(index) + ":" + P.Object.prototype.toString$0.call(this, this);
    },
    static: {BencodeParseError$: function(s, buffer, index) {
        var t1 = new V.BencodeParseError("");
        t1.BencodeParseError$3(s, buffer, index);
        return t1;
      }}
  },
  TrackerPeerManager: {
    "^": "Object;_managdInfoHash,interval<,max,managedPeerAddress",
    isManagedInfoHash$1: function(infoHash) {
      var i, t1;
      if (this._managdInfoHash.length !== infoHash.length)
        return false;
      for (i = 0; t1 = this._managdInfoHash, i < t1.length; ++i) {
        if (i >= infoHash.length)
          return H.ioore(infoHash, i);
        if (!J.$eq(infoHash[i], t1[i]))
          return false;
      }
      return true;
    },
    update$1: function(request) {
      var t1, t2;
      t1 = request.infoHashAsString;
      if (!this.isManagedInfoHash$1(C.NativeUint8List_methods.toList$0($.get$PercentEncode__sencoder().decodeWork$1(t1))))
        return;
      t1 = this.managedPeerAddress;
      t2 = request.peeridAsString;
      t1.addLast$1(V.PeerAddress$(C.NativeUint8List_methods.toList$0($.get$PercentEncode__sencoder().decodeWork$1(t2)), request.address, request.ip, H.Primitives_parseInt(request.portAsString, null, null)));
      if (t1._sequential.length > this.max)
        t1.removeHead$0();
    },
    createResponse$0: function() {
      var t1, response, t2, t3, i;
      t1 = [];
      response = new V.TrackerResponse(10, t1);
      response.interval = this.interval;
      t2 = this.managedPeerAddress;
      t2.shuffle$0(0);
      t3 = t2._shuffled;
      t2 = t2._sequential;
      i = 0;
      while (true) {
        if (!(i < 50 && i < t2.length))
          break;
        if (i >= t3.length)
          return H.ioore(t3, i);
        t1.push(t3[i]);
        ++i;
      }
      return response;
    }
  },
  TrackerRequest: {
    "^": "Object;portAsString,eventAsString,infoHashAsString,peeridAsString,downloadedAsString,uploadedAsString,leftAsString,address,ip<",
    get$peerId: function() {
      var t1 = this.peeridAsString;
      return C.NativeUint8List_methods.toList$0($.get$PercentEncode__sencoder().decodeWork$1(t1));
    },
    get$port: function() {
      return H.Primitives_parseInt(this.portAsString, null, null);
    },
    TrackerRequest$fromMap$3: function(parameter, _address, _ip) {
      this.portAsString = parameter.$index(0, "port");
      this.eventAsString = parameter.$index(0, "event");
      this.infoHashAsString = parameter.$index(0, "info_hash");
      this.peeridAsString = parameter.$index(0, "peer_id");
      this.downloadedAsString = parameter.$index(0, "downloaded");
      this.uploadedAsString = parameter.$index(0, "uploaded");
      this.leftAsString = parameter.$index(0, "left");
      this.address = _address;
      this.ip = P.List_List$from(_ip, true, null);
    }
  },
  TrackerResponse: {
    "^": "Object;interval<,peers<",
    initFromMap$1: function(c) {
      var t1, wpeers, t2, i, t3, wpeer, t4, port, ret, ip, peeerid, t5;
      t1 = J.getInterceptor$asx(c);
      this.interval = t1.$index(c, "interval");
      if (!!J.getInterceptor(t1.$index(c, "peers")).$isUint8List) {
        wpeers = t1.$index(c, "peers");
        t1 = J.getInterceptor$asx(wpeers);
        t2 = this.peers;
        i = 0;
        while (true) {
          t3 = t1.get$length(wpeers);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(i < t3))
            break;
          wpeer = [t1.$index(wpeers, i), t1.$index(wpeers, i + 1), t1.$index(wpeers, i + 2), t1.$index(wpeers, i + 3)];
          t3 = t1.$index(wpeers, i + 4);
          t4 = i + 5;
          return H.ioore(wpeer, t4);
          port = [t3, wpeer[t4]];
          t4 = C.JSArray_methods.toList$0(wpeer);
          return H.ioore(port, 3);
          t3 = J.$and$n(port[3], 255);
          if (2 >= 2)
            return H.ioore(port, 2);
          ret = (0 | t3 << 24 | J.$and$n(port[2], 255) << 16 | J.$and$n(port[1], 255) << 8 | J.$and$n(port[0], 255) << 0) >>> 0;
          t3 = new V.PeerAddress(null, null, null, null);
          t3.peerId = P.List_List$from([], true, null);
          t3.address = "";
          t3.ip = P.List_List$from(t4, true, null);
          t3.port = ret;
          t2.push(t3);
          i += 6;
        }
      } else
        for (t1 = J.get$iterator$ax(t1.$index(c, "peers")), t2 = this.peers; t1.moveNext$0();) {
          wpeer = t1.get$current();
          t3 = J.getInterceptor$asx(wpeer);
          ip = t3.$index(wpeer, "ip");
          peeerid = t3.$index(wpeer, "peer_id");
          port = t3.$index(wpeer, "port");
          t3 = J.toList$0$ax(peeerid);
          t4 = J.toList$0$ax(ip);
          t5 = new V.PeerAddress(null, null, null, null);
          t5.peerId = P.List_List$from(t3, true, null);
          t5.address = "";
          t5.ip = P.List_List$from(t4, true, null);
          t5.port = port;
          t2.push(t5);
        }
    },
    createResponse$1: function(isCompat) {
      var ret, builder, t1, p, t2, ret0, t3, wpeers, wpeer;
      ret = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      ret.$indexSet(0, "interval", this.interval);
      if (isCompat) {
        builder = new V.ArrayBuilder(1024, null, 0, H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(null)), [null]), [], H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(null)), [null]), false);
        builder._buffer8 = new Uint8Array(1024);
        for (t1 = this.peers, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
          p = t1._current;
          builder.appendIntList$3(p.get$ip(), 0, p.get$ip().length);
          t2 = p.get$port();
          ret0 = Array(4);
          t3 = J.getInterceptor$n(t2);
          ret0[0] = t3.$shr(t2, 8) & 255;
          ret0[1] = t3.$shr(t2, 0) & 255;
          builder.appendIntList$3(ret0, 0, 2);
        }
        ret.$indexSet(0, "peers", new Uint8Array(H._ensureNativeList(J.sublist$2$ax(builder._buffer8, 0, builder._hetima$_length))));
      } else {
        wpeers = [];
        ret.$indexSet(0, "peers", wpeers);
        for (t1 = this.peers, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
          p = t1._current;
          wpeer = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
          wpeer.$indexSet(0, "ip", p.get$ipAsString());
          wpeer.$indexSet(0, "peer_id", new Uint8Array(H._ensureNativeList(p.get$peerId())));
          wpeer.$indexSet(0, "port", p.get$port());
          wpeers.push(wpeer);
        }
      }
      return ret;
    },
    TrackerResponse$bencode$1: function(contents) {
      var t1 = $.get$Bencode__decoder();
      t1.index = 0;
      this.initFromMap$1(t1.decodeBenObject$1(contents));
    },
    static: {"^": "TrackerResponse_KEY_INTERVAL,TrackerResponse_KEY_PEERS,TrackerResponse_KEY_PEER_ID,TrackerResponse_KEY_IP,TrackerResponse_KEY_PORT,TrackerResponse_KEY_FAILURE_REASON"}
  },
  TrackerUrl: {
    "^": "Object;trackerHost,trackerPort,path,scheme<,port<,infoHashValue,peerID,event,downloaded,uploaded,left",
    toString$0: function(_) {
      return this.scheme + "://" + this.trackerHost + ":" + C.JSInt_methods.toString$0(this.trackerPort) + this.path + this.toHeader$0();
    },
    toHeader$0: function() {
      return "?info_hash=" + this.infoHashValue + "&port=" + C.JSInt_methods.toString$0(this.port) + "&peer_id=" + this.peerID + "&event=" + this.event + "&uploaded=" + C.JSInt_methods.toString$0(this.uploaded) + "&downloaded=" + C.JSInt_methods.toString$0(this.downloaded) + "&left=" + C.JSInt_methods.toString$0(this.left);
    },
    static: {"^": "TrackerUrl_KEY_INFO_HASH,TrackerUrl_KEY_PEER_ID,TrackerUrl_KEY_PORT,TrackerUrl_KEY_EVENT,TrackerUrl_VALUE_EVENT_STARTED,TrackerUrl_VALUE_EVENT_STOPPED,TrackerUrl_VALUE_EVENT_COMPLETED,TrackerUrl_KEY_DOWNLOADED,TrackerUrl_KEY_UPLOADED,TrackerUrl_KEY_LEFT,TrackerUrl_KEY_COMPACT"}
  },
  PeerAddress: {
    "^": "Object;peerId<,address,ip<,port<",
    $eq: function(_, other) {
      var i, t1, t2;
      if (other == null)
        return false;
      if (!!J.getInterceptor(other).$isPeerAddress) {
        if (other.peerId.length !== this.peerId.length)
          return false;
        for (i = 0; t1 = this.peerId, i < t1.length; ++i) {
          t2 = other.peerId;
          if (i >= t2.length)
            return H.ioore(t2, i);
          if (!J.$eq(t2[i], t1[i]))
            return false;
        }
        return true;
      } else
        return false;
    },
    get$ipAsString: function() {
      var t1, t2;
      t1 = this.ip;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1 = C.JSString_methods.$add("", J.toString$0(t1[0])) + ".";
      t2 = this.ip;
      if (1 >= t2.length)
        return H.ioore(t2, 1);
      t2 = C.JSString_methods.$add(t1, J.toString$0(t2[1])) + ".";
      t1 = this.ip;
      if (2 >= t1.length)
        return H.ioore(t1, 2);
      t1 = C.JSString_methods.$add(t2, J.toString$0(t1[2])) + ".";
      t2 = this.ip;
      if (3 >= t2.length)
        return H.ioore(t2, 3);
      return C.JSString_methods.$add(t1, J.toString$0(t2[3]));
    },
    PeerAddress$4: function(_peerId, _address, _ip, _port) {
      this.peerId = P.List_List$from(_peerId, true, null);
      this.address = _address;
      this.ip = P.List_List$from(_ip, true, null);
      this.port = _port;
    },
    $isPeerAddress: true,
    static: {PeerAddress$: function(_peerId, _address, _ip, _port) {
        var t1 = new V.PeerAddress(null, null, null, null);
        t1.PeerAddress$4(_peerId, _address, _ip, _port);
        return t1;
      }}
  },
  PercentEncode: {
    "^": "Object;builder",
    decodeWork$1: function(message) {
      var t1, count, t2, i, t3, t4;
      t1 = this.builder;
      t1._hetima$_length = 0;
      count = C.Utf8Codec_false.get$encoder().convert$1(message).length;
      for (t2 = J.getInterceptor$asx(message), i = 0; i < count; ++i)
        if (J.$eq(t2.$index(message, i), "%")) {
          t3 = $.get$PercentEncode_DECODE_TABLE();
          ++i;
          t4 = t3.$index(0, t2.$index(message, i));
          if (typeof t4 !== "number")
            return H.iae(t4);
          ++i;
          t3 = t3.$index(0, t2.$index(message, i));
          if (typeof t3 !== "number")
            return H.iae(t3);
          t1.appendByte$1(((255 & t4) << 4 | 255 & t3) >>> 0);
        } else
          t1.appendString$1(t2.$index(message, i));
      return new Uint8Array(H._ensureNativeList(J.sublist$2$ax(t1._buffer8, 0, t1._hetima$_length)));
    },
    encodeWork$1: function(target) {
      var t1, count, i, t2, t3;
      t1 = this.builder;
      t1._hetima$_length = 0;
      count = target.length;
      for (i = 0; i < count; ++i) {
        if (i >= target.length)
          return H.ioore(target, i);
        t2 = target[i];
        if (typeof t2 !== "number")
          return H.iae(t2);
        t3 = $.get$PercentEncode_ENCODE_TABLE();
        t1.appendString$1(C.JSString_methods.$add(C.JSString_methods.$add("%", t3.$index(0, (240 & t2) >>> 4)), t3.$index(0, 15 & t2)));
      }
      return C.Utf8Codec_false.decode$1(J.sublist$2$ax(t1._buffer8, 0, t1._hetima$_length));
    },
    static: {"^": "PercentEncode_DECODE_TABLE,PercentEncode_ENCODE_TABLE,PercentEncode__sencoder"}
  },
  ShuffleLinkedList: {
    "^": "Object;_sequential,_shuffled",
    addLast$1: function(value) {
      var t1 = this._sequential;
      if (C.JSArray_methods.contains$1(t1, value))
        return;
      t1.push(value);
      this._shuffled.push(value);
    },
    removeHead$0: function() {
      var t1 = this._sequential;
      if (t1.length <= 0)
        return;
      C.JSArray_methods.remove$1(this._shuffled, C.JSArray_methods.removeAt$1(t1, 0));
    },
    shuffle$0: function(_) {
      var items, i, t1, n, temp;
      items = this._shuffled;
      for (i = 0; t1 = items.length, i < t1; ++i) {
        n = C.C__JSRandom.nextInt$1(t1);
        t1 = items.length;
        if (i >= t1)
          return H.ioore(items, i);
        temp = items[i];
        if (n < 0 || n >= t1)
          return H.ioore(items, n);
        items[i] = items[n];
        items[n] = temp;
      }
    },
    get$length: function(_) {
      return this._sequential.length;
    }
  }
}],
["hetima_sv", "package:hetima/hetima_sv.dart", , K, {
  "^": "",
  TrackerClientSv: {
    "^": "Object;trackerUrl",
    request$0: function() {
      var completer, t1, version;
      completer = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(null)), [null]);
      t1 = P.HashMap_HashMap(null, null, null, P.String, P._ConnectionTarget);
      version = $.get$Platform__version();
      P.Future_Future$sync(new K.TrackerClientSv_request_closure(this, completer, new P._HttpClient(false, t1, [], [], null, null, P.HttpClient_findProxyFromEnvironment$closure(), C.Duration_15000000, null, null, null, true, "Dart/" + H.S(C.JSNull_methods.substring$2(version, 0, C.JSNull_methods.indexOf$2(version, ".", C.JSNull_methods.indexOf$1(version, ".").$add(0, 1)))) + " (dart:io)")), null).catchError$1(new K.TrackerClientSv_request_closure0(completer)).then$1(new K.TrackerClientSv_request_closure1());
      return completer.future;
    },
    responseHandle$2: function(response, completer) {
      var t1, buffer;
      t1 = {};
      P.print("--[A2]-");
      t1.redirectNum_0 = 0;
      response.get$redirects();
      if (response.get$redirects().length > 0) {
        response.redirect$0().then$1(new K.TrackerClientSv_responseHandle_closure(t1, this, completer));
        return;
      }
      buffer = new V.ArrayBuilder(1024, null, 0, H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(null)), [null]), [], H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(null)), [null]), false);
      buffer._buffer8 = new Uint8Array(1024);
      response.listen$1(new K.TrackerClientSv_responseHandle_closure0(buffer)).onDone$1(new K.TrackerClientSv_responseHandle_closure1(completer, buffer));
    }
  },
  TrackerClientSv_request_closure: {
    "^": "Closure:55;this_0,completer_1,client_2",
    call$0: function() {
      var t1, t2, t3;
      t1 = this.this_0;
      t2 = t1.trackerUrl;
      P.print("--[A0]-" + t2.trackerHost + "," + C.JSInt_methods.toString$0(6969) + "," + t2.path + t2.toHeader$0());
      t3 = t2.trackerHost;
      t2 = t2.path + t2.toHeader$0();
      return this.client_2._openUrl$2("get", P.Uri_Uri(null, t3, null, null, 6969, null, null, "http", "").resolveUri$1(P.Uri_parse(t2))).then$1(new K.TrackerClientSv_request__closure(t1, this.completer_1));
    },
    $isFunction: true
  },
  TrackerClientSv_request__closure: {
    "^": "Closure:136;this_3,completer_4",
    call$1: [function(request) {
      P.print("--[A1]-");
      return request.close$0().then$1(new K.TrackerClientSv_request___closure(this.this_3, this.completer_4));
    }, "call$1", null, 2, 0, null, 104, "call"],
    $isFunction: true
  },
  TrackerClientSv_request___closure: {
    "^": "Closure:137;this_5,completer_6",
    call$1: [function(response) {
      this.this_5.responseHandle$2(response, this.completer_6);
    }, "call$1", null, 2, 0, null, 116, "call"],
    $isFunction: true
  },
  TrackerClientSv_request_closure0: {
    "^": "Closure:58;completer_7",
    call$1: [function(e) {
      var t1, t2;
      t1 = new K.RequestResultSv(0, null);
      t1.code = -1;
      t1.response = null;
      t2 = this.completer_7.future;
      if (t2._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      t2._asyncComplete$1(t1);
      P.print("##er end");
    }, "call$1", null, 2, 0, null, 2, "call"],
    $isFunction: true
  },
  TrackerClientSv_request_closure1: {
    "^": "Closure:58;",
    call$1: [function(e) {
      P.print("###done end");
    }, "call$1", null, 2, 0, null, 2, "call"],
    $isFunction: true
  },
  TrackerClientSv_responseHandle_closure: {
    "^": "Closure:137;box_0,this_1,completer_2",
    call$1: [function(response) {
      var t1, t2;
      if (++this.box_0.redirectNum_0 > 5) {
        t1 = new K.RequestResultSv(0, null);
        t1.code = -1;
        t1.response = null;
        t2 = this.completer_2.future;
        if (t2._state !== 0)
          H.throwExpression(P.StateError$("Future already completed"));
        t2._asyncComplete$1(t1);
      }
      this.this_1.responseHandle$2(response, this.completer_2);
    }, "call$1", null, 2, 0, null, 116, "call"],
    $isFunction: true
  },
  TrackerClientSv_responseHandle_closure0: {
    "^": "Closure:139;buffer_3",
    call$1: [function(contents) {
      var t1 = J.getInterceptor(contents);
      P.print(C.JSString_methods.$add("--[A3]-", t1.get$runtimeType(contents).toString$0(0)));
      P.print("listen:" + J.toString$0(t1.get$length(contents)));
      this.buffer_3.appendUint8List$3(contents, 0, t1.get$length(contents));
    }, "call$1", null, 2, 0, null, 138, "call"],
    $isFunction: true
  },
  TrackerClientSv_responseHandle_closure1: {
    "^": "Closure:55;completer_4,buffer_5",
    call$0: [function() {
      var t1, response, t2;
      P.print("--[A4]-");
      P.print("done");
      t1 = this.buffer_5;
      response = new V.TrackerResponse(10, []);
      response.TrackerResponse$bencode$1(new Uint8Array(H._ensureNativeList(J.sublist$2$ax(t1._buffer8, 0, t1._hetima$_length))));
      t1 = new K.RequestResultSv(0, null);
      t1.code = 0;
      t1.response = response;
      t2 = this.completer_4.future;
      if (t2._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      t2._asyncComplete$1(t1);
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  RequestResultSv: {
    "^": "Object;code<,response<",
    static: {"^": "RequestResultSv_OK,RequestResultSv_ERROR"}
  },
  TrackerServer: {
    "^": "Object;address,port<,_server,outputLog,_peerManagerList",
    add$1: [function(_, hash) {
      var t1, infoHash, t2, t3, isManaged, peerManager;
      t1 = this.outputLog;
      if (t1)
        P.print(C.JSString_methods.$add("TrackerServer#add:", hash));
      infoHash = C.NativeUint8List_methods.toList$0($.get$PercentEncode__sencoder().decodeWork$1(hash));
      for (t2 = this._peerManagerList, t3 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]), isManaged = false; t3.moveNext$0();)
        if (t3._current.isManagedInfoHash$1(infoHash))
          isManaged = true;
      if (isManaged) {
        if (t1)
          P.print(C.JSString_methods.$add("TrackerServer#add:###non:", hash));
        return;
      }
      peerManager = new V.TrackerPeerManager([], 60, 200, H.setRuntimeTypeInfo(new V.ShuffleLinkedList([], []), [null]));
      peerManager._managdInfoHash = C.JSArray_methods.toList$0(infoHash);
      t2.push(peerManager);
      if (t1)
        P.print(C.JSString_methods.$add("TrackerServer#add:###add:", hash));
    }, "call$1", "get$add", 2, 0, 38],
    start$0: function() {
      if (this.outputLog)
        P.print("TrackerServer#start");
      var c = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(null)), [null]);
      P.HttpServer_bind(this.address, this.port, 0).then$1(new K.TrackerServer_start_closure(this, c)).catchError$1(new K.TrackerServer_start_closure0(this, c));
    },
    onListen$1: [function(request) {
      var addressAsInet, ip, cont, e, t1, t2, parameter, infoHashAsString, manager, exception;
      try {
        t1 = this.outputLog;
        if (t1)
          P.print("TrackerServer#onListen" + J.toString$0(request.get$uri()));
        addressAsInet = request.get$connectionInfo().remoteAddress;
        ip = addressAsInet.get$rawAddress();
        t2 = request.get$uri().get$query();
        if (t1)
          P.print(C.JSString_methods.$add("TrackerServer#updateResponse", t2));
        parameter = V.HttpUrlDecoder_queryMap(t2);
        infoHashAsString = parameter.$index(0, "info_hash");
        manager = this.find$1($.get$PercentEncode__sencoder().decodeWork$1(infoHashAsString));
        if (null != manager) {
          t1 = new V.TrackerRequest("", "", "", "", "", "", "", "", null);
          t1.TrackerRequest$fromMap$3(parameter, this.address, ip);
          manager.update$1(t1);
        }
        cont = this.createResponse$1(request.get$uri().get$query());
        request.get$response().set$statusCode(200);
        request.get$response().add$1(0, cont);
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        request.get$response().set$statusCode(400);
        P.print(C.JSString_methods.$add("error:", J.toString$0(e)));
      }
 finally {
        try {
          request.get$response().close$0();
        } catch (exception) {
          H.unwrapException(exception);
        }

      }
    }, "call$1", "get$onListen", 2, 0, 140, 104],
    createResponse$1: function(query) {
      var t1, parameter, infoHashAsString, compactAsString, isCompact, manager, errorResponse, t2, t3, t4, buffer;
      t1 = this.outputLog;
      if (t1)
        P.print(C.JSString_methods.$add("TrackerServer#onListen", query));
      parameter = V.HttpUrlDecoder_queryMap(query);
      infoHashAsString = parameter.$index(0, "info_hash");
      compactAsString = parameter.$index(0, "compact");
      isCompact = compactAsString != null && J.$eq(compactAsString, "1") && true;
      manager = this.find$1($.get$PercentEncode__sencoder().decodeWork$1(infoHashAsString));
      if (null == manager) {
        if (t1)
          P.print("TrackerServer#onListen:###unmanaged");
        errorResponse = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
        errorResponse.$indexSet(0, "failure reason", "unmanaged torrent data");
        t1 = $.get$Bencode__encoder();
        t2 = t1.builder;
        t2._hetima$_length = 0;
        t1.encodeObject$1(errorResponse);
        return C.NativeUint8List_methods.toList$0(new Uint8Array(H._ensureNativeList(J.sublist$2$ax(t2._buffer8, 0, t2._hetima$_length))));
      } else {
        t2 = manager.createResponse$0().createResponse$1(isCompact);
        t3 = $.get$Bencode__encoder();
        t4 = t3.builder;
        t4._hetima$_length = 0;
        t3.encodeObject$1(t2);
        buffer = new Uint8Array(H._ensureNativeList(J.sublist$2$ax(t4._buffer8, 0, t4._hetima$_length)));
        if (t1) {
          t1 = C.NativeUint8List_methods.toList$0(buffer);
          P.print("TrackerServer#onListen:###managed" + $.get$PercentEncode__sencoder().encodeWork$1(t1));
        }
        return C.NativeUint8List_methods.toList$0(buffer);
      }
    },
    find$1: function(infoHash) {
      var t1, l;
      for (t1 = this._peerManagerList, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        l = t1._current;
        if (l.isManagedInfoHash$1(infoHash))
          return l;
      }
      return;
    }
  },
  TrackerServer_start_closure: {
    "^": "Closure:141;this_0,c_1",
    call$1: function(server) {
      var t1, t2;
      t1 = this.this_0;
      t1._server = server;
      server.listen$1(t1.get$onListen());
      t2 = this.c_1.future;
      if (t2._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      t2._asyncComplete$1(new K.StartResult());
      if (t1.outputLog)
        P.print("TrackerServer#start:##ok");
    },
    $isFunction: true
  },
  TrackerServer_start_closure0: {
    "^": "Closure:58;this_2,c_3",
    call$1: function(e) {
      var t1 = this.c_3.future;
      if (t1._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      t1._asyncComplete$1(new K.StartResult());
      if (this.this_2.outputLog)
        P.print("TrackerServer#start:##ng");
    },
    $isFunction: true
  },
  StartResult: {
    "^": "Object;"
  }
}],
["lazy_trace", "package:stack_trace/src/lazy_trace.dart", , S, {
  "^": "",
  LazyTrace: {
    "^": "Object;_thunk,_inner",
    _thunk$0: function() {
      return this._thunk.call$0();
    },
    get$_lazy_trace$_trace: function() {
      var t1 = this._inner;
      if (t1 == null) {
        t1 = this._thunk$0();
        this._inner = t1;
      }
      return t1;
    },
    get$frames: function() {
      return this.get$_lazy_trace$_trace().get$frames();
    },
    toString$0: function(_) {
      return J.toString$0(this.get$_lazy_trace$_trace());
    },
    $isTrace: true,
    $isStackTrace: true
  }
}],
["matcher.description", "package:matcher/src/description.dart", , Y, {
  "^": "",
  StringDescription: {
    "^": "Object;_out",
    get$length: function(_) {
      return this._out._contents.length;
    },
    toString$0: function(_) {
      return this._out._contents;
    },
    add$1: [function(_, text) {
      this._out.write$1(text);
      return this;
    }, "call$1", "get$add", 2, 0, 142],
    addDescriptionOf$1: function(value) {
      value.describe$1(this);
      return this;
    }
  }
}],
["matcher.expect", "package:matcher/src/expect.dart", , Y, {
  "^": "",
  configureExpectFailureHandler: function(handler) {
    $._assertFailureHandler = handler;
  },
  _defaultErrorFormatter: [function(actual, matcher, reason, matchState, verbose) {
    var t1, description, t2;
    t1 = P.StringBuffer$("");
    description = new Y.StringDescription(t1);
    t1.write$1("");
    t1.write$1("Expected: ");
    description.addDescriptionOf$1(matcher)._out.write$1("\n");
    t1.write$1("  Actual: ");
    description.addDescriptionOf$1(actual)._out.write$1("\n");
    t2 = P.StringBuffer$("");
    t2.write$1("");
    matcher.describeMismatch$4(actual, new Y.StringDescription(t2), matchState, verbose);
    t2 = t2._contents;
    if (t2.length > 0)
      t1.write$1("   Which: " + t2 + "\n");
    t1.write$1(reason);
    t1.write$1("\n");
    return t1._contents;
  }, "call$5", "_defaultErrorFormatter$closure", 10, 0, 54],
  TestFailure: {
    "^": "Error;message<",
    toString$0: function(_) {
      return this.message;
    },
    $isTestFailure: true,
    static: {TestFailure$: function(message) {
        return new Y.TestFailure(message);
      }}
  },
  closure: {
    "^": "Closure:143;",
    call$2: function(f, id) {
      return f;
    },
    call$1: function(f) {
      return this.call$2(f, null);
    },
    $isFunction: true
  },
  DefaultFailureHandler: {
    "^": "Object;"
  }
}],
["matcher.interfaces", "package:matcher/src/interfaces.dart", , Q, {
  "^": "",
  Description: {
    "^": "Object;"
  },
  Matcher: {
    "^": "Object;"
  }
}],
["path", "package:path/path.dart", , B, {
  "^": "",
  current: function() {
    var uri, t1, t2, path;
    uri = P.Uri_base();
    t1 = $.get$Style_platform();
    t2 = $.get$Style_url();
    if (t1 == null ? t2 == null : t1 === t2)
      return uri.resolveUri$1(P.Uri_parse(".")).toString$0(0);
    else {
      path = uri.toFilePath$0();
      return C.JSString_methods.substring$2(path, 0, path.length - 1);
    }
  }
}],
["path.context", "package:path/src/context.dart", , F, {
  "^": "",
  _validateArgList: function(method, args) {
    var i, numArgs, numArgs0, message, t1, t2, t3;
    for (i = 1; i < 8; ++i) {
      if (args[i] == null || args[i - 1] != null)
        continue;
      for (numArgs = 8; numArgs >= 1; numArgs = numArgs0) {
        numArgs0 = numArgs - 1;
        if (args[numArgs0] != null)
          break;
      }
      message = new P.StringBuffer("");
      message._contents = "";
      t1 = method + "(";
      message._contents = t1;
      t2 = new H.IterableMixinWorkaround();
      t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(args, 0)];
      t3 = new H.SubListIterable(args, 0, numArgs);
      t3.$builtinTypeInfo = [H.getTypeArgumentByIndex(t2, 0)];
      if (numArgs < 0)
        H.throwExpression(P.RangeError$value(numArgs));
      if (0 > numArgs)
        H.throwExpression(P.RangeError$range(0, 0, numArgs));
      t2 = new H.MappedListIterable(t3, new F._validateArgList_closure());
      t2.$builtinTypeInfo = [null, null];
      t2 = t2.join$1(0, ", ");
      t1 += t2;
      message._contents = t1;
      t2 = "): part " + (i - 1) + " was null, but part " + i + " was not.";
      message._contents = t1 + t2;
      throw H.wrapException(P.ArgumentError$(message.toString$0(0)));
    }
  },
  Context: {
    "^": "Object;style,_context0$_current",
    join$8: function(_, part1, part2, part3, part4, part5, part6, part7, part8) {
      var parts = [part1, part2, part3, part4, part5, part6, part7, part8];
      F._validateArgList("join", parts);
      return this.joinAll$1(H.setRuntimeTypeInfo(new H.WhereIterable(parts, new F.Context_join_closure()), [H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(parts, 0)]), 0)]));
    },
    join$2: function($receiver, part1, part2) {
      return this.join$8($receiver, part1, part2, null, null, null, null, null, null);
    },
    joinAll$1: function(parts) {
      var buffer, t1, t2, t3, needsSeparator, isAbsoluteAndNotRootRelative, part, parsed, root, t4, t5;
      buffer = P.StringBuffer$("");
      for (t1 = H.setRuntimeTypeInfo(new H.WhereIterable(parts, new F.Context_joinAll_closure()), [H.getRuntimeTypeArgument(parts, "IterableBase", 0)]), t1 = H.setRuntimeTypeInfo(new H.WhereIterator(J.get$iterator$ax(t1._iterable), t1._f), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.style, t3 = t1._iterator, needsSeparator = false, isAbsoluteAndNotRootRelative = false; t1.moveNext$0();) {
        part = t3.get$current();
        if (Q.ParsedPath_ParsedPath$parse(part, t2).isRootRelative && isAbsoluteAndNotRootRelative) {
          parsed = Q.ParsedPath_ParsedPath$parse(part, t2);
          root = Q.ParsedPath_ParsedPath$parse(buffer._contents, t2).root;
          t4 = root == null ? "" : root;
          parsed.root = t4;
          if (t2.needsSeparator$1(t4)) {
            t4 = parsed.separators;
            t5 = t2.get$separator();
            if (0 >= t4.length)
              return H.ioore(t4, 0);
            t4[0] = t5;
          }
          buffer._contents = "";
          t4 = parsed.toString$0(0);
          buffer._contents += t4;
        } else if (Q.ParsedPath_ParsedPath$parse(part, t2).root != null) {
          isAbsoluteAndNotRootRelative = !Q.ParsedPath_ParsedPath$parse(part, t2).isRootRelative;
          buffer._contents = "";
          buffer._contents += typeof part === "string" ? part : H.S(part);
        } else {
          t4 = J.getInterceptor$asx(part);
          if (J.$gt$n(t4.get$length(part), 0) && t2.containsSeparator$1(t4.$index(part, 0)) === true)
            ;
          else if (needsSeparator) {
            t4 = t2.get$separator();
            buffer._contents += t4;
          }
          buffer._contents += typeof part === "string" ? part : H.S(part);
        }
        needsSeparator = t2.needsSeparator$1(part);
      }
      return buffer._contents;
    },
    split$1: function(_, path) {
      var parsed, t1, t2;
      parsed = Q.ParsedPath_ParsedPath$parse(path, this.style);
      t1 = parsed.parts;
      t1 = H.setRuntimeTypeInfo(new H.WhereIterable(t1, new F.Context_split_closure()), [H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(t1, 0)]), 0)]);
      t1 = P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "IterableBase", 0));
      parsed.parts = t1;
      t2 = parsed.root;
      if (t2 != null)
        C.JSArray_methods.insert$2(t1, 0, t2);
      return parsed.parts;
    },
    normalize$1: function(path) {
      var parsed = Q.ParsedPath_ParsedPath$parse(path, this.style);
      parsed.normalize$0();
      return parsed.toString$0(0);
    },
    relative$2$from: function(path, from) {
      var t1, t2, fromParsed, pathParsed, t3;
      t1 = this._context0$_current;
      from = t1 != null ? t1 : B.current();
      t1 = this.style;
      if (Q.ParsedPath_ParsedPath$parse(from, t1).root == null && Q.ParsedPath_ParsedPath$parse(path, t1).root != null)
        return this.normalize$1(path);
      if (Q.ParsedPath_ParsedPath$parse(path, t1).root == null || Q.ParsedPath_ParsedPath$parse(path, t1).isRootRelative) {
        t2 = this._context0$_current;
        path = this.join$8(0, t2 != null ? t2 : B.current(), path, null, null, null, null, null, null);
      }
      if (Q.ParsedPath_ParsedPath$parse(path, t1).root == null && Q.ParsedPath_ParsedPath$parse(from, t1).root != null)
        throw H.wrapException(E.PathException$("Unable to find a path to \"" + path + "\" from \"" + H.S(from) + "\"."));
      fromParsed = Q.ParsedPath_ParsedPath$parse(from, t1);
      fromParsed.normalize$0();
      pathParsed = Q.ParsedPath_ParsedPath$parse(path, t1);
      pathParsed.normalize$0();
      t2 = fromParsed.parts;
      if (t2.length > 0 && J.$eq(t2[0], "."))
        return pathParsed.toString$0(0);
      if (!J.$eq(fromParsed.root, pathParsed.root)) {
        t2 = fromParsed.root;
        if (!(t2 == null || pathParsed.root == null)) {
          t2 = J.toLowerCase$0$s(t2);
          t2 = H.stringReplaceAllUnchecked(t2, "/", "\\");
          t3 = J.toLowerCase$0$s(pathParsed.root);
          t2 = t2 !== H.stringReplaceAllUnchecked(t3, "/", "\\");
        } else
          t2 = true;
      } else
        t2 = false;
      if (t2)
        return pathParsed.toString$0(0);
      while (true) {
        t2 = fromParsed.parts;
        if (t2.length > 0) {
          t3 = pathParsed.parts;
          t2 = t3.length > 0 && J.$eq(t2[0], t3[0]);
        } else
          t2 = false;
        if (!t2)
          break;
        C.JSArray_methods.removeAt$1(fromParsed.parts, 0);
        C.JSArray_methods.removeAt$1(fromParsed.separators, 1);
        C.JSArray_methods.removeAt$1(pathParsed.parts, 0);
        C.JSArray_methods.removeAt$1(pathParsed.separators, 1);
      }
      t2 = fromParsed.parts;
      if (t2.length > 0 && J.$eq(t2[0], ".."))
        throw H.wrapException(E.PathException$("Unable to find a path to \"" + path + "\" from \"" + H.S(from) + "\"."));
      t2 = pathParsed.parts;
      t3 = P.List_List$filled(fromParsed.parts.length, "..", null);
      H.IterableMixinWorkaround_insertAllList(t2, 0, t3);
      t2 = pathParsed.separators;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      t2[0] = "";
      t1 = P.List_List$filled(fromParsed.parts.length, t1.get$separator(), null);
      if (!!t2.fixed$length)
        H.throwExpression(P.UnsupportedError$("insertAll"));
      H.IterableMixinWorkaround_insertAllList(t2, 1, t1);
      t1 = pathParsed.parts;
      t2 = t1.length;
      if (t2 === 0)
        return ".";
      if (t2 > 1 && J.$eq(C.JSArray_methods.get$last(t1), ".")) {
        t1 = pathParsed.parts;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1.pop();
        t1 = pathParsed.separators;
        C.JSArray_methods.removeLast$0(t1);
        C.JSArray_methods.removeLast$0(t1);
        C.JSArray_methods.add$1(t1, "");
      }
      pathParsed.root = "";
      pathParsed.removeTrailingSeparators$0();
      return pathParsed.toString$0(0);
    },
    relative$1: function(path) {
      return this.relative$2$from(path, null);
    },
    fromUri$1: function(uri) {
      if (typeof uri === "string")
        uri = P.Uri_parse(uri);
      return this.style.pathFromUri$1(uri);
    },
    toUri$1: function(path) {
      var t1, t2;
      t1 = this.style;
      if (Q.ParsedPath_ParsedPath$parse(path, t1).root == null)
        return t1.relativePathToUri$1(path);
      else {
        t2 = this._context0$_current;
        return t1.absolutePathToUri$1(this.join$2(0, t2 != null ? t2 : B.current(), path));
      }
    },
    prettyUri$1: function(uri) {
      var t1, t2, path, rel;
      if (typeof uri === "string")
        uri = P.Uri_parse(uri);
      if (uri.get$scheme() === "file") {
        t1 = this.style;
        t2 = $.get$Style_url();
        t2 = t1 == null ? t2 == null : t1 === t2;
        t1 = t2;
      } else
        t1 = false;
      if (t1)
        return J.toString$0(uri);
      if (uri.get$scheme() !== "file")
        if (uri.get$scheme() !== "") {
          t1 = this.style;
          t2 = $.get$Style_url();
          t2 = t1 == null ? t2 != null : t1 !== t2;
          t1 = t2;
        } else
          t1 = false;
      else
        t1 = false;
      if (t1)
        return J.toString$0(uri);
      path = this.normalize$1(this.fromUri$1(uri));
      rel = this.relative$1(path);
      this.split$1(0, rel);
      return this.split$1(0, rel).length > this.split$1(0, path).length ? path : rel;
    },
    static: {Context_Context: function(current, style) {
        current = style == null ? B.current() : ".";
        if (style == null)
          style = $.get$Style_platform();
        else if (!style.$isInternalStyle)
          throw H.wrapException(P.ArgumentError$("Only styles defined by the path package are allowed."));
        return new F.Context(style, current);
      }}
  },
  Context_join_closure: {
    "^": "Closure:58;",
    call$1: function(part) {
      return part != null;
    },
    $isFunction: true
  },
  Context_joinAll_closure: {
    "^": "Closure:58;",
    call$1: function(part) {
      return !J.$eq(part, "");
    },
    $isFunction: true
  },
  Context_split_closure: {
    "^": "Closure:58;",
    call$1: function(part) {
      return J.get$isEmpty$asx(part) !== true;
    },
    $isFunction: true
  },
  _validateArgList_closure: {
    "^": "Closure:58;",
    call$1: [function(arg) {
      return arg == null ? "null" : "\"" + H.S(arg) + "\"";
    }, "call$1", null, 2, 0, null, 26, "call"],
    $isFunction: true
  }
}],
["path.internal_style", "package:path/src/internal_style.dart", , E, {
  "^": "",
  InternalStyle: {
    "^": "Style;",
    relativePathToUri$1: function(path) {
      return P.Uri_Uri(null, null, null, F.Context_Context(null, this).split$1(0, path), null, null, null, "", "");
    },
    $isInternalStyle: true
  }
}],
["path.parsed_path", "package:path/src/parsed_path.dart", , Q, {
  "^": "",
  ParsedPath: {
    "^": "Object;style,root,isRootRelative,parts,separators",
    get$hasTrailingSeparator: function() {
      var t1 = this.parts;
      if (t1.length !== 0)
        t1 = J.$eq(C.JSArray_methods.get$last(t1), "") || !J.$eq(C.JSArray_methods.get$last(this.separators), "");
      else
        t1 = false;
      return t1;
    },
    removeTrailingSeparators$0: function() {
      var t1, t2;
      while (true) {
        t1 = this.parts;
        if (!(t1.length !== 0 && J.$eq(C.JSArray_methods.get$last(t1), "")))
          break;
        t1 = this.parts;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1.pop();
        C.JSArray_methods.removeLast$0(this.separators);
      }
      t1 = this.separators;
      t2 = t1.length;
      if (t2 > 0)
        t1[t2 - 1] = "";
    },
    normalize$0: function() {
      var newParts, t1, leadingDoubles, part, t2, newSeparators, t3;
      newParts = [];
      for (t1 = this.parts, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]), leadingDoubles = 0; t1.moveNext$0();) {
        part = t1._current;
        t2 = J.getInterceptor(part);
        if (t2.$eq(part, ".") || t2.$eq(part, ""))
          ;
        else if (t2.$eq(part, ".."))
          if (newParts.length > 0)
            newParts.pop();
          else
            ++leadingDoubles;
        else
          newParts.push(part);
      }
      if (this.root == null) {
        t1 = P.List_List$filled(leadingDoubles, "..", null);
        H.IterableMixinWorkaround_insertAllList(newParts, 0, t1);
      }
      if (newParts.length === 0 && this.root == null)
        newParts.push(".");
      newSeparators = P.List_List$generate(newParts.length, new Q.ParsedPath_normalize_closure(this), true, null);
      t1 = this.root;
      C.JSArray_methods.insert$2(newSeparators, 0, t1 != null && newParts.length > 0 && this.style.needsSeparator$1(t1) ? this.style.get$separator() : "");
      this.parts = newParts;
      this.separators = newSeparators;
      t1 = this.root;
      if (t1 != null) {
        t2 = this.style;
        t3 = $.get$Style_windows();
        t3 = t2 == null ? t3 == null : t2 === t3;
        t2 = t3;
      } else
        t2 = false;
      if (t2)
        this.root = J.replaceAll$2$s(t1, "/", "\\");
      this.removeTrailingSeparators$0();
    },
    toString$0: function(_) {
      var builder, t1, i, str;
      builder = P.StringBuffer$("");
      t1 = this.root;
      if (t1 != null)
        builder.write$1(t1);
      for (i = 0; i < this.parts.length; ++i) {
        t1 = this.separators;
        if (i >= t1.length)
          return H.ioore(t1, i);
        str = t1[i];
        builder._contents += typeof str === "string" ? str : H.S(str);
        t1 = this.parts;
        if (i >= t1.length)
          return H.ioore(t1, i);
        str = t1[i];
        builder._contents += typeof str === "string" ? str : H.S(str);
      }
      builder.write$1(C.JSArray_methods.get$last(this.separators));
      return builder._contents;
    },
    static: {ParsedPath_ParsedPath$parse: function(path, style) {
        var root, t1, parts, separators, t2, start, i, t3;
        root = style.getRoot$1(path);
        t1 = style.getRelativeRoot$1(path);
        if (root != null)
          path = J.substring$1$s(path, J.get$length$asx(root));
        parts = [];
        separators = [];
        t2 = J.getInterceptor$asx(path);
        if (t2.get$isNotEmpty(path) && style.isSeparator$1(t2.codeUnitAt$1(path, 0))) {
          separators.push(t2.$index(path, 0));
          start = 1;
        } else {
          separators.push("");
          start = 0;
        }
        i = start;
        while (true) {
          t3 = t2.get$length(path);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(i < t3))
            break;
          if (style.isSeparator$1(t2.codeUnitAt$1(path, i))) {
            parts.push(t2.substring$2(path, start, i));
            separators.push(t2.$index(path, i));
            start = i + 1;
          }
          ++i;
        }
        t3 = t2.get$length(path);
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (start < t3) {
          parts.push(t2.substring$1(path, start));
          separators.push("");
        }
        return new Q.ParsedPath(style, root, t1 != null, parts, separators);
      }}
  },
  ParsedPath_normalize_closure: {
    "^": "Closure:58;this_0",
    call$1: function(_) {
      return this.this_0.style.get$separator();
    },
    $isFunction: true
  }
}],
["path.path_exception", "package:path/src/path_exception.dart", , E, {
  "^": "",
  PathException: {
    "^": "Object;message<",
    toString$0: function(_) {
      return "PathException: " + this.message;
    },
    static: {PathException$: function(message) {
        return new E.PathException(message);
      }}
  }
}],
["path.style", "package:path/src/style.dart", , S, {
  "^": "",
  Style__getPlatformStyle: function() {
    if (P.Uri_base().scheme !== "file")
      return $.get$Style_url();
    if (!C.JSString_methods.endsWith$1(P.Uri_base()._path, "/"))
      return $.get$Style_url();
    if (P.Uri_Uri(null, null, "a/b", null, null, null, null, "", "").toFilePath$0() === "a\\b")
      return $.get$Style_windows();
    return $.get$Style_posix();
  },
  Style: {
    "^": "Object;",
    toString$0: function(_) {
      return this.get$name();
    }
  }
}],
["path.style.posix", "package:path/src/style/posix.dart", , Z, {
  "^": "",
  PosixStyle: {
    "^": "InternalStyle;name<,separator<,separators,separatorPattern,needsSeparatorPattern,rootPattern,relativeRootPattern",
    containsSeparator$1: function(path) {
      return J.contains$1$asx(path, "/");
    },
    isSeparator$1: function(codeUnit) {
      return codeUnit === 47;
    },
    needsSeparator$1: function(path) {
      var t1 = J.getInterceptor$asx(path);
      return t1.get$isNotEmpty(path) && t1.codeUnitAt$1(path, J.$sub$n(t1.get$length(path), 1)) !== 47;
    },
    getRoot$1: function(path) {
      var t1 = J.getInterceptor$asx(path);
      if (t1.get$isNotEmpty(path) && t1.codeUnitAt$1(path, 0) === 47)
        return "/";
      return;
    },
    getRelativeRoot$1: function(path) {
      return;
    },
    pathFromUri$1: function(uri) {
      if (uri.get$scheme() === "" || uri.get$scheme() === "file")
        return P.Uri__uriDecode(uri.get$path(), C.Utf8Codec_false, false);
      throw H.wrapException(P.ArgumentError$("Uri " + H.S(uri) + " must have scheme 'file:'."));
    },
    absolutePathToUri$1: function(path) {
      var parsed, t1;
      parsed = Q.ParsedPath_ParsedPath$parse(path, this);
      t1 = parsed.parts;
      if (t1.length === 0)
        C.JSArray_methods.addAll$1(t1, ["", ""]);
      else if (parsed.get$hasTrailingSeparator())
        parsed.parts.push("");
      return P.Uri_Uri(null, null, null, parsed.parts, null, null, null, "file", "");
    }
  }
}],
["path.style.url", "package:path/src/style/url.dart", , E, {
  "^": "",
  UrlStyle: {
    "^": "InternalStyle;name<,separator<,separators,separatorPattern,needsSeparatorPattern,rootPattern,relativeRootPattern",
    containsSeparator$1: function(path) {
      return J.contains$1$asx(path, "/");
    },
    isSeparator$1: function(codeUnit) {
      return codeUnit === 47;
    },
    needsSeparator$1: function(path) {
      var t1, root;
      t1 = J.getInterceptor$asx(path);
      if (t1.get$isEmpty(path) === true)
        return false;
      if (t1.codeUnitAt$1(path, J.$sub$n(t1.get$length(path), 1)) !== 47)
        return true;
      root = this._url$_getRoot$1(path);
      return root != null && C.JSString_methods.endsWith$1(root, "://");
    },
    getRoot$1: function(path) {
      var root = this._url$_getRoot$1(path);
      return root == null ? this.getRelativeRoot$1(path) : root;
    },
    getRelativeRoot$1: function(path) {
      var t1 = J.getInterceptor$asx(path);
      if (t1.get$isEmpty(path) === true)
        return;
      return t1.codeUnitAt$1(path, 0) === 47 ? "/" : null;
    },
    pathFromUri$1: function(uri) {
      return J.toString$0(uri);
    },
    relativePathToUri$1: function(path) {
      return P.Uri_parse(path);
    },
    absolutePathToUri$1: function(path) {
      return P.Uri_parse(path);
    },
    _url$_getRoot$1: function(path) {
      var t1, start, t2, $char, start0;
      t1 = J.getInterceptor$asx(path);
      if (t1.get$isEmpty(path) === true)
        return;
      if (!N.isAlphabetic(t1.codeUnitAt$1(path, 0)))
        return;
      start = 1;
      while (true) {
        t2 = t1.get$length(path);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(start < t2))
          break;
        c$0: {
          $char = t1.codeUnitAt$1(path, start);
          if (N.isAlphabetic($char))
            break c$0;
          if ($char >= 48 && $char <= 57)
            break c$0;
          if ($char === 45 || $char === 43 || $char === 46)
            break c$0;
          break;
        }
        ++start;
      }
      start0 = start + 3;
      t2 = t1.get$length(path);
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (start0 > t2)
        return;
      if (t1.substring$2(path, start, start0) !== "://")
        return;
      start = start0;
      while (true) {
        t2 = t1.get$length(path);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(start < t2 && t1.codeUnitAt$1(path, start) !== 47))
          break;
        ++start;
      }
      return t1.substring$2(path, 0, start);
    }
  }
}],
["path.style.windows", "package:path/src/style/windows.dart", , T, {
  "^": "",
  WindowsStyle: {
    "^": "InternalStyle;name<,separator<,separators,separatorPattern,needsSeparatorPattern,rootPattern,relativeRootPattern",
    containsSeparator$1: function(path) {
      return J.contains$1$asx(path, "/");
    },
    isSeparator$1: function(codeUnit) {
      return codeUnit === 47 || codeUnit === 92;
    },
    needsSeparator$1: function(path) {
      var t1 = J.getInterceptor$asx(path);
      if (t1.get$isEmpty(path) === true)
        return false;
      t1 = t1.codeUnitAt$1(path, J.$sub$n(t1.get$length(path), 1));
      return !(t1 === 47 || t1 === 92);
    },
    getRoot$1: function(path) {
      var root = this._getRoot$1(path);
      return root == null ? this.getRelativeRoot$1(path) : root;
    },
    getRelativeRoot$1: function(path) {
      var t1, t2;
      t1 = J.getInterceptor$asx(path);
      if (t1.get$isEmpty(path) === true)
        return;
      t2 = t1.codeUnitAt$1(path, 0);
      if (!(t2 === 47 || t2 === 92))
        return;
      if (J.$gt$n(t1.get$length(path), 1)) {
        t2 = t1.codeUnitAt$1(path, 1);
        t2 = t2 === 47 || t2 === 92;
      } else
        t2 = false;
      if (t2)
        return;
      return t1.$index(path, 0);
    },
    pathFromUri$1: function(uri) {
      var path;
      if (uri.get$scheme() !== "" && uri.get$scheme() !== "file")
        throw H.wrapException(P.ArgumentError$("Uri " + H.S(uri) + " must have scheme 'file:'."));
      path = uri.get$path();
      if (uri.get$host() === "") {
        if (C.JSString_methods.startsWith$1(path, "/"))
          path = H.stringReplaceFirstUnchecked(path, "/", "");
      } else
        path = "\\\\" + H.S(uri.get$host()) + path;
      return P.Uri__uriDecode(H.stringReplaceAllUnchecked(path, "/", "\\"), C.Utf8Codec_false, false);
    },
    absolutePathToUri$1: function(path) {
      var parsed, t1, rootParts, t2;
      parsed = Q.ParsedPath_ParsedPath$parse(path, this);
      if (J.startsWith$1$s(parsed.root, "\\\\")) {
        t1 = J.split$1$s(parsed.root, "\\");
        rootParts = H.setRuntimeTypeInfo(new H.WhereIterable(t1, new T.WindowsStyle_absolutePathToUri_closure()), [H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(t1, 0)]), 0)]);
        C.JSArray_methods.insert$2(parsed.parts, 0, rootParts.get$last(rootParts));
        if (parsed.get$hasTrailingSeparator())
          parsed.parts.push("");
        return P.Uri_Uri(null, rootParts.get$first(rootParts), null, parsed.parts, null, null, null, "file", "");
      } else {
        if (parsed.parts.length === 0 || parsed.get$hasTrailingSeparator())
          parsed.parts.push("");
        t1 = parsed.parts;
        t2 = J.replaceAll$2$s(parsed.root, "/", "");
        C.JSArray_methods.insert$2(t1, 0, H.stringReplaceAllUnchecked(t2, "\\", ""));
        return P.Uri_Uri(null, null, null, parsed.parts, null, null, null, "file", "");
      }
    },
    _getRoot$1: function(path) {
      var t1, t2, start;
      t1 = J.getInterceptor$asx(path);
      if (J.$lt$n(t1.get$length(path), 3))
        return;
      if (N.isAlphabetic(t1.codeUnitAt$1(path, 0))) {
        if (t1.codeUnitAt$1(path, 1) !== 58)
          return;
        t2 = t1.codeUnitAt$1(path, 2);
        if (!(t2 === 47 || t2 === 92))
          return;
        return t1.substring$2(path, 0, 3);
      }
      if (!t1.startsWith$1(path, "\\\\"))
        return;
      start = 2;
      while (true) {
        t2 = t1.get$length(path);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(start < t2 && t1.codeUnitAt$1(path, start) !== 92))
          break;
        ++start;
      }
      if (start === 2 || start === t1.get$length(path))
        return;
      ++start;
      if (t1.codeUnitAt$1(path, start) === 92)
        return;
      ++start;
      while (true) {
        t2 = t1.get$length(path);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(start < t2 && t1.codeUnitAt$1(path, start) !== 92))
          break;
        ++start;
      }
      return t1.substring$2(path, 0, start);
    }
  },
  WindowsStyle_absolutePathToUri_closure: {
    "^": "Closure:58;",
    call$1: function(part) {
      return !J.$eq(part, "");
    },
    $isFunction: true
  }
}],
["path.utils", "package:path/src/utils.dart", , N, {
  "^": "",
  isAlphabetic: function($char) {
    var t1;
    if (!($char >= 65 && $char <= 90))
      t1 = $char >= 97 && $char <= 122;
    else
      t1 = true;
    return t1;
  }
}],
["stack_trace.src.utils", "package:stack_trace/src/utils.dart", , N, {
  "^": "",
  padRight: function(string, $length) {
    var t1, t2, result, i;
    t1 = J.getInterceptor$asx(string);
    t2 = t1.get$length(string);
    if (typeof $length !== "number")
      return H.iae($length);
    if (t2 >= $length)
      return string;
    result = P.StringBuffer$("");
    result.write$1(string);
    for (i = 0; i < $length - t1.get$length(string); ++i)
      result._contents += " ";
    return result._contents;
  }
}],
["trace", "package:stack_trace/src/trace.dart", , R, {
  "^": "",
  Trace: {
    "^": "Object;frames<",
    get$terse: function() {
      var t1 = this.foldFrames$1(new R.Trace_terse_closure()).frames;
      return new R.Trace(H.setRuntimeTypeInfo(new P.UnmodifiableListView(t1.map$1(t1, new R.Trace_terse_closure0()).toList$0(0)), [S.Frame]));
    },
    foldFrames$1: function(predicate) {
      var newFrames, t1, frame;
      newFrames = H.setRuntimeTypeInfo([], [S.Frame]);
      for (t1 = this.frames, t1 = t1.get$reversed(t1), t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.get$length(t1), 0, null), [H.getRuntimeTypeArgument(t1, "ListIterable", 0)]); t1.moveNext$0();) {
        frame = t1._current;
        if (predicate.call$1(frame) !== true)
          newFrames.push(frame);
        else if (newFrames.length === 0 || predicate.call$1(C.JSArray_methods.get$last(newFrames)) !== true)
          newFrames.push(new S.Frame(frame.get$uri(), frame.get$line(), frame.get$column(), frame.get$member()));
      }
      return new R.Trace(H.setRuntimeTypeInfo(new P.UnmodifiableListView(H.setRuntimeTypeInfo(new H.ReversedListIterable(newFrames), [H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(newFrames, 0)]), 0)]).toList$0(0)), [S.Frame]));
    },
    toString$0: function(_) {
      var t1 = this.frames;
      return t1.map$1(t1, new R.Trace_toString_closure(t1.map$1(t1, new R.Trace_toString_closure0()).fold$2(0, 0, P.max$closure()))).join$0(0);
    },
    $isTrace: true,
    $isStackTrace: true,
    static: {Trace_Trace$from: function(trace) {
        if (!!trace.$isTrace)
          return trace;
        return new S.LazyTrace(new R.Trace_Trace$from_closure(trace), null);
      }, Trace_Trace$parse: function(trace) {
        var error, t1, exception;
        try {
          if (J.get$isEmpty$asx(trace) === true) {
            t1 = H.setRuntimeTypeInfo(new P.UnmodifiableListView(C.JSArray_methods.toList$0(H.setRuntimeTypeInfo([], [S.Frame]))), [S.Frame]);
            return new R.Trace(t1);
          }
          if (J.contains$1$asx(trace, $.get$_v8Trace()) === true) {
            t1 = R.Trace$parseV8(trace);
            return t1;
          }
          if (J.contains$1$asx(trace, $.get$_safariTrace()) === true) {
            t1 = R.Trace$parseSafari6_1(trace);
            return t1;
          }
          if (J.contains$1$asx(trace, $.get$_firefoxTrace()) === true) {
            t1 = R.Trace$parseSafari6_0(trace);
            return t1;
          }
          if (J.contains$1$asx(trace, $.get$_friendlyTrace()) === true) {
            t1 = R.Trace$parseFriendly(trace);
            return t1;
          }
          t1 = R.Trace$parseVM(trace);
          return t1;
        } catch (exception) {
          t1 = H.unwrapException(exception);
          if (!!J.getInterceptor(t1).$isFormatException) {
            error = t1;
            throw H.wrapException(P.FormatException$(H.S(error.get$message()) + "\nStack trace:\n" + H.S(trace), null, null));
          } else
            throw exception;
        }

      }, Trace$parseVM: function(trace) {
        var t1 = J.trim$0$s(trace).split("\n");
        t1 = H.setRuntimeTypeInfo(new H.WhereIterable(t1, new R.Trace$parseVM_closure()), [H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(t1, 0)]), 0)]);
        return new R.Trace(H.setRuntimeTypeInfo(new P.UnmodifiableListView(H.MappedIterable_MappedIterable(t1, new R.Trace$parseVM_closure0(), H.getRuntimeTypeArgument(t1, "IterableBase", 0), null).toList$0(0)), [S.Frame]));
      }, Trace$parseV8: function(trace) {
        var t1 = J.split$1$s(trace, "\n");
        t1 = H.SubListIterable$(t1, 1, null, H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(t1, 0)]), 0));
        t1 = P.IterableBase.prototype.skipWhile$1.call(t1, t1, new R.Trace$parseV8_closure());
        return new R.Trace(H.setRuntimeTypeInfo(new P.UnmodifiableListView(H.MappedIterable_MappedIterable(t1, new R.Trace$parseV8_closure0(), H.getRuntimeTypeArgument(t1, "IterableBase", 0), null).toList$0(0)), [S.Frame]));
      }, Trace$parseSafari6_1: function(trace) {
        var t1 = J.trim$0$s(trace).split("\n");
        t1 = H.setRuntimeTypeInfo(new H.WhereIterable(t1, new R.Trace$parseSafari6_1_closure()), [H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(t1, 0)]), 0)]);
        return new R.Trace(H.setRuntimeTypeInfo(new P.UnmodifiableListView(H.MappedIterable_MappedIterable(t1, new R.Trace$parseSafari6_1_closure0(), H.getRuntimeTypeArgument(t1, "IterableBase", 0), null).toList$0(0)), [S.Frame]));
      }, Trace$parseSafari6_0: function(trace) {
        var t1 = J.trim$0$s(trace).split("\n");
        t1 = H.setRuntimeTypeInfo(new H.WhereIterable(t1, new R.Trace$parseSafari6_0_closure()), [H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(t1, 0)]), 0)]);
        return new R.Trace(H.setRuntimeTypeInfo(new P.UnmodifiableListView(H.MappedIterable_MappedIterable(t1, new R.Trace$parseSafari6_0_closure0(), H.getRuntimeTypeArgument(t1, "IterableBase", 0), null).toList$0(0)), [S.Frame]));
      }, Trace$parseFriendly: function(trace) {
        var t1 = J.trim$0$s(trace).split("\n");
        t1 = H.setRuntimeTypeInfo(new H.WhereIterable(t1, new R.Trace$parseFriendly_closure()), [H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(t1, 0)]), 0)]);
        return new R.Trace(H.setRuntimeTypeInfo(new P.UnmodifiableListView(H.MappedIterable_MappedIterable(t1, new R.Trace$parseFriendly_closure0(), H.getRuntimeTypeArgument(t1, "IterableBase", 0), null).toList$0(0)), [S.Frame]));
      }}
  },
  Trace_Trace$from_closure: {
    "^": "Closure:55;trace_0",
    call$0: function() {
      return R.Trace_Trace$parse(this.trace_0.toString$0(0));
    },
    $isFunction: true
  },
  Trace$parseVM_closure: {
    "^": "Closure:58;",
    call$1: function(line) {
      return J.get$isNotEmpty$asx(line);
    },
    $isFunction: true
  },
  Trace$parseVM_closure0: {
    "^": "Closure:58;",
    call$1: [function(line) {
      return S.Frame_Frame$parseVM(line);
    }, "call$1", null, 2, 0, null, 37, "call"],
    $isFunction: true
  },
  Trace$parseV8_closure: {
    "^": "Closure:58;",
    call$1: function(line) {
      return !J.startsWith$1$s(line, $.get$_v8TraceLine());
    },
    $isFunction: true
  },
  Trace$parseV8_closure0: {
    "^": "Closure:58;",
    call$1: [function(line) {
      return S.Frame_Frame$parseV8(line);
    }, "call$1", null, 2, 0, null, 37, "call"],
    $isFunction: true
  },
  Trace$parseSafari6_1_closure: {
    "^": "Closure:58;",
    call$1: function(line) {
      return J.get$isNotEmpty$asx(line);
    },
    $isFunction: true
  },
  Trace$parseSafari6_1_closure0: {
    "^": "Closure:58;",
    call$1: [function(line) {
      var match, t1, uri, t2, member, column;
      match = $.get$_safariFrame().firstMatch$1(line);
      if (match == null)
        H.throwExpression(P.FormatException$("Couldn't parse Safari stack trace line '" + H.S(line) + "'.", null, null));
      t1 = match._match;
      if (2 >= t1.length)
        return H.ioore(t1, 2);
      uri = P.Uri_parse(t1[2]);
      t2 = t1.length;
      if (1 >= t2)
        return H.ioore(t1, 1);
      member = t1[1];
      if (member == null)
        member = "<fn>";
      if (3 >= t2)
        return H.ioore(t1, 3);
      if (J.$eq(t1[3], ""))
        line = null;
      else {
        if (3 >= t1.length)
          return H.ioore(t1, 3);
        line = H.Primitives_parseInt(t1[3], null, null);
      }
      if (4 >= t1.length)
        return H.ioore(t1, 4);
      if (J.$eq(t1[4], ""))
        column = null;
      else {
        if (4 >= t1.length)
          return H.ioore(t1, 4);
        column = H.Primitives_parseInt(t1[4], null, null);
      }
      return new S.Frame(uri, line, column, member);
    }, "call$1", null, 2, 0, null, 37, "call"],
    $isFunction: true
  },
  Trace$parseSafari6_0_closure: {
    "^": "Closure:58;",
    call$1: function(line) {
      return !J.$eq(line, "[native code]");
    },
    $isFunction: true
  },
  Trace$parseSafari6_0_closure0: {
    "^": "Closure:58;",
    call$1: [function(line) {
      var match, t1, uri, t2, member;
      match = $.get$_firefoxFrame().firstMatch$1(line);
      if (match == null)
        H.throwExpression(P.FormatException$("Couldn't parse Firefox stack trace line '" + H.S(line) + "'.", null, null));
      t1 = match._match;
      if (3 >= t1.length)
        return H.ioore(t1, 3);
      uri = S.Frame__uriOrPathToUri(t1[3]);
      t2 = t1.length;
      if (1 >= t2)
        return H.ioore(t1, 1);
      member = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      member = J.$add$ns(member, C.JSArray_methods.join$0(P.List_List$filled(C.JSString_methods.allMatches$1("/", t1[2]).length, ".<fn>", null)));
      if (J.$eq(member, ""))
        member = "<fn>";
      member = J.replaceFirst$2$s(member, $.get$_initialDot(), "");
      if (4 >= t1.length)
        return H.ioore(t1, 4);
      return new S.Frame(uri, H.Primitives_parseInt(t1[4], null, null), null, member);
    }, "call$1", null, 2, 0, null, 37, "call"],
    $isFunction: true
  },
  Trace$parseFriendly_closure: {
    "^": "Closure:58;",
    call$1: function(line) {
      return !J.startsWith$1$s(line, "=====");
    },
    $isFunction: true
  },
  Trace$parseFriendly_closure0: {
    "^": "Closure:58;",
    call$1: [function(line) {
      var match, t1, uri, t2, t3, t4, column;
      match = $.get$_friendlyFrame().firstMatch$1(line);
      if (match == null)
        H.throwExpression(P.FormatException$("Couldn't parse package:stack_trace stack trace line '" + H.S(line) + "'.", null, null));
      t1 = match._match;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      uri = P.Uri_parse(t1[1]);
      if (uri.scheme === "") {
        t2 = $.get$context();
        t3 = t2.fromUri$1(uri);
        t4 = t2._context0$_current;
        uri = t2.toUri$1(t2.join$8(0, t4 != null ? t4 : B.current(), t3, null, null, null, null, null, null));
      }
      if (2 >= t1.length)
        return H.ioore(t1, 2);
      t2 = t1[2];
      line = t2 == null ? null : H.Primitives_parseInt(t2, null, null);
      if (3 >= t1.length)
        return H.ioore(t1, 3);
      t2 = t1[3];
      column = t2 == null ? null : H.Primitives_parseInt(t2, null, null);
      if (4 >= t1.length)
        return H.ioore(t1, 4);
      return new S.Frame(uri, line, column, t1[4]);
    }, "call$1", null, 2, 0, null, 37, "call"],
    $isFunction: true
  },
  Trace_terse_closure: {
    "^": "Closure:58;",
    call$1: function(frame) {
      return frame.get$isCore() || J.$eq(frame.get$$package(), "stack_trace");
    },
    $isFunction: true
  },
  Trace_terse_closure0: {
    "^": "Closure:58;",
    call$1: [function(frame) {
      var t1, t2;
      if (!frame.get$isCore())
        return frame;
      t1 = frame.get$library();
      t2 = $.get$_terseRegExp();
      return new S.Frame(P.Uri_parse(H.stringReplaceAllUnchecked(t1, t2, "")), null, null, frame.get$member());
    }, "call$1", null, 2, 0, null, 144, "call"],
    $isFunction: true
  },
  Trace_toString_closure0: {
    "^": "Closure:58;",
    call$1: [function(frame) {
      return J.get$length$asx(frame.get$location());
    }, "call$1", null, 2, 0, null, 144, "call"],
    $isFunction: true
  },
  Trace_toString_closure: {
    "^": "Closure:58;longest_0",
    call$1: [function(frame) {
      return H.S(N.padRight(frame.get$location(), this.longest_0)) + "  " + H.S(frame.get$member()) + "\n";
    }, "call$1", null, 2, 0, null, 144, "call"],
    $isFunction: true
  }
}],
["", "trackerserver_test.dart", , T, {
  "^": "",
  main: [function() {
    var test, ticket, infoHash, peerId, tracker, manager, peerIdA, peerIdB;
    P.print("---");
    test = new V.HetiTest(P.LinkedHashMap_LinkedHashMap(null, null, null, null, null), 0, "");
    test._id = "t";
    ticket = test.test$2("n", 3000);
    infoHash = V.PeerIdCreator_createPeerid("heti");
    peerId = V.PeerIdCreator_createPeerid("heti");
    tracker = new K.TrackerServer(null, null, null, true, []);
    tracker.address = "127.0.0.1";
    tracker.port = 6969;
    tracker.add$1(0, $.get$PercentEncode__sencoder().encodeWork$1(infoHash));
    manager = tracker.find$1(infoHash);
    P.Future_Future$sync(new T.main_closure(infoHash, peerId, tracker), null).then$1(new T.main_closure0(ticket, manager)).whenComplete$1(new T.main_closure1(ticket));
    ticket = test.test$2("m", 3000);
    peerId = V.PeerIdCreator_createPeerid("-d-");
    ticket.assertTrue$2("", V.PeerAddress$(peerId, "s", [127, 0, 0, 1], 6060).$eq(0, V.PeerAddress$(peerId, "s", [127, 0, 0, 1], 6061)));
    ticket.fin$0();
    ticket = test.test$2("s", 3000);
    peerIdA = V.PeerIdCreator_createPeerid("-d-");
    peerIdB = V.PeerIdCreator_createPeerid("-e-");
    ticket.assertTrue$2("", !V.PeerAddress$(peerIdA, "s", [127, 0, 0, 1], 6060).$eq(0, V.PeerAddress$(peerIdB, "s", [127, 0, 0, 1], 6061)));
    ticket.fin$0();
  }, "call$0", "main$closure", 0, 0, 12],
  main_closure: {
    "^": "Closure:55;infoHash_0,peerId_1,tracker_2",
    call$0: function() {
      return this.tracker_2.start$0().then$1(new T.main__closure(this.infoHash_0, this.peerId_1));
    },
    $isFunction: true
  },
  main__closure: {
    "^": "Closure:146;infoHash_3,peerId_4",
    call$1: [function(result) {
      var t1;
      P.print("--[2]-");
      t1 = new V.TrackerUrl("127.0.0.1", 6969, "/announce", "http", 6969, "", "", "", 0, 0, 0);
      t1.trackerHost = "127.0.0.1";
      t1.trackerPort = 6969;
      t1.peerID = $.get$PercentEncode__sencoder().encodeWork$1(this.peerId_4);
      t1.infoHashValue = $.get$PercentEncode__sencoder().encodeWork$1(this.infoHash_3);
      return new K.TrackerClientSv(t1).request$0();
    }, "call$1", null, 2, 0, null, 145, "call"],
    $isFunction: true
  },
  main_closure0: {
    "^": "Closure:147;ticket_5,manager_6",
    call$1: [function(r) {
      var t1, t2, t3, t4, t5;
      if ($._currentTestCaseIndex !== -1)
        H.throwExpression(P.StateError$("Not allowed when tests are running."));
      N._ensureInitialized(true);
      if (!$._soloTestSeen || $._soloNestingLevel > 0) {
        t1 = $.get$testCases()._collection$_source.length;
        t2 = N._fullSpec("");
        t3 = $.get$_currentContext().get$fullName();
        t4 = $.get$_currentContext();
        t5 = t4._testSetup;
        t4 = t4._testTeardown;
        $.get$_testCases().push(new N.TestCase(t1 + 1, t2, t5, t4, new T.main__closure0(this.ticket_5, this.manager_6, r), 0, "", null, null, t3, null, null, true, false, null));
      }
    }, "call$1", null, 2, 0, null, 135, "call"],
    $isFunction: true
  },
  main__closure0: {
    "^": "Closure:55;ticket_7,manager_8,r_9",
    call$0: function() {
      var t1, t2;
      t1 = this.ticket_7;
      t2 = this.r_9;
      t1.assertTrue$2("1:", t2.get$code() === 0);
      t1.assertTrue$2("2:", J.$eq(t2.get$response().get$interval(), this.manager_8.get$interval()));
      t2 = t2.get$response().get$peers();
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      t1.assertTrue$2("3:", J.$eq(t2[0].port, 6969));
    },
    $isFunction: true
  },
  main_closure1: {
    "^": "Closure:55;ticket_10",
    call$0: [function() {
      this.ticket_10.fin$0();
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  }
},
1],
["unittest", "package:unittest/unittest.dart", , N, {
  "^": "",
  unittestConfiguration: function() {
    var t1 = $._config;
    if (t1 == null) {
      t1 = new N.SimpleConfiguration(null, true, true, H.setRuntimeTypeInfo([], [[V.Pair, P.String, P.StackTrace]]), C.Duration_120000000);
      if ($._assertErrorFormatter == null)
        $._assertErrorFormatter = Y._defaultErrorFormatter$closure();
      Y.configureExpectFailureHandler(new N._ExpectFailureHandler(t1));
      $._config = t1;
    }
    return t1;
  },
  _nextTestCase: [function() {
    var t1 = $._currentTestCaseIndex;
    if (typeof t1 !== "number")
      return t1.$add();
    $._currentTestCaseIndex = t1 + 1;
    N._runTest();
  }, "call$0", "_nextTestCase$closure", 0, 0, 12],
  runTests: [function() {
    if ($._currentTestCaseIndex !== -1)
      H.throwExpression(P.StateError$("Not allowed when tests are running."));
    N._ensureInitialized(false);
    $._currentTestCaseIndex = 0;
    $._config.toString;
    N._runTest();
  }, "call$0", "runTests$closure", 0, 0, 12],
  _registerException: function(testCase, e, trace) {
    var message = !!J.getInterceptor(e).$isTestFailure ? e.message : "Caught " + H.S(e);
    if (testCase.get$result() == null)
      testCase._fail$2(message, trace);
    else
      testCase._unittest$_error$2(message, trace);
  },
  _runTest: function() {
    var t1, testCase, timeout, e, t2, t3, t4, f, exception;
    t1 = {};
    t2 = $._currentTestCaseIndex;
    t3 = $.get$testCases()._collection$_source;
    t4 = t3.length;
    if (typeof t2 !== "number")
      return t2.$ge();
    if (t2 >= t4)
      N._completeTests();
    else {
      if (t2 < 0)
        return H.ioore(t3, t2);
      testCase = t3[t2];
      f = P.runZoned(testCase.get$_run(), new N._runTest_closure(testCase), null, null);
      timeout = N.unittestConfiguration().timeout;
      t1.timer_0 = null;
      if (timeout != null)
        try {
          t1.timer_0 = P.Timer_Timer(timeout, new N._runTest_closure0(testCase, timeout));
        } catch (exception) {
          t2 = H.unwrapException(exception);
          if (!!J.getInterceptor(t2).$isUnsupportedError) {
            e = t2;
            if (!J.$eq(e.get$message(), "Timer greater than 0."))
              throw exception;
          } else
            throw exception;
        }

      f.whenComplete$1(new N._runTest_closure1(t1));
    }
  },
  _completeTests: function() {
    var t1, passed, failed, errors, t2;
    if (!$._initialized)
      return;
    for (t1 = $.get$testCases(), t1 = t1.get$iterator(t1), passed = 0, failed = 0, errors = 0; t1.moveNext$0();)
      switch (t1._current.get$result()) {
        case "pass":
          ++passed;
          break;
        case "fail":
          ++failed;
          break;
        case "error":
          ++errors;
          break;
      }
    $._config.onSummary$5(passed, failed, errors, $.get$testCases(), $._uncaughtErrorMessage);
    t1 = $._config;
    t2 = passed > 0 && failed === 0 && errors === 0 && true;
    t1.toString;
    if (t2) {
      P.print("unittest-suite-success");
      t1 = t1._receivePort;
      t1._rawPort.close$0();
      t1.__isolate_helper$_controller.close$0();
    } else {
      t2 = t1._receivePort;
      t2._rawPort.close$0();
      t2.__isolate_helper$_controller.close$0();
      if (t1.throwOnTestFailures)
        H.throwExpression(P.Exception_Exception("Some tests failed."));
    }
    $._initialized = false;
    $._currentTestCaseIndex = -1;
  },
  _fullSpec: function(spec) {
    var group = $.get$_currentContext().get$fullName();
    return group !== "" ? group + $.groupSep + spec : spec;
  },
  _ensureInitialized: function(configAutoStart) {
    var t1, t2, t3, t4;
    if ($._initialized)
      return;
    $._initialized = true;
    $.wrapAsync = new N._ensureInitialized_closure();
    $._uncaughtErrorMessage = null;
    t1 = N.unittestConfiguration();
    t1.toString;
    $.filterStacks = false;
    t2 = $.RawReceivePortImpl__nextFreeId;
    $.RawReceivePortImpl__nextFreeId = t2 + 1;
    t3 = new H.RawReceivePortImpl(t2, null, false);
    t4 = init.globalState.currentContext;
    t4._addRegistration$2(t2, t3);
    t4._updateGlobalState$0();
    t4 = new H.ReceivePortImpl(t3, null);
    t4.ReceivePortImpl$fromRawReceivePort$1(t3);
    t1._receivePort = t4;
    P.print("unittest-suite-wait-for-done");
    if (configAutoStart) {
      $._config.toString;
      t1 = true;
    } else
      t1 = false;
    if (t1)
      P.scheduleMicrotask(N.runTests$closure());
  },
  _GroupContext: {
    "^": "Object;parent<,_unittest$_name,_testSetup,_testTeardown",
    get$fullName: function() {
      return this._unittest$_name;
    }
  },
  _ExpectFailureHandler: {
    "^": "DefaultFailureHandler;_config"
  },
  SimpleConfiguration: {
    "^": "Configuration;_receivePort,throwOnTestFailures,stopTestOnExpectFailure,_testLogBuffer,timeout",
    get$name: function() {
      return "Configuration";
    },
    onTestResult$1: function(testCase) {
      var reason, t1, t2, reasonAndTrace, t3, str, t4, lastReasonAndTrace;
      if (!this.stopTestOnExpectFailure && this._testLogBuffer.length > 0) {
        reason = P.StringBuffer$("");
        for (t1 = this._testLogBuffer, t2 = H.SubListIterable$(t1, 0, t1.length - 1, H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(t1, 0)]), 0)), t2 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.get$length(t2), 0, null), [H.getRuntimeTypeArgument(t2, "ListIterable", 0)]); t2.moveNext$0();) {
          reasonAndTrace = t2._current;
          t3 = J.getInterceptor$ax(reasonAndTrace);
          str = t3.get$first(reasonAndTrace);
          t4 = reason._contents += typeof str === "string" ? str : H.S(str);
          reason._contents = t4 + "\n";
          str = t3.get$last(reasonAndTrace);
          t3 = reason._contents += typeof str === "string" ? str : H.S(str);
          reason._contents = t3 + "\n";
        }
        lastReasonAndTrace = C.JSArray_methods.get$last(t1);
        reason.write$1(lastReasonAndTrace.get$first(lastReasonAndTrace));
        if (testCase._result === "pass") {
          testCase._result = "fail";
          testCase._unittest$_message = reason._contents;
          testCase._stackTrace = lastReasonAndTrace.get$last(lastReasonAndTrace);
        } else {
          reason.write$1(lastReasonAndTrace.get$last(lastReasonAndTrace));
          reason.write$1("\n");
          testCase._unittest$_message = reason._contents + "\n" + testCase._unittest$_message;
        }
      }
    },
    onSummary$5: function(passed, failed, errors, results, uncaughtError) {
      var t1, t, result, t2, t3, line;
      for (t1 = results.get$iterator(results); t1.moveNext$0();) {
        t = t1._current;
        result = new P.StringBuffer("");
        result._contents = "";
        t2 = t.get$result();
        t2.toString;
        t2 = t2.toUpperCase();
        result._contents = t2;
        t2 += ": ";
        result._contents = t2;
        t3 = t.get$description();
        t2 += t3;
        result._contents = t2;
        t2 += "\n";
        result._contents = t2;
        if (!J.$eq(t.get$message(), "")) {
          t3 = J.replaceAll$2$s(t.get$message(), new H.JSSyntaxRegExp("^", H.JSSyntaxRegExp_makeNative("^", true, true, false), null, null), "  ");
          t2 += t3;
          result._contents = t2;
          t2 += "\n";
          result._contents = t2;
        }
        if (t.get$stackTrace() != null) {
          t3 = J.replaceAll$2$s(J.toString$0(t.get$stackTrace()), new H.JSSyntaxRegExp("^", H.JSSyntaxRegExp_makeNative("^", true, true, false), null, null), "  ");
          t2 += t3;
          result._contents = t2;
          t2 += "\n";
          result._contents = t2;
        }
        line = C.JSString_methods.trim$0(t2);
        t2 = $.printToZone;
        if (t2 == null)
          H.printString(line);
        else
          t2.call$1(line);
      }
      P.print("");
      if (passed === 0 && failed === 0 && errors === 0 && true)
        P.print("No tests found.");
      else if (failed === 0 && errors === 0 && true)
        P.print("All " + passed + " tests passed.");
      else
        P.print("" + passed + " PASSED, " + failed + " FAILED, " + errors + " ERRORS");
    }
  },
  _ArgPlaceHolder: {
    "^": "Object;"
  },
  _SpreadArgsHelper: {
    "^": "Object;callback,minExpectedCalls,maxExpectedCalls,isDone,id,actualCalls,testCase,complete",
    callback$0: function() {
      return this.callback.call$0();
    },
    shouldCallBack$0: function() {
      ++this.actualCalls;
      var t1 = this.testCase;
      if (t1.get$isComplete()) {
        if (t1.get$result() === "pass")
          t1._unittest$_error$1("Callback " + this.id + "called (" + this.actualCalls + ") after test case " + t1.get$description() + " has already been marked as " + H.S(t1.get$result()) + ".");
        return false;
      } else {
        t1 = this.maxExpectedCalls;
        if (this.actualCalls > t1)
          throw H.wrapException(Y.TestFailure$("Callback " + this.id + "called more times than expected (" + t1 + ")."));
      }
      return true;
    },
    after$0: [function() {
      if (!this.complete) {
        var t1 = this.minExpectedCalls;
        if (t1 > 0 && this.actualCalls < t1)
          return;
        this.complete = true;
        this.testCase._markCallbackComplete$0();
      }
    }, "call$0", "get$after", 0, 0, 12],
    get$func: function() {
      var t1, t2, t3;
      t1 = this.callback;
      t2 = H.getDynamicRuntimeType();
      t3 = H.buildFunctionType(t2, [t2, t2, t2, t2, t2, t2])._isTest$1(t1);
      if (t3)
        return this.get$_max6();
      t3 = H.buildFunctionType(t2, [t2, t2, t2, t2, t2])._isTest$1(t1);
      if (t3)
        return this.get$_max5();
      t3 = H.buildFunctionType(t2, [t2, t2, t2, t2])._isTest$1(t1);
      if (t3)
        return this.get$_max4();
      t3 = H.buildFunctionType(t2, [t2, t2, t2])._isTest$1(t1);
      if (t3)
        return this.get$_max3();
      t3 = H.buildFunctionType(t2, [t2, t2])._isTest$1(t1);
      if (t3)
        return this.get$_max2();
      t3 = H.buildFunctionType(t2, [t2])._isTest$1(t1);
      if (t3)
        return this.get$_max1();
      t2 = H.buildFunctionType(t2)._isTest$1(t1);
      if (t2)
        return this.get$_max0();
      throw H.wrapException(P.ArgumentError$("The callback argument has more than 6 required arguments"));
    },
    _max0$0: [function() {
      return this._max6$0();
    }, "call$0", "get$_max0", 0, 0, 55],
    _max1$1: [function(a0) {
      return this._max6$1(a0);
    }, function() {
      return this._max1$1(C.C__ArgPlaceHolder);
    }, "_max1$0", "call$1", "call$0", "get$_max1", 0, 2, 148, 149, 150],
    _max2$2: [function(a0, a1) {
      return this._max6$2(a0, a1);
    }, function(a0) {
      return this._max2$2(a0, C.C__ArgPlaceHolder);
    }, "_max2$1", function() {
      return this._max2$2(C.C__ArgPlaceHolder, C.C__ArgPlaceHolder);
    }, "_max2$0", "call$2", "call$1", "call$0", "get$_max2", 0, 4, 151, 149, 149, 150, 152],
    _max3$3: [function(a0, a1, a2) {
      return this._max6$3(a0, a1, a2);
    }, function(a0) {
      return this._max3$3(a0, C.C__ArgPlaceHolder, C.C__ArgPlaceHolder);
    }, "_max3$1", function() {
      return this._max3$3(C.C__ArgPlaceHolder, C.C__ArgPlaceHolder, C.C__ArgPlaceHolder);
    }, "_max3$0", function(a0, a1) {
      return this._max3$3(a0, a1, C.C__ArgPlaceHolder);
    }, "_max3$2", "call$3", "call$1", "call$0", "call$2", "get$_max3", 0, 6, 153, 149, 149, 149, 150, 152, 154],
    _max4$4: [function(a0, a1, a2, a3) {
      return this._max6$4(a0, a1, a2, a3);
    }, function(a0) {
      return this._max4$4(a0, C.C__ArgPlaceHolder, C.C__ArgPlaceHolder, C.C__ArgPlaceHolder);
    }, "_max4$1", function() {
      return this._max4$4(C.C__ArgPlaceHolder, C.C__ArgPlaceHolder, C.C__ArgPlaceHolder, C.C__ArgPlaceHolder);
    }, "_max4$0", function(a0, a1) {
      return this._max4$4(a0, a1, C.C__ArgPlaceHolder, C.C__ArgPlaceHolder);
    }, "_max4$2", function(a0, a1, a2) {
      return this._max4$4(a0, a1, a2, C.C__ArgPlaceHolder);
    }, "_max4$3", "call$4", "call$1", "call$0", "call$2", "call$3", "get$_max4", 0, 8, 155, 149, 149, 149, 149, 150, 152, 154, 156],
    _max5$5: [function(a0, a1, a2, a3, a4) {
      return this._max6$5(a0, a1, a2, a3, a4);
    }, function(a0) {
      return this._max5$5(a0, C.C__ArgPlaceHolder, C.C__ArgPlaceHolder, C.C__ArgPlaceHolder, C.C__ArgPlaceHolder);
    }, "_max5$1", function() {
      return this._max5$5(C.C__ArgPlaceHolder, C.C__ArgPlaceHolder, C.C__ArgPlaceHolder, C.C__ArgPlaceHolder, C.C__ArgPlaceHolder);
    }, "_max5$0", function(a0, a1) {
      return this._max5$5(a0, a1, C.C__ArgPlaceHolder, C.C__ArgPlaceHolder, C.C__ArgPlaceHolder);
    }, "_max5$2", function(a0, a1, a2, a3) {
      return this._max5$5(a0, a1, a2, a3, C.C__ArgPlaceHolder);
    }, "_max5$4", function(a0, a1, a2) {
      return this._max5$5(a0, a1, a2, C.C__ArgPlaceHolder, C.C__ArgPlaceHolder);
    }, "_max5$3", "call$5", "call$1", "call$0", "call$2", "call$4", "call$3", "get$_max5", 0, 10, 157, 149, 149, 149, 149, 149, 150, 152, 154, 156, 158],
    _max6$6: [function(a0, a1, a2, a3, a4, a5) {
      var args = [a0, a1, a2, a3, a4, a5];
      H.IterableMixinWorkaround_removeWhereList(args, new N._SpreadArgsHelper__max6_closure());
      return this._guardAsync$3(new N._SpreadArgsHelper__max6_closure0(this, args), this.get$after(), this.testCase);
    }, function() {
      return this._max6$6(C.C__ArgPlaceHolder, C.C__ArgPlaceHolder, C.C__ArgPlaceHolder, C.C__ArgPlaceHolder, C.C__ArgPlaceHolder, C.C__ArgPlaceHolder);
    }, "_max6$0", function(a0) {
      return this._max6$6(a0, C.C__ArgPlaceHolder, C.C__ArgPlaceHolder, C.C__ArgPlaceHolder, C.C__ArgPlaceHolder, C.C__ArgPlaceHolder);
    }, "_max6$1", function(a0, a1) {
      return this._max6$6(a0, a1, C.C__ArgPlaceHolder, C.C__ArgPlaceHolder, C.C__ArgPlaceHolder, C.C__ArgPlaceHolder);
    }, "_max6$2", function(a0, a1, a2) {
      return this._max6$6(a0, a1, a2, C.C__ArgPlaceHolder, C.C__ArgPlaceHolder, C.C__ArgPlaceHolder);
    }, "_max6$3", function(a0, a1, a2, a3) {
      return this._max6$6(a0, a1, a2, a3, C.C__ArgPlaceHolder, C.C__ArgPlaceHolder);
    }, "_max6$4", function(a0, a1, a2, a3, a4) {
      return this._max6$6(a0, a1, a2, a3, a4, C.C__ArgPlaceHolder);
    }, "_max6$5", "call$6", "call$0", "call$1", "call$2", "call$3", "call$4", "call$5", "get$_max6", 0, 12, 159, 149, 149, 149, 149, 149, 149, 150, 152, 154, 156, 158, 160],
    _guardAsync$3: function(tryBody, finallyBody, testCase) {
      var e, trace, t1, exception;
      try {
        t1 = tryBody.call$0();
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        trace = new H._StackTrace(exception, null);
        N._registerException(testCase, e, trace);
      }
 finally {
        if (finallyBody != null)
          finallyBody.call$0();
      }
    },
    _SpreadArgsHelper$5$isDone: function(callback, minExpected, maxExpected, id, isDone) {
      var t1;
      N._ensureInitialized(true);
      t1 = this.testCase;
      if (t1 == null)
        throw H.wrapException(P.StateError$("No valid test. Did you forget to run your test inside a call to test()?"));
      if (minExpected > 0) {
        t1.set$_callbackFunctionsOutstanding(t1.get$_callbackFunctionsOutstanding() + 1);
        this.complete = false;
      } else
        this.complete = true;
    },
    static: {_SpreadArgsHelper__makeCallbackId: function(id, callback) {
        return H.S(id) + " ";
      }}
  },
  _SpreadArgsHelper__max6_closure: {
    "^": "Closure:58;",
    call$1: function(a) {
      return J.$eq(a, C.C__ArgPlaceHolder);
    },
    $isFunction: true
  },
  _SpreadArgsHelper__max6_closure0: {
    "^": "Closure:55;this_0,args_1",
    call$0: function() {
      var t1 = this.this_0;
      if (t1.shouldCallBack$0())
        return H.Primitives_applyFunction(t1.callback, this.args_1, P.Function__toMangledNames(null));
    },
    $isFunction: true
  },
  TestCase: {
    "^": "Object;id,description<,_setUp,_tearDown,_testFunction,_callbackFunctionsOutstanding@,_unittest$_message,_result,_stackTrace,currentGroup,_startTime,_runningTime,_enabled,_doneTeardown,_testComplete",
    _testFunction$0: function() {
      return this._testFunction.call$0();
    },
    get$message: function() {
      return this._unittest$_message;
    },
    get$result: function() {
      return this._result;
    },
    get$stackTrace: function() {
      return this._stackTrace;
    },
    get$isComplete: function() {
      return !this._enabled || this._result != null;
    },
    _errorHandler$1: function(stage) {
      return new N.TestCase__errorHandler_closure(this, stage);
    },
    _run$0: [function() {
      if (!this._enabled)
        return P._Future$immediate(null, null);
      this._stackTrace = null;
      this._result = null;
      this._unittest$_message = "";
      return P._Future$immediate(null, null).then$1(new N.TestCase__run_closure(this)).catchError$1(this._errorHandler$1("Setup")).then$1(new N.TestCase__run_closure0(this)).catchError$1(this._errorHandler$1("Test")).then$1(new N.TestCase__run_closure1(this)).catchError$1(this._errorHandler$1("Teardown")).whenComplete$1(new N.TestCase__run_closure2(this));
    }, "call$0", "get$_run", 0, 0, 73],
    _unittest$_complete$3: function(testResult, messageText, stack) {
      var t1, otherMs, t2;
      if (this._runningTime == null)
        if (this._startTime != null) {
          t1 = Date.now();
          new P.DateTime(t1, false).DateTime$_now$0();
          otherMs = this._startTime.millisecondsSinceEpoch;
          if (typeof t1 !== "number")
            return t1.$sub();
          if (typeof otherMs !== "number")
            return H.iae(otherMs);
          this._runningTime = P.Duration$(0, 0, 0, t1 - otherMs, 0, 0);
        } else
          this._runningTime = C.Duration_0;
      this._unittest$_message = messageText;
      t1 = V.getTrace(stack, $.formatStacks, $.filterStacks);
      this._stackTrace = t1;
      if (t1 == null)
        this._stackTrace = stack;
      t1 = this._result;
      t2 = $._config;
      if (t1 == null) {
        this._result = testResult;
        t2.onTestResult$1(this);
      } else {
        this._result = testResult;
        t2.toString;
      }
      t1 = this._testComplete;
      if (t1 != null) {
        this._testComplete = null;
        t1 = t1.future;
        if (t1._state !== 0)
          H.throwExpression(P.StateError$("Future already completed"));
        t1._asyncComplete$1(this);
      }
    },
    _unittest$_complete$1: function(testResult) {
      return this._unittest$_complete$3(testResult, "", null);
    },
    _fail$2: function(messageText, stack) {
      var t1 = this._result;
      if (t1 != null)
        this._unittest$_complete$3("error", t1 === "pass" ? "Test failed after initially passing: " + messageText : "Test failed more than once: " + messageText, stack);
      else
        this._unittest$_complete$3("fail", messageText, stack);
    },
    _unittest$_error$2: function(messageText, stack) {
      this._unittest$_complete$3("error", messageText, stack);
    },
    _unittest$_error$1: function(messageText) {
      return this._unittest$_error$2(messageText, null);
    },
    _markCallbackComplete$0: [function() {
      if (--this._callbackFunctionsOutstanding === 0)
        var t1 = !(!this._enabled || this._result != null);
      else
        t1 = false;
      if (t1)
        this._unittest$_complete$1("pass");
    }, "call$0", "get$_markCallbackComplete", 0, 0, 12],
    toString$0: function(_) {
      var t1, t2;
      t1 = this._result;
      t2 = this.description;
      return t1 != null ? t2 + ": " + H.S(t1) : t2;
    }
  },
  TestCase__errorHandler_closure: {
    "^": "Closure:56;this_0,stage_1",
    call$2: [function(e, stack) {
      var t1, t2;
      if (stack == null && !!J.getInterceptor(e).$isError)
        stack = e.get$stackTrace();
      t1 = this.this_0;
      t2 = t1._result;
      if (t2 == null || t2 === "pass")
        if (!!J.getInterceptor(e).$isTestFailure)
          t1._fail$2(H.S(e), stack);
        else
          t1._unittest$_complete$3("error", this.stage_1 + " failed: Caught " + H.S(e), stack);
    }, "call$2", null, 4, 0, null, 2, 161, "call"],
    $isFunction: true
  },
  TestCase__run_closure: {
    "^": "Closure:58;this_0",
    call$1: [function(_) {
    }, "call$1", null, 2, 0, null, 60, "call"],
    $isFunction: true
  },
  TestCase__run_closure0: {
    "^": "Closure:58;this_1",
    call$1: [function(_) {
      var t1, t2, testReturn;
      t1 = this.this_1;
      if (t1._result != null)
        return P._Future$immediate(null, null);
      C.JSArray_methods.set$length($._config._testLogBuffer, 0);
      t2 = new P.DateTime(Date.now(), false);
      t2.DateTime$_now$0();
      t1._startTime = t2;
      t1._runningTime = null;
      ++t1._callbackFunctionsOutstanding;
      testReturn = t1._testFunction$0();
      if (!!J.getInterceptor(testReturn).$isFuture) {
        ++t1._callbackFunctionsOutstanding;
        testReturn.catchError$1(t1._errorHandler$1("Test")).whenComplete$1(t1.get$_markCallbackComplete());
      }
    }, "call$1", null, 2, 0, null, 60, "call"],
    $isFunction: true
  },
  TestCase__run_closure1: {
    "^": "Closure:58;this_2",
    call$1: [function(_) {
      var t1, t2;
      t1 = this.this_2;
      t1._markCallbackComplete$0();
      if (t1._result == null) {
        t2 = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(null)), [null]);
        t1._testComplete = t2;
        return t2.future.whenComplete$1(new N.TestCase__run__closure(t1)).catchError$1(t1._errorHandler$1("Teardown"));
      }
    }, "call$1", null, 2, 0, null, 60, "call"],
    $isFunction: true
  },
  TestCase__run__closure: {
    "^": "Closure:55;this_3",
    call$0: [function() {
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  TestCase__run_closure2: {
    "^": "Closure:55;this_4",
    call$0: [function() {
      var t1 = this.this_4;
      t1._setUp = null;
      t1._tearDown = null;
      t1._testFunction = null;
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _runTest_closure: {
    "^": "Closure:56;testCase_1",
    call$2: [function(error, stack) {
      N._registerException(this.testCase_1, error, stack);
    }, "call$2", null, 4, 0, null, 17, 161, "call"],
    $isFunction: true
  },
  _runTest_closure0: {
    "^": "Closure:55;testCase_2,timeout_3",
    call$0: [function() {
      this.testCase_2._unittest$_error$1("Test timed out after " + H.S(C.JSNumber_methods._tdivFast$1(this.timeout_3._duration, 1000000)) + " seconds.");
      var t1 = $._currentTestCaseIndex;
      if (typeof t1 !== "number")
        return t1.$add();
      $._currentTestCaseIndex = t1 + 1;
      N._runTest();
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _runTest_closure1: {
    "^": "Closure:55;box_0",
    call$0: [function() {
      var t1, t2;
      t1 = this.box_0.timer_0;
      if (t1 != null)
        t1.cancel$0();
      t1 = Date.now();
      new P.DateTime(t1, false).DateTime$_now$0();
      t2 = $.get$_lastBreath();
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (t1 - t2 >= 200) {
        $._lastBreath = t1;
        P.Timer_Timer(C.Duration_0, N._nextTestCase$closure());
      } else
        P.scheduleMicrotask(N._nextTestCase$closure());
    }, "call$0", null, 0, 0, null, "call"],
    $isFunction: true
  },
  _ensureInitialized_closure: {
    "^": "Closure:67;",
    call$2: function(f, id) {
      var t1, t2;
      t1 = $._currentTestCaseIndex;
      if (typeof t1 !== "number")
        return t1.$ge();
      if (t1 >= 0 && t1 < $.get$testCases()._collection$_source.length) {
        t2 = $.get$testCases()._collection$_source;
        if (t1 < 0 || t1 >= t2.length)
          return H.ioore(t2, t1);
        t1 = t2[t1];
      } else
        t1 = null;
      t1 = new N._SpreadArgsHelper(f, 1, 1, null, N._SpreadArgsHelper__makeCallbackId(id, f), 0, t1, null);
      t1._SpreadArgsHelper$5$isDone(f, 1, 0, id, null);
      return t1.get$func();
    },
    call$1: function(f) {
      return this.call$2(f, null);
    },
    $isFunction: true
  }
}],
["unittest.configuration", "package:unittest/src/configuration.dart", , K, {
  "^": "",
  Configuration: {
    "^": "Object;"
  }
}],
["unittest.utils", "package:unittest/src/utils.dart", , V, {
  "^": "",
  getTrace: function(stack, formatStacks, filterStacks) {
    var trace, t1;
    if (stack == null || !formatStacks)
      return;
    if (typeof stack === "string")
      trace = R.Trace_Trace$parse(stack);
    else {
      t1 = J.getInterceptor(stack);
      if (!!t1.$isStackTrace)
        trace = R.Trace_Trace$from(stack);
      else
        throw H.wrapException(P.Exception_Exception("Invalid stack type " + H.S(t1.get$runtimeType(stack)) + " for " + H.S(stack) + "."));
    }
    if (!filterStacks)
      return trace;
    t1 = trace.get$frames();
    return new R.Trace(H.setRuntimeTypeInfo(new P.UnmodifiableListView(t1.takeWhile$1(t1, new V.getTrace_closure()).toList$0(0)), [S.Frame])).get$terse().foldFrames$1(new V.getTrace_closure0());
  },
  Pair: {
    "^": "Object;"
  },
  getTrace_closure: {
    "^": "Closure:58;",
    call$1: function(frame) {
      return !J.$eq(frame.get$$package(), "unittest") || !J.$eq(frame.get$member(), "TestCase._runTest");
    },
    $isFunction: true
  },
  getTrace_closure0: {
    "^": "Closure:58;",
    call$1: function(frame) {
      return J.$eq(frame.get$$package(), "unittest") || frame.get$isCore();
    },
    $isFunction: true
  }
}],
]);
Isolate.$finishClasses($$, $, null);
$$ = null;

// Runtime type support
;(function() {
  var TRUE = !0, _;
  _ = P.$int;
  _.$is$int = TRUE;
  _.$isnum = TRUE;
  _.$isComparable = TRUE;
  _.$asComparable = [P.num];
  _.$isObject = TRUE;
  _ = P.String;
  _.$isString = TRUE;
  _.$isComparable = TRUE;
  _.$asComparable = [P.String];
  _.$isObject = TRUE;
  _ = P.num;
  _.$isnum = TRUE;
  _.$isComparable = TRUE;
  _.$asComparable = [P.num];
  _.$isObject = TRUE;
  _ = P.HttpRequest;
  _.$isHttpRequest = TRUE;
  _.$isStream = TRUE;
  _.$asStream = [[P.List, P.$int]];
  _.$isObject = TRUE;
  _ = P.Duration;
  _.$isDuration = TRUE;
  _.$isComparable = TRUE;
  _.$asComparable = [P.Duration];
  _.$isObject = TRUE;
  P._HttpConnection.$isObject = TRUE;
  _ = P._HttpIncoming;
  _.$isStream = TRUE;
  _.$asStream = [[P.List, P.$int]];
  _.$isObject = TRUE;
  _ = P.List;
  _.$isList = TRUE;
  _.$isObject = TRUE;
  P.Object.$isObject = TRUE;
  _ = P.HttpResponse;
  _.$isEventSink = TRUE;
  _.$asEventSink = [[P.List, P.$int]];
  _.$isObject = TRUE;
  _ = P.RawSocketEvent;
  _.$isRawSocketEvent = TRUE;
  _.$isObject = TRUE;
  _ = P.HttpClientResponse;
  _.$isHttpClientResponse = TRUE;
  _.$isStream = TRUE;
  _.$asStream = [[P.List, P.$int]];
  _.$isObject = TRUE;
  P.Match.$isObject = TRUE;
  _ = P._HttpServer;
  _.$isHttpServer = TRUE;
  _.$isStream = TRUE;
  _.$asStream = [P.HttpRequest];
  _.$isStream = TRUE;
  _.$asStream = [P.HttpRequest];
  _.$isObject = TRUE;
  _ = P.bool;
  _.$isbool = TRUE;
  _.$isObject = TRUE;
  P.Cookie.$isObject = TRUE;
  P.Encoding.$isObject = TRUE;
  P._ConnectionTarget.$isObject = TRUE;
  _ = P._RawSecureSocket;
  _.$isStream = TRUE;
  _.$asStream = [P.RawSocketEvent];
  _.$isRawSecureSocket = TRUE;
  _.$isRawSocket = TRUE;
  _.$isStream = TRUE;
  _.$asStream = [P.RawSocketEvent];
  _.$isObject = TRUE;
  P._Proxy.$isObject = TRUE;
  N.TestCase.$isObject = TRUE;
  V.Pair.$isObject = TRUE;
  _ = P.StackTrace;
  _.$isStackTrace = TRUE;
  _.$isObject = TRUE;
  S.Frame.$isObject = TRUE;
  H.RawReceivePortImpl.$isObject = TRUE;
  H._IsolateEvent.$isObject = TRUE;
  H._IsolateContext.$isObject = TRUE;
  _ = K.RequestResultSv;
  _.$isRequestResultSv = TRUE;
  _.$isObject = TRUE;
  _ = K.StartResult;
  _.$isStartResult = TRUE;
  _.$isObject = TRUE;
  _ = P.HttpServer;
  _.$isHttpServer = TRUE;
  _.$isStream = TRUE;
  _.$asStream = [P.HttpRequest];
  _.$isObject = TRUE;
  _ = P.Socket;
  _.$isSocket = TRUE;
  _.$isStream = TRUE;
  _.$asStream = [[P.List, P.$int]];
  _.$isEventSink = TRUE;
  _.$asEventSink = [[P.List, P.$int]];
  _.$isObject = TRUE;
  _ = P.Symbol0;
  _.$isSymbol0 = TRUE;
  _.$isObject = TRUE;
  _ = P.Future;
  _.$isFuture = TRUE;
  _.$isObject = TRUE;
  _ = P.HttpClientRequest;
  _.$isHttpClientRequest = TRUE;
  _.$isEventSink = TRUE;
  _.$asEventSink = [[P.List, P.$int]];
  _.$isObject = TRUE;
  _ = P._ConnectionInfo;
  _.$is_ConnectionInfo = TRUE;
  _.$isObject = TRUE;
  _ = P.X509Certificate;
  _.$isX509Certificate = TRUE;
  _.$isObject = TRUE;
  _ = P._Credentials;
  _.$is_Credentials = TRUE;
  _.$isObject = TRUE;
  _ = P._AuthenticationScheme;
  _.$is_AuthenticationScheme = TRUE;
  _.$isObject = TRUE;
  _ = P._HttpClientRequest;
  _.$is_HttpClientRequest = TRUE;
  _.$isHttpClientRequest = TRUE;
  _.$isEventSink = TRUE;
  _.$asEventSink = [[P.List, P.$int]];
  _.$isEventSink = TRUE;
  _.$asEventSink = [[P.List, P.$int]];
  _.$isEventSink = TRUE;
  _.$asEventSink = [[P.List, P.$int]];
  _.$isObject = TRUE;
  _ = P.EventSink;
  _.$isEventSink = TRUE;
  _.$isObject = TRUE;
  _ = P.Zone;
  _.$isZone = TRUE;
  _.$isObject = TRUE;
  _ = P.ZoneDelegate;
  _.$isZoneDelegate = TRUE;
  _.$isObject = TRUE;
  _ = P.Function;
  _.$isFunction = TRUE;
  _.$isObject = TRUE;
  _ = P.Uri;
  _.$isUri = TRUE;
  _.$isObject = TRUE;
  _ = P.Map;
  _.$isMap = TRUE;
  _.$isObject = TRUE;
  _ = Q.Matcher;
  _.$isMatcher = TRUE;
  _.$isObject = TRUE;
  _ = P.ZoneSpecification;
  _.$isZoneSpecification = TRUE;
  _.$isObject = TRUE;
  _ = P.Timer;
  _.$isTimer = TRUE;
  _.$isObject = TRUE;
  _ = P.Comparable;
  _.$isComparable = TRUE;
  _.$isObject = TRUE;
  _ = P._EventSink;
  _.$is_EventSink = TRUE;
  _.$isObject = TRUE;
  _ = P._DelayedEvent;
  _.$is_DelayedEvent = TRUE;
  _.$isObject = TRUE;
  _ = P.DateTime;
  _.$isDateTime = TRUE;
  _.$isComparable = TRUE;
  _.$asComparable = [null];
  _.$isObject = TRUE;
  _ = P.StreamSubscription;
  _.$isStreamSubscription = TRUE;
  _.$isObject = TRUE;
  _ = P.Stream;
  _.$isStream = TRUE;
  _.$isObject = TRUE;
  _ = Q.Description;
  _.$isDescription = TRUE;
  _.$isObject = TRUE;
  _ = P.RawSecureSocket;
  _.$isRawSecureSocket = TRUE;
  _.$isRawSocket = TRUE;
  _.$isStream = TRUE;
  _.$asStream = [P.RawSocketEvent];
  _.$isObject = TRUE;
  _ = P.RawSocket;
  _.$isRawSocket = TRUE;
  _.$isStream = TRUE;
  _.$asStream = [P.RawSocketEvent];
  _.$isObject = TRUE;
})();
;
// getInterceptor methods
J.getInterceptor = function(receiver) {
  if (typeof receiver == "number") {
    if (Math.floor(receiver) == receiver)
      return J.JSInt.prototype;
    return J.JSDouble.prototype;
  }
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return J.JSNull.prototype;
  if (typeof receiver == "boolean")
    return J.JSBool.prototype;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  if (typeof receiver != "object")
    return receiver;
  if (receiver instanceof P.Object)
    return receiver;
  return J.getNativeInterceptor(receiver);
};
J.getInterceptor$asx = function(receiver) {
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  if (typeof receiver != "object")
    return receiver;
  if (receiver instanceof P.Object)
    return receiver;
  return J.getNativeInterceptor(receiver);
};
J.getInterceptor$ax = function(receiver) {
  if (receiver == null)
    return receiver;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  if (typeof receiver != "object")
    return receiver;
  if (receiver instanceof P.Object)
    return receiver;
  return J.getNativeInterceptor(receiver);
};
J.getInterceptor$n = function(receiver) {
  if (typeof receiver == "number")
    return J.JSNumber.prototype;
  if (receiver == null)
    return receiver;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$ns = function(receiver) {
  if (typeof receiver == "number")
    return J.JSNumber.prototype;
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$s = function(receiver) {
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$x = function(receiver) {
  if (receiver == null)
    return receiver;
  if (typeof receiver != "object")
    return receiver;
  if (receiver instanceof P.Object)
    return receiver;
  return J.getNativeInterceptor(receiver);
};
J.$add$ns = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver + a0;
  return J.getInterceptor$ns(receiver).$add(receiver, a0);
};
J.$and$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return (receiver & a0) >>> 0;
  return J.getInterceptor$n(receiver).$and(receiver, a0);
};
J.$eq = function(receiver, a0) {
  if (receiver == null)
    return a0 == null;
  if (typeof receiver != "object")
    return a0 != null && receiver === a0;
  return J.getInterceptor(receiver).$eq(receiver, a0);
};
J.$ge$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver >= a0;
  return J.getInterceptor$n(receiver).$ge(receiver, a0);
};
J.$gt$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver > a0;
  return J.getInterceptor$n(receiver).$gt(receiver, a0);
};
J.$index$asx = function(receiver, a0) {
  if (receiver.constructor == Array || typeof receiver == "string" || H.isJsIndexable(receiver, receiver[init.dispatchPropertyName]))
    if (a0 >>> 0 === a0 && a0 < receiver.length)
      return receiver[a0];
  return J.getInterceptor$asx(receiver).$index(receiver, a0);
};
J.$indexSet$ax = function(receiver, a0, a1) {
  if ((receiver.constructor == Array || H.isJsIndexable(receiver, receiver[init.dispatchPropertyName])) && !receiver.immutable$list && a0 >>> 0 === a0 && a0 < receiver.length)
    return receiver[a0] = a1;
  return J.getInterceptor$ax(receiver).$indexSet(receiver, a0, a1);
};
J.$lt$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver < a0;
  return J.getInterceptor$n(receiver).$lt(receiver, a0);
};
J.$mul$ns = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver * a0;
  return J.getInterceptor$ns(receiver).$mul(receiver, a0);
};
J.$shl$n = function(receiver, a0) {
  return J.getInterceptor$n(receiver).$shl(receiver, a0);
};
J.$sub$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver - a0;
  return J.getInterceptor$n(receiver).$sub(receiver, a0);
};
J.$xor$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return (receiver ^ a0) >>> 0;
  return J.getInterceptor$n(receiver).$xor(receiver, a0);
};
J.add$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).add$1(receiver, a0);
};
J.asUint8List$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).asUint8List$2(receiver, a0, a1);
};
J.codeUnitAt$1$s = function(receiver, a0) {
  return J.getInterceptor$s(receiver).codeUnitAt$1(receiver, a0);
};
J.compareTo$1$ns = function(receiver, a0) {
  return J.getInterceptor$ns(receiver).compareTo$1(receiver, a0);
};
J.contains$1$asx = function(receiver, a0) {
  return J.getInterceptor$asx(receiver).contains$1(receiver, a0);
};
J.elementAt$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).elementAt$1(receiver, a0);
};
J.endsWith$1$s = function(receiver, a0) {
  return J.getInterceptor$s(receiver).endsWith$1(receiver, a0);
};
J.expand$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).expand$1(receiver, a0);
};
J.forEach$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).forEach$1(receiver, a0);
};
J.get$add$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).get$add(receiver);
};
J.get$buffer$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$buffer(receiver);
};
J.get$codeUnits$s = function(receiver) {
  return J.getInterceptor$s(receiver).get$codeUnits(receiver);
};
J.get$first$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).get$first(receiver);
};
J.get$hashCode$ = function(receiver) {
  return J.getInterceptor(receiver).get$hashCode(receiver);
};
J.get$isEmpty$asx = function(receiver) {
  return J.getInterceptor$asx(receiver).get$isEmpty(receiver);
};
J.get$isNotEmpty$asx = function(receiver) {
  return J.getInterceptor$asx(receiver).get$isNotEmpty(receiver);
};
J.get$iterator$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).get$iterator(receiver);
};
J.get$last$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).get$last(receiver);
};
J.get$length$asx = function(receiver) {
  return J.getInterceptor$asx(receiver).get$length(receiver);
};
J.get$offsetInBytes$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$offsetInBytes(receiver);
};
J.indexOf$1$asx = function(receiver, a0) {
  return J.getInterceptor$asx(receiver).indexOf$1(receiver, a0);
};
J.matchAsPrefix$2$s = function(receiver, a0, a1) {
  return J.getInterceptor$s(receiver).matchAsPrefix$2(receiver, a0, a1);
};
J.remove$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).remove$1(receiver, a0);
};
J.replaceAll$2$s = function(receiver, a0, a1) {
  return J.getInterceptor$s(receiver).replaceAll$2(receiver, a0, a1);
};
J.replaceFirst$2$s = function(receiver, a0, a1) {
  return J.getInterceptor$s(receiver).replaceFirst$2(receiver, a0, a1);
};
J.setRange$3$ax = function(receiver, a0, a1, a2) {
  return J.getInterceptor$ax(receiver).setRange$3(receiver, a0, a1, a2);
};
J.skip$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).skip$1(receiver, a0);
};
J.split$1$s = function(receiver, a0) {
  return J.getInterceptor$s(receiver).split$1(receiver, a0);
};
J.startsWith$1$s = function(receiver, a0) {
  return J.getInterceptor$s(receiver).startsWith$1(receiver, a0);
};
J.sublist$2$ax = function(receiver, a0, a1) {
  return J.getInterceptor$ax(receiver).sublist$2(receiver, a0, a1);
};
J.substring$1$s = function(receiver, a0) {
  return J.getInterceptor$s(receiver).substring$1(receiver, a0);
};
J.substring$2$s = function(receiver, a0, a1) {
  return J.getInterceptor$s(receiver).substring$2(receiver, a0, a1);
};
J.toList$0$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).toList$0(receiver);
};
J.toLowerCase$0$s = function(receiver) {
  return J.getInterceptor$s(receiver).toLowerCase$0(receiver);
};
J.toRadixString$1$n = function(receiver, a0) {
  return J.getInterceptor$n(receiver).toRadixString$1(receiver, a0);
};
J.toString$0 = function(receiver) {
  return J.getInterceptor(receiver).toString$0(receiver);
};
J.trim$0$s = function(receiver) {
  return J.getInterceptor$s(receiver).trim$0(receiver);
};
C.JSArray_methods = J.JSArray.prototype;
C.JSDouble_methods = J.JSDouble.prototype;
C.JSInt_methods = J.JSInt.prototype;
C.JSNull_methods = J.JSNull.prototype;
C.JSNumber_methods = J.JSNumber.prototype;
C.JSString_methods = J.JSString.prototype;
C.NativeUint8List_methods = H.NativeUint8List.prototype;
C.PlainJavaScriptObject_methods = J.PlainJavaScriptObject.prototype;
C.UnknownJavaScriptObject_methods = J.UnknownJavaScriptObject.prototype;
C.AsciiCodec_false = new P.AsciiCodec(false);
C.AsciiEncoder_127 = new P.AsciiEncoder(127);
C.C_DynamicRuntimeType = new H.DynamicRuntimeType();
C.C_EmptyIterator = new H.EmptyIterator();
C.C_OutOfMemoryError = new P.OutOfMemoryError();
C.C__ArgPlaceHolder = new N._ArgPlaceHolder();
C.C__DelayedDone = new P._DelayedDone();
C.C__JSRandom = new P._JSRandom();
C.C__RootZone = new P._RootZone();
C.Duration_0 = new P.Duration(0);
C.Duration_100000 = new P.Duration(100000);
C.Duration_120000000 = new P.Duration(120000000);
C.Duration_15000000 = new P.Duration(15000000);
C.GZipCodec_yXb = new P.GZipCodec(true, 6, 8, 0, 15, null, false);
C.JS_CONST_0 = function(hooks) {
  if (typeof dartExperimentalFixupGetTag != "function") return hooks;
  hooks.getTag = dartExperimentalFixupGetTag(hooks.getTag);
};
C.JS_CONST_4hp = function(hooks) {
  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";
  if (userAgent.indexOf("Firefox") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "GeoGeolocation": "Geolocation",
    "Location": "!Location",
    "WorkerMessageEvent": "MessageEvent",
    "XMLDocument": "!Document"};
  function getTagFirefox(o) {
    var tag = getTag(o);
    return quickMap[tag] || tag;
  }
  hooks.getTag = getTagFirefox;
};
C.JS_CONST_8ZY = function getTagFallback(o) {
  var constructor = o.constructor;
  if (typeof constructor == "function") {
    var name = constructor.name;
    if (typeof name == "string" &&
        name.length > 2 &&
        name !== "Object" &&
        name !== "Function.prototype") {
      return name;
    }
  }
  var s = Object.prototype.toString.call(o);
  return s.substring(8, s.length - 1);
};
C.JS_CONST_Fs4 = function(hooks) { return hooks; }
;
C.JS_CONST_QJm = function(getTagFallback) {
  return function(hooks) {
    if (typeof navigator != "object") return hooks;
    var ua = navigator.userAgent;
    if (ua.indexOf("DumpRenderTree") >= 0) return hooks;
    if (ua.indexOf("Chrome") >= 0) {
      function confirm(p) {
        return typeof window == "object" && window[p] && window[p].name == p;
      }
      if (confirm("Window") && confirm("HTMLElement")) return hooks;
    }
    hooks.getTag = getTagFallback;
  };
};
C.JS_CONST_gkc = function(hooks) {
  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";
  if (userAgent.indexOf("Trident/") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "HTMLDDElement": "HTMLElement",
    "HTMLDTElement": "HTMLElement",
    "HTMLPhraseElement": "HTMLElement",
    "Position": "Geoposition"
  };
  function getTagIE(o) {
    var tag = getTag(o);
    var newTag = quickMap[tag];
    if (newTag) return newTag;
    if (tag == "Object") {
      if (window.DataView && (o instanceof window.DataView)) return "DataView";
    }
    return tag;
  }
  function prototypeForTagIE(tag) {
    var constructor = window[tag];
    if (constructor == null) return null;
    return constructor.prototype;
  }
  hooks.getTag = getTagIE;
  hooks.prototypeForTag = prototypeForTagIE;
};
C.JS_CONST_oRe = function() {
  function typeNameInChrome(o) {
    var name = o.constructor.name;
    if (name) return name;
    var s = Object.prototype.toString.call(o);
    return s.substring(8, s.length - 1);
  }
  function getUnknownTag(object, tag) {
    if (/^HTML[A-Z].*Element$/.test(tag)) {
      var name = Object.prototype.toString.call(object);
      if (name == "[object Object]") return null;
      return "HTMLElement";
    }
  }
  function getUnknownTagGenericBrowser(object, tag) {
    if (self.HTMLElement && object instanceof HTMLElement) return "HTMLElement";
    return getUnknownTag(object, tag);
  }
  function prototypeForTag(tag) {
    if (typeof window == "undefined") return null;
    if (typeof window[tag] == "undefined") return null;
    var constructor = window[tag];
    if (typeof constructor != "function") return null;
    return constructor.prototype;
  }
  function discriminator(tag) { return null; }
  var isBrowser = typeof navigator == "object";
  return {
    getTag: typeNameInChrome,
    getUnknownTag: isBrowser ? getUnknownTagGenericBrowser : getUnknownTag,
    prototypeForTag: prototypeForTag,
    discriminator: discriminator };
};
C.JS_CONST_rr7 = function(hooks) {
  var getTag = hooks.getTag;
  var prototypeForTag = hooks.prototypeForTag;
  function getTagFixed(o) {
    var tag = getTag(o);
    if (tag == "Document") {
      if (!!o.xmlVersion) return "!Document";
      return "!HTMLDocument";
    }
    return tag;
  }
  function prototypeForTagFixed(tag) {
    if (tag == "Document") return null;
    return prototypeForTag(tag);
  }
  hooks.getTag = getTagFixed;
  hooks.prototypeForTag = prototypeForTagFixed;
};
C.JsonCodec_null_null = new P.JsonCodec(null, null);
C.JsonEncoder_null_null = new P.JsonEncoder(null, null);
C.Latin1Codec_false = new P.Latin1Codec(false);
C.Latin1Encoder_255 = new P.Latin1Encoder(255);
Isolate.makeConstantList = function(list) {
  list.immutable$list = init;
  list.fixed$length = init;
  return list;
};
;
C.List_127_2047_65535_1114111 = H.setRuntimeTypeInfo(Isolate.makeConstantList([127, 2047, 65535, 1114111]), [P.$int]);
C.List_2Vk = Isolate.makeConstantList([72, 84, 84, 80, 47, 49, 46, 49]);
C.List_2Vk0 = Isolate.makeConstantList([0, 0, 32776, 33792, 1, 10240, 0, 0]);
C.List_2Vk1 = Isolate.makeConstantList([72, 84, 84, 80, 47, 49, 46, 48]);
C.List_72_84_84_80 = Isolate.makeConstantList([72, 84, 84, 80]);
C.List_A8J = Isolate.makeConstantList(["(", ")", "<", ">", "@", ",", ";", ":", "\\", "\"", "/", "[", "]", "?", "=", "{", "}"]);
C.List_CVk = Isolate.makeConstantList([0, 0, 65490, 45055, 65535, 34815, 65534, 18431]);
C.List_E7y = Isolate.makeConstantList([72, 84, 84, 80, 47, 49, 46]);
C.List_E7y0 = Isolate.makeConstantList([13, 10, 48, 13, 10, 13, 10]);
C.List_ECn = Isolate.makeConstantList(["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]);
C.List_JYB = Isolate.makeConstantList([0, 0, 26624, 1023, 65534, 2047, 65534, 2047]);
C.List_NUU = Isolate.makeConstantList([false, false, false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, true, false, false, false, false, false, true, true, false, false, true, false, false, true, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false]);
C.List_WnV = Isolate.makeConstantList(["/", "\\"]);
C.List_cGl = Isolate.makeConstantList([48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70]);
C.List_cSk = Isolate.makeConstantList(["/"]);
C.List_empty = Isolate.makeConstantList([]);
C.List_empty0 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [P.String]);
C.List_gRj = Isolate.makeConstantList([0, 0, 32722, 12287, 65534, 34815, 65534, 18431]);
C.List_h8w = Isolate.makeConstantList(["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]);
C.List_nxB = Isolate.makeConstantList([0, 0, 24576, 1023, 65534, 34815, 65534, 18431]);
C.List_qNA = Isolate.makeConstantList([0, 0, 32754, 11263, 65534, 34815, 65534, 18431]);
C.List_qg4 = Isolate.makeConstantList([0, 0, 65490, 12287, 65535, 34815, 65534, 18431]);
C.List_qg40 = Isolate.makeConstantList([0, 0, 32722, 12287, 65535, 34815, 65534, 18431]);
C.List_yTu = Isolate.makeConstantList([48, 13, 10, 13, 10]);
C.List_yTu0 = H.setRuntimeTypeInfo(Isolate.makeConstantList([1, 2, 3, 4, 0]), [P.$int]);
C.RawSocketEvent_0 = new P.RawSocketEvent(0);
C.RawSocketEvent_1 = new P.RawSocketEvent(1);
C.RawSocketEvent_2 = new P.RawSocketEvent(2);
C.SocketDirection_0 = new P.SocketDirection(0);
C.SocketDirection_1 = new P.SocketDirection(1);
C.SocketDirection_2 = new P.SocketDirection(2);
C.SocketOption_0 = new P.SocketOption(0);
C.Symbol_call = new H.Symbol("call");
C.Type_6L0 = H.createRuntimeType('Uint8List');
C.Type_Ejg = H.createRuntimeType('String');
C.Type_EsU = H.createRuntimeType('bool');
C.Type_SnA = H.createRuntimeType('$int');
C.Type_XXD = H.createRuntimeType('JSObject');
C.Type_eZO = H.createRuntimeType('Null');
C.Type_qq1 = H.createRuntimeType('$double');
C.Type_wAg = H.createRuntimeType('ByteBuffer');
C.Type_xM7 = H.createRuntimeType('num');
C.Utf8Codec_false = new P.Utf8Codec(false);
C._AuthenticationScheme_0 = new P._AuthenticationScheme(0);
C._AuthenticationScheme_1 = new P._AuthenticationScheme(1);
C._AuthenticationScheme_m1 = new P._AuthenticationScheme(-1);
C._Proxy_cg9 = new P._Proxy(null, null, null, null, true);
C.List_jqP = Isolate.makeConstantList([C._Proxy_cg9]);
C._ProxyConfiguration_8Zd = new P._ProxyConfiguration(C.List_jqP);
C._ZoneFunction_3bB = new P._ZoneFunction(C.C__RootZone, P._rootCreatePeriodicTimer$closure());
C._ZoneFunction_7G2 = new P._ZoneFunction(C.C__RootZone, P._rootRegisterBinaryCallback$closure());
C._ZoneFunction_Eeh = new P._ZoneFunction(C.C__RootZone, P._rootRegisterUnaryCallback$closure());
C._ZoneFunction_NMc = new P._ZoneFunction(C.C__RootZone, P._rootHandleUncaughtError$closure());
C._ZoneFunction__RootZone__rootCreateTimer = new P._ZoneFunction(C.C__RootZone, P._rootCreateTimer$closure());
C._ZoneFunction__RootZone__rootFork = new P._ZoneFunction(C.C__RootZone, P._rootFork$closure());
C._ZoneFunction__RootZone__rootPrint = new P._ZoneFunction(C.C__RootZone, P._rootPrint$closure());
C._ZoneFunction__RootZone__rootRegisterCallback = new P._ZoneFunction(C.C__RootZone, P._rootRegisterCallback$closure());
C._ZoneFunction__RootZone__rootRun = new P._ZoneFunction(C.C__RootZone, P._rootRun$closure());
C._ZoneFunction__RootZone__rootRunBinary = new P._ZoneFunction(C.C__RootZone, P._rootRunBinary$closure());
C._ZoneFunction__RootZone__rootRunUnary = new P._ZoneFunction(C.C__RootZone, P._rootRunUnary$closure());
C._ZoneFunction__RootZone__rootScheduleMicrotask = new P._ZoneFunction(C.C__RootZone, P._rootScheduleMicrotask$closure());
C._ZoneSpecification_woc = new P._ZoneSpecification(null, null, null, null, null, null, null, null, null, null, null, null);
$.libraries_to_load = {};
$.IsolateNatives_enableSpawnWorker = null;
$.RawReceivePortImpl__nextFreeId = 1;
$.Primitives_mirrorFunctionCacheName = "$cachedFunction";
$.Primitives_mirrorInvokeCacheName = "$cachedInvocation";
$.Closure_functionCounter = 0;
$.BoundClosure_selfFieldNameCache = null;
$.BoundClosure_receiverFieldNameCache = null;
$.RuntimeFunctionType_inAssert = false;
$.getTagFunction = null;
$.alternateTagFunction = null;
$.prototypeForTagFunction = null;
$.dispatchRecordsForInstanceTags = null;
$.interceptorsForUncacheableTags = null;
$.initNativeDispatchFlag = null;
$.printToZone = null;
$._nextCallback = null;
$._lastCallback = null;
$._lastPriorityCallback = null;
$._isInCallbackLoop = false;
$.Zone__current = C.C__RootZone;
$._RootZone__rootDelegate = null;
$.Expando__keyCount = 0;
$._Platform__environmentCache = null;
$._nextServiceId = 1;
$._assertFailureHandler = null;
$._assertErrorFormatter = null;
$._config = null;
$.groupSep = " ";
$._soloNestingLevel = 0;
$._soloTestSeen = false;
$._currentTestCaseIndex = -1;
$._initialized = false;
$._uncaughtErrorMessage = null;
$.formatStacks = true;
$.filterStacks = true;
Isolate.$lazy($, "thisScript", "IsolateNatives_thisScript", "get$IsolateNatives_thisScript", function() {
  return H.IsolateNatives_computeThisScript();
});
Isolate.$lazy($, "workerIds", "IsolateNatives_workerIds", "get$IsolateNatives_workerIds", function() {
  return H.setRuntimeTypeInfo(new P.Expando(null), [P.$int]);
});
Isolate.$lazy($, "noSuchMethodPattern", "TypeErrorDecoder_noSuchMethodPattern", "get$TypeErrorDecoder_noSuchMethodPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({toString: function() {
      return "$receiver$";
    }}));
});
Isolate.$lazy($, "notClosurePattern", "TypeErrorDecoder_notClosurePattern", "get$TypeErrorDecoder_notClosurePattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({$method$: null, toString: function() {
      return "$receiver$";
    }}));
});
Isolate.$lazy($, "nullCallPattern", "TypeErrorDecoder_nullCallPattern", "get$TypeErrorDecoder_nullCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(null));
});
Isolate.$lazy($, "nullLiteralCallPattern", "TypeErrorDecoder_nullLiteralCallPattern", "get$TypeErrorDecoder_nullLiteralCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    var $argumentsExpr$ = '$arguments$';
    try {
      null.$method$($argumentsExpr$);
    } catch (e) {
      return e.message;
    }

  }());
});
Isolate.$lazy($, "undefinedCallPattern", "TypeErrorDecoder_undefinedCallPattern", "get$TypeErrorDecoder_undefinedCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(void 0));
});
Isolate.$lazy($, "undefinedLiteralCallPattern", "TypeErrorDecoder_undefinedLiteralCallPattern", "get$TypeErrorDecoder_undefinedLiteralCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    var $argumentsExpr$ = '$arguments$';
    try {
      (void 0).$method$($argumentsExpr$);
    } catch (e) {
      return e.message;
    }

  }());
});
Isolate.$lazy($, "nullPropertyPattern", "TypeErrorDecoder_nullPropertyPattern", "get$TypeErrorDecoder_nullPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(null));
});
Isolate.$lazy($, "nullLiteralPropertyPattern", "TypeErrorDecoder_nullLiteralPropertyPattern", "get$TypeErrorDecoder_nullLiteralPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    try {
      null.$method$;
    } catch (e) {
      return e.message;
    }

  }());
});
Isolate.$lazy($, "undefinedPropertyPattern", "TypeErrorDecoder_undefinedPropertyPattern", "get$TypeErrorDecoder_undefinedPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(void 0));
});
Isolate.$lazy($, "undefinedLiteralPropertyPattern", "TypeErrorDecoder_undefinedLiteralPropertyPattern", "get$TypeErrorDecoder_undefinedLiteralPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    try {
      (void 0).$method$;
    } catch (e) {
      return e.message;
    }

  }());
});
Isolate.$lazy($, "scheduleImmediateClosure", "_AsyncRun_scheduleImmediateClosure", "get$_AsyncRun_scheduleImmediateClosure", function() {
  return P._AsyncRun__initializeScheduleImmediate();
});
Isolate.$lazy($, "_nullFuture", "Future__nullFuture", "get$Future__nullFuture", function() {
  return P._Future$immediate(null, null);
});
Isolate.$lazy($, "_rootMap", "_RootZone__rootMap", "get$_RootZone__rootMap", function() {
  return P.HashMap_HashMap(null, null, null, null, null);
});
Isolate.$lazy($, "_toStringVisiting", "IterableBase__toStringVisiting", "get$IterableBase__toStringVisiting", function() {
  return [];
});
Isolate.$lazy($, "_nameToEncoding", "Encoding__nameToEncoding", "get$Encoding__nameToEncoding", function() {
  return P.LinkedHashMap_LinkedHashMap$_literal(["iso_8859-1:1987", C.Latin1Codec_false, "iso-ir-100", C.Latin1Codec_false, "iso_8859-1", C.Latin1Codec_false, "iso-8859-1", C.Latin1Codec_false, "latin1", C.Latin1Codec_false, "l1", C.Latin1Codec_false, "ibm819", C.Latin1Codec_false, "cp819", C.Latin1Codec_false, "csisolatin1", C.Latin1Codec_false, "iso-ir-6", C.AsciiCodec_false, "ansi_x3.4-1968", C.AsciiCodec_false, "ansi_x3.4-1986", C.AsciiCodec_false, "iso_646.irv:1991", C.AsciiCodec_false, "iso646-us", C.AsciiCodec_false, "us-ascii", C.AsciiCodec_false, "us", C.AsciiCodec_false, "ibm367", C.AsciiCodec_false, "cp367", C.AsciiCodec_false, "csascii", C.AsciiCodec_false, "ascii", C.AsciiCodec_false, "csutf8", C.Utf8Codec_false, "utf-8", C.Utf8Codec_false], P.String, P.Encoding);
});
Isolate.$lazy($, "TEXT", "ContentType_TEXT", "get$ContentType_TEXT", function() {
  return P._ContentType$("text", "plain", "utf-8", null);
});
Isolate.$lazy($, "_platformEnvironmentCache", "_HttpClient__platformEnvironmentCache", "get$_HttpClient__platformEnvironmentCache", function() {
  return P._Platform_environment();
});
Isolate.$lazy($, "_connections", "_HttpConnection__connections", "get$_HttpConnection__connections", function() {
  return P.HashMap_HashMap(null, null, null, P.$int, P._HttpConnection);
});
Isolate.$lazy($, "_servers", "_HttpServer__servers", "get$_HttpServer__servers", function() {
  return P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, P._HttpServer);
});
Isolate.$lazy($, "_version", "Platform__version", "get$Platform__version", function() {
  return P._Platform_version();
});
Isolate.$lazy($, "_vmFrame", "_vmFrame", "get$_vmFrame", function() {
  return new H.JSSyntaxRegExp("^#\\d+\\s+(\\S.*) \\((.+?):(\\d+)(?::(\\d+))?\\)$", H.JSSyntaxRegExp_makeNative("^#\\d+\\s+(\\S.*) \\((.+?):(\\d+)(?::(\\d+))?\\)$", false, true, false), null, null);
});
Isolate.$lazy($, "_v8Frame", "_v8Frame", "get$_v8Frame", function() {
  return new H.JSSyntaxRegExp("^\\s*at (?:(\\S.*?)(?: \\[as [^\\]]+\\])? \\((.*)\\)|(.*))$", H.JSSyntaxRegExp_makeNative("^\\s*at (?:(\\S.*?)(?: \\[as [^\\]]+\\])? \\((.*)\\)|(.*))$", false, true, false), null, null);
});
Isolate.$lazy($, "_v8UrlLocation", "_v8UrlLocation", "get$_v8UrlLocation", function() {
  return new H.JSSyntaxRegExp("^(.*):(\\d+):(\\d+)$", H.JSSyntaxRegExp_makeNative("^(.*):(\\d+):(\\d+)$", false, true, false), null, null);
});
Isolate.$lazy($, "_v8EvalLocation", "_v8EvalLocation", "get$_v8EvalLocation", function() {
  return new H.JSSyntaxRegExp("^eval at (?:\\S.*?) \\((.*)\\)(?:, .*?:\\d+:\\d+)?$", H.JSSyntaxRegExp_makeNative("^eval at (?:\\S.*?) \\((.*)\\)(?:, .*?:\\d+:\\d+)?$", false, true, false), null, null);
});
Isolate.$lazy($, "_safariFrame", "_safariFrame", "get$_safariFrame", function() {
  return new H.JSSyntaxRegExp("^(?:([0-9A-Za-z_$]*)@)?(.*):(\\d*):(\\d*)$", H.JSSyntaxRegExp_makeNative("^(?:([0-9A-Za-z_$]*)@)?(.*):(\\d*):(\\d*)$", false, true, false), null, null);
});
Isolate.$lazy($, "_firefoxFrame", "_firefoxFrame", "get$_firefoxFrame", function() {
  return new H.JSSyntaxRegExp("^([^@(/]*)(?:\\(.*\\))?((?:/[^/]*)*)(?:\\(.*\\))?@(.*):(\\d+)$", H.JSSyntaxRegExp_makeNative("^([^@(/]*)(?:\\(.*\\))?((?:/[^/]*)*)(?:\\(.*\\))?@(.*):(\\d+)$", false, true, false), null, null);
});
Isolate.$lazy($, "_friendlyFrame", "_friendlyFrame", "get$_friendlyFrame", function() {
  return new H.JSSyntaxRegExp("^(\\S+)(?: (\\d+)(?::(\\d+))?)?\\s+([^\\d]\\S*)$", H.JSSyntaxRegExp_makeNative("^(\\S+)(?: (\\d+)(?::(\\d+))?)?\\s+([^\\d]\\S*)$", false, true, false), null, null);
});
Isolate.$lazy($, "_initialDot", "_initialDot", "get$_initialDot", function() {
  return new H.JSSyntaxRegExp("^\\.", H.JSSyntaxRegExp_makeNative("^\\.", false, true, false), null, null);
});
Isolate.$lazy($, "_uriRegExp", "Frame__uriRegExp", "get$Frame__uriRegExp", function() {
  return new H.JSSyntaxRegExp("^[a-zA-Z][-+.a-zA-Z\\d]*://", H.JSSyntaxRegExp_makeNative("^[a-zA-Z][-+.a-zA-Z\\d]*://", false, true, false), null, null);
});
Isolate.$lazy($, "_windowsRegExp", "Frame__windowsRegExp", "get$Frame__windowsRegExp", function() {
  return new H.JSSyntaxRegExp("^([a-zA-Z]:[\\\\/]|\\\\\\\\)", H.JSSyntaxRegExp_makeNative("^([a-zA-Z]:[\\\\/]|\\\\\\\\)", false, true, false), null, null);
});
Isolate.$lazy($, "_encoder", "Bencode__encoder", "get$Bencode__encoder", function() {
  var t1 = new V.ArrayBuilder(1024, null, 0, H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(null)), [null]), [], H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(null)), [null]), false);
  t1._buffer8 = new Uint8Array(1024);
  return new V.Bencoder(t1);
});
Isolate.$lazy($, "_decoder", "Bencode__decoder", "get$Bencode__decoder", function() {
  return new V.Bdecoder(null);
});
Isolate.$lazy($, "_random", "PeerIdCreator__random", "get$PeerIdCreator__random", function() {
  var t1 = new P.DateTime(Date.now(), false);
  t1.DateTime$_now$0();
  t1 = H.Primitives_getMilliseconds(t1);
  return P._Random$(t1);
});
Isolate.$lazy($, "DECODE_TABLE", "PercentEncode_DECODE_TABLE", "get$PercentEncode_DECODE_TABLE", function() {
  return P.LinkedHashMap_LinkedHashMap$_literal(["0", 0, "1", 1, "2", 2, "3", 3, "4", 4, "5", 5, "6", 6, "7", 7, "8", 8, "9", 9, "a", 10, "A", 10, "b", 11, "B", 11, "c", 12, "C", 12, "d", 13, "D", 13, "e", 14, "E", 14, "f", 15, "F", 15], null, null);
});
Isolate.$lazy($, "ENCODE_TABLE", "PercentEncode_ENCODE_TABLE", "get$PercentEncode_ENCODE_TABLE", function() {
  return P.LinkedHashMap_LinkedHashMap$_literal([0, "0", 1, "1", 2, "2", 3, "3", 4, "4", 5, "5", 6, "6", 7, "7", 8, "8", 9, "9", 10, "A", 11, "B", 12, "C", 13, "D", 14, "E", 15, "F"], null, null);
});
Isolate.$lazy($, "_sencoder", "PercentEncode__sencoder", "get$PercentEncode__sencoder", function() {
  var t1 = new V.ArrayBuilder(1024, null, 0, H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(null)), [null]), [], H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(null)), [null]), false);
  t1._buffer8 = new Uint8Array(1024);
  return new V.PercentEncode(t1);
});
Isolate.$lazy($, "wrapAsync", "wrapAsync", "get$wrapAsync", function() {
  return new Y.closure();
});
Isolate.$lazy($, "windows", "windows", "get$windows", function() {
  return F.Context_Context(null, $.get$Style_windows());
});
Isolate.$lazy($, "context", "context", "get$context", function() {
  return new F.Context($.get$Style_platform(), null);
});
Isolate.$lazy($, "posix", "Style_posix", "get$Style_posix", function() {
  return new Z.PosixStyle("posix", "/", C.List_cSk, new H.JSSyntaxRegExp("/", H.JSSyntaxRegExp_makeNative("/", false, true, false), null, null), new H.JSSyntaxRegExp("[^/]$", H.JSSyntaxRegExp_makeNative("[^/]$", false, true, false), null, null), new H.JSSyntaxRegExp("^/", H.JSSyntaxRegExp_makeNative("^/", false, true, false), null, null), null);
});
Isolate.$lazy($, "windows", "Style_windows", "get$Style_windows", function() {
  return new T.WindowsStyle("windows", "\\", C.List_WnV, new H.JSSyntaxRegExp("[/\\\\]", H.JSSyntaxRegExp_makeNative("[/\\\\]", false, true, false), null, null), new H.JSSyntaxRegExp("[^/\\\\]$", H.JSSyntaxRegExp_makeNative("[^/\\\\]$", false, true, false), null, null), new H.JSSyntaxRegExp("^(\\\\\\\\[^\\\\]+\\\\[^\\\\/]+|[a-zA-Z]:[/\\\\])", H.JSSyntaxRegExp_makeNative("^(\\\\\\\\[^\\\\]+\\\\[^\\\\/]+|[a-zA-Z]:[/\\\\])", false, true, false), null, null), new H.JSSyntaxRegExp("^[/\\\\](?![/\\\\])", H.JSSyntaxRegExp_makeNative("^[/\\\\](?![/\\\\])", false, true, false), null, null));
});
Isolate.$lazy($, "url", "Style_url", "get$Style_url", function() {
  return new E.UrlStyle("url", "/", C.List_cSk, new H.JSSyntaxRegExp("/", H.JSSyntaxRegExp_makeNative("/", false, true, false), null, null), new H.JSSyntaxRegExp("(^[a-zA-Z][-+.a-zA-Z\\d]*://|[^/])$", H.JSSyntaxRegExp_makeNative("(^[a-zA-Z][-+.a-zA-Z\\d]*://|[^/])$", false, true, false), null, null), new H.JSSyntaxRegExp("[a-zA-Z][-+.a-zA-Z\\d]*://[^/]*", H.JSSyntaxRegExp_makeNative("[a-zA-Z][-+.a-zA-Z\\d]*://[^/]*", false, true, false), null, null), new H.JSSyntaxRegExp("^/", H.JSSyntaxRegExp_makeNative("^/", false, true, false), null, null));
});
Isolate.$lazy($, "platform", "Style_platform", "get$Style_platform", function() {
  return S.Style__getPlatformStyle();
});
Isolate.$lazy($, "_terseRegExp", "_terseRegExp", "get$_terseRegExp", function() {
  return new H.JSSyntaxRegExp("(-patch)?(/.*)?$", H.JSSyntaxRegExp_makeNative("(-patch)?(/.*)?$", false, true, false), null, null);
});
Isolate.$lazy($, "_v8Trace", "_v8Trace", "get$_v8Trace", function() {
  return new H.JSSyntaxRegExp("\\n    ?at ", H.JSSyntaxRegExp_makeNative("\\n    ?at ", false, true, false), null, null);
});
Isolate.$lazy($, "_v8TraceLine", "_v8TraceLine", "get$_v8TraceLine", function() {
  return new H.JSSyntaxRegExp("    ?at ", H.JSSyntaxRegExp_makeNative("    ?at ", false, true, false), null, null);
});
Isolate.$lazy($, "_safariTrace", "_safariTrace", "get$_safariTrace", function() {
  return new H.JSSyntaxRegExp("^([0-9A-Za-z_$]*@)?.*:\\d*:\\d*$", H.JSSyntaxRegExp_makeNative("^([0-9A-Za-z_$]*@)?.*:\\d*:\\d*$", true, true, false), null, null);
});
Isolate.$lazy($, "_firefoxTrace", "_firefoxTrace", "get$_firefoxTrace", function() {
  return new H.JSSyntaxRegExp("^([.0-9A-Za-z_$/<]|\\(.*\\))*@", H.JSSyntaxRegExp_makeNative("^([.0-9A-Za-z_$/<]|\\(.*\\))*@", false, true, false), null, null);
});
Isolate.$lazy($, "_friendlyTrace", "_friendlyTrace", "get$_friendlyTrace", function() {
  return new H.JSSyntaxRegExp("^[^\\s]+( \\d+(:\\d+)?)?[ \\t]+[^\\s]+$", H.JSSyntaxRegExp_makeNative("^[^\\s]+( \\d+(:\\d+)?)?[ \\t]+[^\\s]+$", true, true, false), null, null);
});
Isolate.$lazy($, "_testCases", "_testCases", "get$_testCases", function() {
  return H.setRuntimeTypeInfo([], [N.TestCase]);
});
Isolate.$lazy($, "testCases", "testCases", "get$testCases", function() {
  return H.setRuntimeTypeInfo(new P.UnmodifiableListView($.get$_testCases()), [N.TestCase]);
});
Isolate.$lazy($, "_rootContext", "_rootContext", "get$_rootContext", function() {
  var t1 = new N._GroupContext(null, "", null, null);
  t1._testSetup = null;
  t1._testTeardown = null;
  return t1;
});
Isolate.$lazy($, "_currentContext", "_currentContext", "get$_currentContext", function() {
  return $.get$_rootContext();
});
Isolate.$lazy($, "_lastBreath", "_lastBreath", "get$_lastBreath", function() {
  var t1 = Date.now();
  new P.DateTime(t1, false).DateTime$_now$0();
  return t1;
});
// Native classes

init.metadata = ["object",
"sender",
"e",
{func: "dynamic__String", args: [P.String]},
"closure",
"isolate",
"numberOfArguments",
"arg1",
"arg2",
"arg3",
"arg4",
{func: "void__void_", void: true, args: [{func: "void_", void: true}]},
{func: "void_", void: true},
{func: "void__dynamic", void: true, args: [null]},
"value",
{func: "void__dynamic__StackTrace", void: true, args: [null], opt: [P.StackTrace]},
,
"error",
"stackTrace",
{func: "void__Zone_ZoneDelegate_Zone_dynamic_StackTrace", void: true, args: [P.Zone, P.ZoneDelegate, P.Zone, null, P.StackTrace]},
"self",
"parent",
"zone",
{func: "dynamic__Zone_ZoneDelegate_Zone_args0", args: [P.Zone, P.ZoneDelegate, P.Zone, {func: "args0"}]},
"f",
{func: "dynamic__Zone_ZoneDelegate_Zone_args1_dynamic", args: [P.Zone, P.ZoneDelegate, P.Zone, {func: "args1", args: [null]}, null]},
"arg",
{func: "dynamic__Zone_ZoneDelegate_Zone_args2_dynamic_dynamic", args: [P.Zone, P.ZoneDelegate, P.Zone, {func: "args2", args: [null, null]}, null, null]},
{func: "ZoneCallback__Zone_ZoneDelegate_Zone_args0", ret: {func: "args0"}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: "args0"}]},
{func: "ZoneUnaryCallback__Zone_ZoneDelegate_Zone_args1", ret: {func: "args1", args: [null]}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: "args1", args: [null]}]},
{func: "ZoneBinaryCallback__Zone_ZoneDelegate_Zone_args2", ret: {func: "args2", args: [null, null]}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: "args2", args: [null, null]}]},
{func: "void__Zone_ZoneDelegate_Zone_args0", void: true, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: "args0"}]},
{func: "Timer__Zone_ZoneDelegate_Zone_Duration_void_", ret: P.Timer, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Duration, {func: "void_", void: true}]},
"duration",
"callback",
{func: "Timer__Zone_ZoneDelegate_Zone_Duration_void__Timer", ret: P.Timer, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Duration, {func: "void__Timer", void: true, args: [P.Timer]}]},
{func: "void__Zone_ZoneDelegate_Zone_String", void: true, args: [P.Zone, P.ZoneDelegate, P.Zone, P.String]},
"line",
{func: "void__String", void: true, args: [P.String]},
{func: "Zone__Zone_ZoneDelegate_Zone_ZoneSpecification_Map", ret: P.Zone, args: [P.Zone, P.ZoneDelegate, P.Zone, P.ZoneSpecification, P.Map]},
"specification",
"zoneValues",
{func: "bool__dynamic_dynamic", ret: P.bool, args: [null, null]},
"a",
"b",
{func: "int__dynamic", ret: P.$int, args: [null]},
{func: "Object__dynamic", ret: P.Object, args: [null]},
{func: "int__Comparable_Comparable", ret: P.$int, args: [P.Comparable, P.Comparable]},
{func: "bool__Object_Object", ret: P.bool, args: [P.Object, P.Object]},
{func: "int__Object", ret: P.$int, args: [P.Object]},
{func: "String__String", ret: P.String, args: [P.String]},
"encodedComponent",
{func: "String__Uri__Map", ret: P.String, args: [P.Uri], named: {environment: [P.Map, P.String, P.String]}},
{func: "num__num_num", ret: P.num, args: [P.num, P.num]},
{func: "String__dynamic_Matcher_String_Map_bool", ret: P.String, args: [null, Q.Matcher, P.String, P.Map, P.bool]},
{func: "args0"},
{func: "args2", args: [null, null]},
{func: "dynamic__String_dynamic", args: [P.String, null]},
{func: "args1", args: [null]},
{func: "dynamic__dynamic_String", args: [null, P.String]},
"_",
{func: "dynamic__void_", args: [{func: "void_", void: true}]},
"theError",
"theStackTrace",
{func: "dynamic__Object", args: [P.Object]},
{func: "void___dynamic", void: true, opt: [null]},
{func: "void__Object__StackTrace", void: true, args: [P.Object], opt: [P.StackTrace]},
{func: "dynamic__dynamic__dynamic", args: [null], opt: [null]},
{func: "bool_", ret: P.bool},
"ignored",
"element",
{func: "dynamic__bool", args: [P.bool]},
"data",
{func: "Future_", ret: P.Future},
{func: "void__Object_StackTrace", void: true, args: [P.Object, P.StackTrace]},
"s",
{func: "dynamic__dynamic_StackTrace", args: [null, P.StackTrace]},
{func: "void___DelayedEvent", void: true, args: [P._DelayedEvent]},
{func: "void__dynamic_StackTrace", void: true, args: [null, P.StackTrace]},
{func: "void__dynamic__dynamic", void: true, args: [null], opt: [null]},
{func: "dynamic__Zone_ZoneDelegate_Zone_dynamic_StackTrace", args: [P.Zone, P.ZoneDelegate, P.Zone, null, P.StackTrace]},
"each",
"key",
{func: "void__List", void: true, args: [[P.List, P.$int]]},
{func: "dynamic__EventSink", args: [P.EventSink]},
{func: "void__Object", void: true, args: [P.Object]},
{func: "int__dynamic_int", ret: P.$int, args: [null, P.$int]},
{func: "void__int_int", void: true, args: [P.$int, P.$int]},
{func: "dynamic__Symbol_dynamic", args: [P.Symbol0, null]},
{func: "DateTime__Duration", ret: P.DateTime, args: [P.Duration]},
{func: "String__int", ret: P.String, args: [P.$int]},
{func: "bool__int", ret: P.bool, args: [P.$int]},
{func: "int__dynamic_dynamic", ret: P.$int, args: [null, null]},
"byteString",
{func: "void__String__dynamic", void: true, args: [P.String], opt: [null]},
{func: "int__int_int", ret: P.$int, args: [P.$int, P.$int]},
"name",
{func: "void__String_dynamic", void: true, args: [P.String, null]},
{func: "dynamic__String_List", args: [P.String, [P.List, P.String]]},
{func: "String_", ret: P.String},
{func: "bool__String", ret: P.bool, args: [P.String]},
"headerValue",
{func: "dynamic__String_String", args: [P.String, P.String]},
"cookie",
"request",
{func: "Future_0", ret: [P.Future, P.HttpClientResponse]},
{func: "List_", ret: [P.List, P.String]},
{func: "_Credentials___AuthenticationScheme", ret: P._Credentials, args: [P._AuthenticationScheme]},
{func: "void___Credentials", void: true, args: [P._Credentials]},
{func: "Future___AuthenticationScheme_String", ret: P.Future, args: [P._AuthenticationScheme, P.String]},
"credsAvailable",
"list",
"v",
"incoming",
{func: "dynamic__dynamic__StackTrace", args: [null], opt: [P.StackTrace]},
"closing",
"response",
"secureSocket",
"certificate",
{func: "bool__X509Certificate", ret: P.bool, args: [P.X509Certificate]},
"tunnel",
"info",
{func: "dynamic___HttpClientRequest", args: [P._HttpClientRequest]},
{func: "Future__dynamic", ret: [P.Future, P._ConnectionInfo], args: [null]},
{func: "Future___bool", ret: P.Future, named: {force: P.bool}},
false,
"force",
"socket",
{func: "dynamic__Socket", args: [P.Socket]},
"buffer",
"dummy",
{func: "void__RawSocketEvent", void: true, args: [P.RawSocketEvent]},
"event",
{func: "List__int", ret: [P.List, P.$int], args: [P.$int]},
{func: "int__int", ret: P.$int, args: [P.$int]},
"r",
{func: "dynamic__HttpClientRequest", args: [P.HttpClientRequest]},
{func: "dynamic__HttpClientResponse", args: [P.HttpClientResponse]},
"contents",
{func: "dynamic__List", args: [[P.List, P.$int]]},
{func: "void__HttpRequest", void: true, args: [P.HttpRequest]},
{func: "dynamic__HttpServer", args: [P.HttpServer]},
{func: "Description__String", ret: Q.Description, args: [P.String]},
{func: "dynamic__Function__dynamic", args: [P.Function], opt: [null]},
"frame",
"result",
{func: "dynamic__StartResult", args: [K.StartResult]},
{func: "dynamic__RequestResultSv", args: [K.RequestResultSv]},
{func: "dynamic___dynamic", opt: [null]},
C.C__ArgPlaceHolder,
"a0",
{func: "dynamic___dynamic_dynamic", opt: [null, null]},
"a1",
{func: "dynamic___dynamic_dynamic_dynamic", opt: [null, null, null]},
"a2",
{func: "dynamic___dynamic_dynamic_dynamic_dynamic", opt: [null, null, null, null]},
"a3",
{func: "dynamic___dynamic_dynamic_dynamic_dynamic_dynamic", opt: [null, null, null, null, null]},
"a4",
{func: "dynamic___dynamic_dynamic_dynamic_dynamic_dynamic_dynamic", opt: [null, null, null, null, null, null]},
"a5",
"stack",
];
$ = null;
Isolate = Isolate.$finishIsolateConstructor(Isolate);
$ = new Isolate();
function convertToFastObject(properties) {
  function MyClass() {
  }
  MyClass.prototype = properties;
  new MyClass();
  return properties;
}
;
A = convertToFastObject(A);
B = convertToFastObject(B);
C = convertToFastObject(C);
D = convertToFastObject(D);
E = convertToFastObject(E);
F = convertToFastObject(F);
G = convertToFastObject(G);
H = convertToFastObject(H);
J = convertToFastObject(J);
K = convertToFastObject(K);
L = convertToFastObject(L);
M = convertToFastObject(M);
N = convertToFastObject(N);
O = convertToFastObject(O);
P = convertToFastObject(P);
Q = convertToFastObject(Q);
R = convertToFastObject(R);
S = convertToFastObject(S);
T = convertToFastObject(T);
U = convertToFastObject(U);
V = convertToFastObject(V);
W = convertToFastObject(W);
X = convertToFastObject(X);
Y = convertToFastObject(Y);
Z = convertToFastObject(Z);
function init() {
  Isolate.$isolateProperties = {};
  function generateAccessor(fieldDescriptor, accessors, cls) {
    var fieldInformation = fieldDescriptor.split("-");
    var field = fieldInformation[0];
    var len = field.length;
    var code = field.charCodeAt(len - 1);
    var reflectable;
    if (fieldInformation.length > 1)
      reflectable = true;
    else
      reflectable = false;
    code = code >= 60 && code <= 64 ? code - 59 : code >= 123 && code <= 126 ? code - 117 : code >= 37 && code <= 43 ? code - 27 : 0;
    if (code) {
      var getterCode = code & 3;
      var setterCode = code >> 2;
      var accessorName = field = field.substring(0, len - 1);
      var divider = field.indexOf(":");
      if (divider > 0) {
        accessorName = field.substring(0, divider);
        field = field.substring(divider + 1);
      }
      if (getterCode) {
        var args = getterCode & 2 ? "receiver" : "";
        var receiver = getterCode & 1 ? "this" : "receiver";
        var body = "return " + receiver + "." + field;
        var property = cls + ".prototype.get$" + accessorName + "=";
        var fn = "function(" + args + "){" + body + "}";
        if (reflectable)
          accessors.push(property + "$reflectable(" + fn + ");\n");
        else
          accessors.push(property + fn + ";\n");
      }
      if (setterCode) {
        var args = setterCode & 2 ? "receiver, value" : "value";
        var receiver = setterCode & 1 ? "this" : "receiver";
        var body = receiver + "." + field + " = value";
        var property = cls + ".prototype.set$" + accessorName + "=";
        var fn = "function(" + args + "){" + body + "}";
        if (reflectable)
          accessors.push(property + "$reflectable(" + fn + ");\n");
        else
          accessors.push(property + fn + ";\n");
      }
    }
    return field;
  }
  Isolate.$isolateProperties.$generateAccessor = generateAccessor;
  function defineClass(name, cls, fields) {
    var accessors = [];
    var str = "function " + cls + "(";
    var body = "";
    for (var i = 0; i < fields.length; i++) {
      if (i != 0)
        str += ", ";
      var field = generateAccessor(fields[i], accessors, cls);
      var parameter = "parameter_" + field;
      str += parameter;
      body += "this." + field + " = " + parameter + ";\n";
    }
    str += ") {\n" + body + "}\n";
    str += cls + ".builtin$cls=\"" + name + "\";\n";
    str += "$desc=$collectedClasses." + cls + ";\n";
    str += "if($desc instanceof Array) $desc = $desc[1];\n";
    str += cls + ".prototype = $desc;\n";
    if (typeof defineClass.name != "string") {
      str += cls + ".name=\"" + cls + "\";\n";
    }
    str += accessors.join("");
    return str;
  }
  var inheritFrom = function() {
    function tmp() {
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    return function(constructor, superConstructor) {
      tmp.prototype = superConstructor.prototype;
      var object = new tmp();
      var properties = constructor.prototype;
      for (var member in properties)
        if (hasOwnProperty.call(properties, member))
          object[member] = properties[member];
      object.constructor = constructor;
      constructor.prototype = object;
      return object;
    };
  }();
  Isolate.$finishClasses = function(collectedClasses, isolateProperties, existingIsolateProperties) {
    var pendingClasses = {};
    if (!init.allClasses)
      init.allClasses = {};
    var allClasses = init.allClasses;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    if (typeof dart_precompiled == "function") {
      var constructors = dart_precompiled(collectedClasses);
    } else {
      var combinedConstructorFunction = "function $reflectable(fn){fn.$reflectable=1;return fn};\n" + "var $desc;\n";
      var constructorsList = [];
    }
    for (var cls in collectedClasses) {
      if (hasOwnProperty.call(collectedClasses, cls)) {
        var desc = collectedClasses[cls];
        if (desc instanceof Array)
          desc = desc[1];
        var classData = desc["^"], supr, name = cls, fields = classData;
        if (typeof classData == "string") {
          var split = classData.split("/");
          if (split.length == 2) {
            name = split[0];
            fields = split[1];
          }
        }
        var s = fields.split(";");
        fields = s[1] == "" ? [] : s[1].split(",");
        supr = s[0];
        split = supr.split(":");
        if (split.length == 2) {
          supr = split[0];
          var functionSignature = split[1];
          if (functionSignature)
            desc.$signature = function(s) {
              return function() {
                return init.metadata[s];
              };
            }(functionSignature);
        }
        if (supr && supr.indexOf("+") > 0) {
          s = supr.split("+");
          supr = s[0];
          var mixin = collectedClasses[s[1]];
          if (mixin instanceof Array)
            mixin = mixin[1];
          for (var d in mixin) {
            if (hasOwnProperty.call(mixin, d) && !hasOwnProperty.call(desc, d))
              desc[d] = mixin[d];
          }
        }
        if (typeof dart_precompiled != "function") {
          combinedConstructorFunction += defineClass(name, cls, fields);
          constructorsList.push(cls);
        }
        if (supr)
          pendingClasses[cls] = supr;
      }
    }
    if (typeof dart_precompiled != "function") {
      combinedConstructorFunction += "return [\n  " + constructorsList.join(",\n  ") + "\n]";
      var constructors = new Function("$collectedClasses", combinedConstructorFunction)(collectedClasses);
      combinedConstructorFunction = null;
    }
    for (var i = 0; i < constructors.length; i++) {
      var constructor = constructors[i];
      var cls = constructor.name;
      var desc = collectedClasses[cls];
      var globalObject = isolateProperties;
      if (desc instanceof Array) {
        globalObject = desc[0] || isolateProperties;
        desc = desc[1];
      }
      allClasses[cls] = constructor;
      globalObject[cls] = constructor;
    }
    constructors = null;
    var finishedClasses = {};
    init.interceptorsByTag = Object.create(null);
    init.leafTags = {};
    function finishClass(cls) {
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      if (hasOwnProperty.call(finishedClasses, cls))
        return;
      finishedClasses[cls] = true;
      var superclass = pendingClasses[cls];
      if (!superclass || typeof superclass != "string")
        return;
      finishClass(superclass);
      var constructor = allClasses[cls];
      var superConstructor = allClasses[superclass];
      if (!superConstructor)
        superConstructor = existingIsolateProperties[superclass];
      var prototype = inheritFrom(constructor, superConstructor);
      if (hasOwnProperty.call(prototype, "%")) {
        var nativeSpec = prototype["%"].split(";");
        if (nativeSpec[0]) {
          var tags = nativeSpec[0].split("|");
          for (var i = 0; i < tags.length; i++) {
            init.interceptorsByTag[tags[i]] = constructor;
            init.leafTags[tags[i]] = true;
          }
        }
        if (nativeSpec[1]) {
          tags = nativeSpec[1].split("|");
          if (nativeSpec[2]) {
            var subclasses = nativeSpec[2].split("|");
            for (var i = 0; i < subclasses.length; i++) {
              var subclass = allClasses[subclasses[i]];
              subclass.$nativeSuperclassTag = tags[0];
            }
          }
          for (i = 0; i < tags.length; i++) {
            init.interceptorsByTag[tags[i]] = constructor;
            init.leafTags[tags[i]] = false;
          }
        }
      }
    }
    for (var cls in pendingClasses)
      finishClass(cls);
  };
  Isolate.$lazy = function(prototype, staticName, fieldName, getterName, lazyValue) {
    var sentinelUndefined = {};
    var sentinelInProgress = {};
    prototype[fieldName] = sentinelUndefined;
    prototype[getterName] = function() {
      var result = $[fieldName];
      try {
        if (result === sentinelUndefined) {
          $[fieldName] = sentinelInProgress;
          try {
            result = $[fieldName] = lazyValue();
          } finally {
            if (result === sentinelUndefined)
              if ($[fieldName] === sentinelInProgress)
                $[fieldName] = null;
          }
        } else {
          if (result === sentinelInProgress)
            H.throwCyclicInit(staticName);
        }
        return result;
      } finally {
        $[getterName] = function() {
          return this[fieldName];
        };
      }
    };
  };
  Isolate.$finishIsolateConstructor = function(oldIsolate) {
    var isolateProperties = oldIsolate.$isolateProperties;
    function Isolate() {
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      for (var staticName in isolateProperties)
        if (hasOwnProperty.call(isolateProperties, staticName))
          this[staticName] = isolateProperties[staticName];
      function ForceEfficientMap() {
      }
      ForceEfficientMap.prototype = this;
      new ForceEfficientMap();
    }
    Isolate.prototype = oldIsolate.prototype;
    Isolate.prototype.constructor = Isolate;
    Isolate.$isolateProperties = isolateProperties;
    Isolate.$finishClasses = oldIsolate.$finishClasses;
    Isolate.makeConstantList = oldIsolate.makeConstantList;
    return Isolate;
  };
}
!function() {
  function intern(s) {
    var o = {};
    o[s] = 1;
    return Object.keys(convertToFastObject(o))[0];
  }
  init.getIsolateTag = function(name) {
    return intern("___dart_" + name + init.isolateTag);
  };
  var tableProperty = "___dart_isolate_tags_";
  var usedProperties = Object[tableProperty] || (Object[tableProperty] = Object.create(null));
  var rootProperty = "_ZxYxX";
  for (var i = 0;; i++) {
    var property = intern(rootProperty + "_" + i + "_");
    if (!(property in usedProperties)) {
      usedProperties[property] = 1;
      init.isolateTag = property;
      break;
    }
  }
}();
init.dispatchPropertyName = init.getIsolateTag("dispatch_record");
// BEGIN invoke [main].
;(function(callback) {
  if (typeof document === "undefined") {
    callback(null);
    return;
  }
  if (document.currentScript) {
    callback(document.currentScript);
    return;
  }
  var scripts = document.scripts;
  function onLoad(event) {
    for (var i = 0; i < scripts.length; ++i) {
      scripts[i].removeEventListener("load", onLoad, false);
    }
    callback(event.target);
  }
  for (var i = 0; i < scripts.length; ++i) {
    scripts[i].addEventListener("load", onLoad, false);
  }
})(function(currentScript) {
  init.currentScript = currentScript;
  if (typeof dartMainRunner === "function") {
    dartMainRunner(function(a) {
      H.startRootIsolate(T.main$closure(), a);
    }, []);
  } else {
    (function(a) {
      H.startRootIsolate(T.main$closure(), a);
    })([]);
  }
});
;
// END invoke [main].
})()

//# sourceMappingURL=trackerserver_test.dart.js.map
